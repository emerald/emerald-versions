diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/Makefile.am ubc-1.05alpha-src/vm/Makefile.am
--- sourceforge-1.06alpha/vm/Makefile.am	2017-12-11 17:59:03.087714500 +0100
+++ ubc-1.05alpha-src/vm/Makefile.am	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-SUBDIRS = src
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/cctab.c ubc-1.05alpha-src/vm/src/cctab.c
--- sourceforge-1.06alpha/vm/src/cctab.c	2017-12-11 17:59:03.087714500 +0100
+++ ubc-1.05alpha-src/vm/src/cctab.c	2017-12-11 17:59:03.421711955 +0100
@@ -9,6 +9,11 @@
 #include "assert.h"
 #include "cctab.h"
 
+static int notselected(void) 
+{
+  assert(0);
+  return 1;
+}
 CCallDescriptor EMSTREAM_table[] = { 
   { (ccallFunction) streamOpen, "EMS_OPEN", "ixS" },
   { (ccallFunction) streamClose, "EMS_CLOSE", "vxi" },
@@ -26,7 +31,6 @@
   { (ccallFunction) streamFlush, "EMS_FLUSH", "vxi" },
   { (ccallFunction) streamBind, "EMS_BIND", "iS" },
   { (ccallFunction) streamAccept, "EMS_ACCEPT", "ii" },
-  { (ccallFunction) streamRawRead, "EMS_RAWREAD", "ixip" },
 };
 CCallDescriptor STRING_table[] = { 
   { (ccallFunction) charIsAlpha, "EMCH_ISALPHA", "bi" },
@@ -55,20 +59,246 @@
 CCallDescriptor MISK_table[] = { 
   { (ccallFunction) die, "UEXIT", "vi" },
   { (ccallFunction) mgetenv, "UGETENV", "sS" },
-  { (ccallFunction) opendir, "UOPENDIR", "pS" },
-  { (ccallFunction) mreaddir, "UREADDIR", "sp" },
-  { (ccallFunction) closedir, "UCLOSEDIR", "vp" },
+};
+CCallDescriptor REGEXP_table[] = { 
+  { (ccallFunction) notselected, "REG_EXEC", "bpS" },
+  { (ccallFunction) notselected, "REG_SUB", "SpS" },
+  { (ccallFunction) notselected, "REG_COMP", "pS" },
+};
+CCallDescriptor XFORMS_table[] = { 
+  { (ccallFunction) notselected, "FL_INITIALIZE", "vS" },
+  { (ccallFunction) notselected, "FL_BGN_FORM", "iiii" },
+  { (ccallFunction) notselected, "FL_END_FORM", "v" },
+  { (ccallFunction) notselected, "FL_SHOW_FORM", "viiiS" },
+  { (ccallFunction) notselected, "FL_DO_FORMS", "i" },
+  { (ccallFunction) notselected, "FL_HIDE_FORM", "vi" },
+  { (ccallFunction) notselected, "FL_GET_DISPLAY", "i" },
+  { (ccallFunction) notselected, "FL_CREATE_BOX", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_CREATE_FRAME", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_CREATE_TEXT", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_CREATE_BITMAP", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_SET_BITMAP_DATA", "viiiS" },
+  { (ccallFunction) notselected, "FL_SET_BITMAP_FILE", "viS" },
+  { (ccallFunction) notselected, "FL_CREATE_CLOCK", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_CREATE_CHART", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_SET_CHART_MAXNUMB", "vii" },
+  { (ccallFunction) notselected, "FL_CLEAR_CHART", "vi" },
+  { (ccallFunction) notselected, "FL_ADD_CHART_VALUE", "vifSi" },
+  { (ccallFunction) notselected, "FL_INSERT_CHART_VALUE", "viifSi" },
+  { (ccallFunction) notselected, "FL_REPLACE_CHART_VALUE", "viifSi" },
+  { (ccallFunction) notselected, "FL_SET_CHART_BOUNDS", "viff" },
+  { (ccallFunction) notselected, "FL_SET_CHART_AUTOSIZE", "vii" },
+  { (ccallFunction) notselected, "FL_CREATE_BUTTON", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_CREATE_LIGHTBUTTON", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_CREATE_ROUNDBUTTON", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_CREATE_CHECKBUTTON", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_CREATE_BITMAPBUTTON", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_SET_BUTTON", "vii" },
+  { (ccallFunction) notselected, "FL_GET_BUTTON", "ii" },
+  { (ccallFunction) notselected, "FL_GET_BUTTON_NUMB", "ii" },
+  { (ccallFunction) notselected, "FL_SET_BITMAPBUTTON_DATA", "viiiS" },
+  { (ccallFunction) notselected, "FL_SET_BITMAPBUTTON_FILE", "viS" },
+  { (ccallFunction) notselected, "FL_CREATE_SLIDER", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_CREATE_VALSLIDER", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_SET_SLIDER_VALUE", "vif" },
+  { (ccallFunction) notselected, "FL_GET_SLIDER_VALUE", "fi" },
+  { (ccallFunction) notselected, "FL_SET_SLIDER_BOUNDS", "viff" },
+  { (ccallFunction) notselected, "FL_SET_SLIDER_STEP", "vif" },
+  { (ccallFunction) notselected, "FL_SET_SLIDER_SIZE", "vif" },
+  { (ccallFunction) notselected, "FL_SET_SLIDER_PRECISION", "vii" },
+  { (ccallFunction) notselected, "FL_CREATE_DIAL", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_SET_DIAL_VALUE", "vif" },
+  { (ccallFunction) notselected, "FL_GET_DIAL_VALUE", "fi" },
+  { (ccallFunction) notselected, "FL_SET_DIAL_BOUNDS", "viff" },
+  { (ccallFunction) notselected, "FL_SET_DIAL_ANGLES", "viff" },
+  { (ccallFunction) notselected, "FL_SET_DIAL_CROSS", "vii" },
+  { (ccallFunction) notselected, "FL_SET_DIAL_STEP", "vif" },
+  { (ccallFunction) notselected, "FL_CREATE_COUNTER", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_SET_COUNTER_VALUE", "vif" },
+  { (ccallFunction) notselected, "FL_GET_COUNTER_VALUE", "fi" },
+  { (ccallFunction) notselected, "FL_SET_COUNTER_BOUNDS", "viff" },
+  { (ccallFunction) notselected, "FL_SET_COUNTER_STEP", "viff" },
+  { (ccallFunction) notselected, "FL_SET_COUNTER_PRECISION", "vii" },
+  { (ccallFunction) notselected, "FL_CREATE_INPUT", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_GET_INPUT", "si" },
+  { (ccallFunction) notselected, "FL_SET_INPUT", "viS" },
+  { (ccallFunction) notselected, "FL_SET_INPUT_SELECTED", "vii" },
+  { (ccallFunction) notselected, "FL_SET_INPUT_SELECTED_RANGE", "viii" },
+  { (ccallFunction) notselected, "FL_SET_INPUT_CURSORPOS", "viii" },
+  { (ccallFunction) notselected, "FL_GET_INPUT_CURSORXPOS", "ii" },
+  { (ccallFunction) notselected, "FL_SET_INPUT_MAXCHARS", "vii" },
+  { (ccallFunction) notselected, "FL_SET_INPUT_SCROLL", "vii" },
+  { (ccallFunction) notselected, "FL_SETPUP_FONTSIZE", "vi" },
+  { (ccallFunction) notselected, "FL_SETPUP_FONTSTYLE", "vi" },
+  { (ccallFunction) notselected, "FL_CREATE_MENU", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_GET_MENU", "ii" },
+  { (ccallFunction) notselected, "FL_GET_MENU_TEXT", "si" },
+  { (ccallFunction) notselected, "FL_GET_MENU_ITEM_TEXT", "sii" },
+  { (ccallFunction) notselected, "FL_GET_MENU_MAXITEMS", "ii" },
+  { (ccallFunction) notselected, "FL_SET_MENU", "viS" },
+  { (ccallFunction) notselected, "FL_CLEAR_MENU", "vi" },
+  { (ccallFunction) notselected, "FL_ADDTO_MENU", "viS" },
+  { (ccallFunction) notselected, "FL_REPLACE_MENU_ITEM", "viiS" },
+  { (ccallFunction) notselected, "FL_DELETE_MENU_ITEM", "vii" },
+  { (ccallFunction) notselected, "FL_SET_MENU_ITEM_MODE", "viii" },
+  { (ccallFunction) notselected, "FL_GET_MENU_ITEM_MODE", "iii" },
+  { (ccallFunction) notselected, "FL_SHOW_MENU_SYMBOL", "vii" },
+  { (ccallFunction) notselected, "FL_SET_MENU_POPUP", "vii" },
+  { (ccallFunction) notselected, "FL_CREATE_CHOICE", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_CLEAR_CHOICE", "vi" },
+  { (ccallFunction) notselected, "FL_ADDTO_CHOICE", "viS" },
+  { (ccallFunction) notselected, "FL_DELETE_CHOICE", "vii" },
+  { (ccallFunction) notselected, "FL_REPLACE_CHOICE", "viiS" },
+  { (ccallFunction) notselected, "FL_GET_CHOICE", "ii" },
+  { (ccallFunction) notselected, "FL_GET_CHOICE_TEXT", "si" },
+  { (ccallFunction) notselected, "FL_GET_CHOICE_ITEM_TEXT", "sii" },
+  { (ccallFunction) notselected, "FL_GET_CHOICE_MAXITEMS", "ii" },
+  { (ccallFunction) notselected, "FL_SET_CHOICE", "vii" },
+  { (ccallFunction) notselected, "FL_SET_CHOICE_TEXT", "viS" },
+  { (ccallFunction) notselected, "FL_SET_CHOICE_ITEM_MODE", "viii" },
+  { (ccallFunction) notselected, "FL_SET_CHOICE_ALIGN", "vii" },
+  { (ccallFunction) notselected, "FL_SET_CHOICE_FONTSIZE", "vii" },
+  { (ccallFunction) notselected, "FL_SET_CHOICE_FONTSTYLE", "vii" },
+  { (ccallFunction) notselected, "FL_CREATE_BROWSER", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_CLEAR_BROWSER", "vi" },
+  { (ccallFunction) notselected, "FL_ADDTO_BROWSER", "viS" },
+  { (ccallFunction) notselected, "FL_ADD_BROWSER_LINE", "viS" },
+  { (ccallFunction) notselected, "FL_INSERT_BROWSER_LINE", "viiS" },
+  { (ccallFunction) notselected, "FL_DELETE_BROWSER_LINE", "vii" },
+  { (ccallFunction) notselected, "FL_REPLACE_BROWSER_LINE", "viiS" },
+  { (ccallFunction) notselected, "FL_GET_BROWSER_LINE", "sii" },
+  { (ccallFunction) notselected, "FL_SELECT_BROWSER_LINE", "vii" },
+  { (ccallFunction) notselected, "FL_DESELECT_BROWSER_LINE", "vii" },
+  { (ccallFunction) notselected, "FL_DESELECT_BROWSER", "vi" },
+  { (ccallFunction) notselected, "FL_ISSELECTED_BROWSER_LINE", "iii" },
+  { (ccallFunction) notselected, "FL_GET_BROWSER", "ii" },
+  { (ccallFunction) notselected, "FL_GET_BROWSER_MAXLINE", "ii" },
+  { (ccallFunction) notselected, "FL_GET_BROWSER_SCREENLINES", "ii" },
+  { (ccallFunction) notselected, "FL_GET_BROWSER_TOPLINE", "ii" },
+  { (ccallFunction) notselected, "FL_SET_BROWSER_TOPLINE", "vii" },
+  { (ccallFunction) notselected, "FL_SET_BROWSER_XOFFSET", "vii" },
+  { (ccallFunction) notselected, "FL_SET_BROWSER_FONTSIZE", "vii" },
+  { (ccallFunction) notselected, "FL_SET_BROWSER_FONTSTYLE", "vii" },
+  { (ccallFunction) notselected, "FL_CREATE_TIMER", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_SET_TIMER", "vif" },
+  { (ccallFunction) notselected, "FL_GET_TIMER", "fi" },
+  { (ccallFunction) notselected, "FL_CREATE_XYPLOT", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_SET_OBJECT_LSIZE", "vii" },
+  { (ccallFunction) notselected, "FL_SET_FONT", "vii" },
+  { (ccallFunction) notselected, "FL_SET_OBJECT_RETURN", "vii" },
+  { (ccallFunction) notselected, "FL_ADD_OBJECT", "vii" },
+  { (ccallFunction) notselected, "FL_SET_OBJECT_SHORTCUT", "viSi" },
+  { (ccallFunction) notselected, "FL_REDRAW_OBJECT", "vi" },
+  { (ccallFunction) notselected, "FL_FLUSH", "v" },
+  { (ccallFunction) notselected, "FL_GET_STRING_WIDTH", "iiiSi" },
+  { (ccallFunction) notselected, "FL_SET_OBJECT_BOXTYPE", "vii" },
+  { (ccallFunction) notselected, "FL_SET_OBJECT_LALIGN", "vii" },
+  { (ccallFunction) notselected, "FL_CREATE_PIXMAP", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_SET_PIXMAP_FILE", "viS" },
+  { (ccallFunction) notselected, "FL_SET_PIXMAP_PIXMAP", "viii" },
+  { (ccallFunction) notselected, "FL_FREE_PIXMAP_PIXMAP", "vi" },
+  { (ccallFunction) notselected, "FL_DELETE_OBJECT", "vi" },
+  { (ccallFunction) notselected, "FL_SET_OBJECT_LABEL", "viS" },
+  { (ccallFunction) notselected, "FL_HIDE_OBJECT", "vi" },
+  { (ccallFunction) notselected, "FL_SHOW_OBJECT", "vi" },
+  { (ccallFunction) notselected, "FL_FREEZE_FORM", "vi" },
+  { (ccallFunction) notselected, "FL_UNFREEZE_FORM", "vi" },
+  { (ccallFunction) notselected, "FL_SET_OBJECT_POSITION", "viii" },
+  { (ccallFunction) notselected, "FL_SET_FORM_POSITION", "viii" },
+  { (ccallFunction) notselected, "FL_REDRAW_FORM", "vi" },
+  { (ccallFunction) notselected, "FL_RINGBELL", "v" },
+  { (ccallFunction) notselected, "FL_CREATE_FREE", "iiiiiiS" },
+  { (ccallFunction) notselected, "FL_FREE_FETCH", "iii" },
+  { (ccallFunction) notselected, "FL_FREE_WAIT", "viX" },
+  { (ccallFunction) notselected, "FL_DRAWMODE", "vi" },
+  { (ccallFunction) notselected, "FL_LINE", "viiiii" },
+  { (ccallFunction) notselected, "FL_RECTANGLE", "viiiiii" },
+  { (ccallFunction) notselected, "FL_SET_OBJECT_COLOR", "viii" },
+  { (ccallFunction) notselected, "FL_SET_CLIPPING", "viiii" },
+  { (ccallFunction) notselected, "FL_UNSET_CLIPPING", "v" },
+  { (ccallFunction) notselected, "FL_SET_TEXT_CLIPPING", "viiii" },
+  { (ccallFunction) notselected, "FL_UNSET_TEXT_CLIPPING", "v" },
+  { (ccallFunction) notselected, "FL_ROUNDRECTANGLE", "viiiiii" },
+  { (ccallFunction) notselected, "FL_OVAL", "viiiiii" },
+  { (ccallFunction) notselected, "FL_PIESLICE", "viiiiiiii" },
+  { (ccallFunction) notselected, "FL_ACTIVATE_OBJECT", "vi" },
+  { (ccallFunction) notselected, "FL_DEACTIVATE_OBJECT", "vi" },
+  { (ccallFunction) notselected, "FL_FREE_OBJECT", "vi" },
+  { (ccallFunction) notselected, "FL_FREE_FORM", "vi" },
+  { (ccallFunction) notselected, "FL_DRAW_TEXT", "viiiiiiiiS" },
+  { (ccallFunction) notselected, "FL_SET_OBJECT_LSTYLE", "vii" },
+};
+CCallDescriptor XLIBA_table[] = { 
+  { (ccallFunction) notselected, "XOPENDISPLAY", "is" },
+  { (ccallFunction) notselected, "XCONNECTIONNUMBER", "ii" },
+  { (ccallFunction) notselected, "MTREGISTERFD", "vi" },
+};
+CCallDescriptor XTA_table[] = { 
+  { (ccallFunction) notselected, "XTTOOLKITINITIALIZE", "v" },
+  { (ccallFunction) notselected, "XTCREATEAPPLICATIONCONTEXT", "i" },
+  { (ccallFunction) notselected, "XTOPENDISPLAY", "iiss" },
+  { (ccallFunction) notselected, "XTAPPCREATESHELL", "issiiii" },
+  { (ccallFunction) notselected, "XTMANAGECHILD", "vi" },
+  { (ccallFunction) notselected, "XTREALIZEWIDGET", "vi" },
+  { (ccallFunction) notselected, "XTAPPMAINLOOP", "vi" },
+  { (ccallFunction) notselected, "XTSETLANGUAGEPROC", "v" },
+  { (ccallFunction) notselected, "XTVAAPPINITIALIZE", "is" },
+  { (ccallFunction) notselected, "XTVACREATEMANAGEDWIDGET", "isiisii" },
+  { (ccallFunction) notselected, "XTADDCALLBACK", "visi" },
+  { (ccallFunction) notselected, "XTRETRIEVECALLBACK", "i" },
+  { (ccallFunction) notselected, "MXTSETARGINT", "vii" },
+  { (ccallFunction) notselected, "MXTSETARGSTRING", "vis" },
+  { (ccallFunction) notselected, "MXTCLEARARG", "vi" },
+  { (ccallFunction) notselected, "MXTVACREATEMANAGEDWIDGET", "isiii" },
+};
+CCallDescriptor XMA_table[] = { 
+  { (ccallFunction) notselected, "", "" },
+};
+CCallDescriptor BANI_table[] = { 
+  { (ccallFunction) notselected, "STARTSERVER", "v" },
+  { (ccallFunction) notselected, "STARTCLIENT", "v" },
+  { (ccallFunction) notselected, "CALLSERVER", "iii" },
+  { (ccallFunction) notselected, "INITCLIENT", "iis" },
+  { (ccallFunction) notselected, "INITSERVER", "vi" },
+  { (ccallFunction) notselected, "CALLSERVER2", "iiipi" },
+  { (ccallFunction) notselected, "CHECKWITHSERVER", "bi" },
+  { (ccallFunction) notselected, "SERVERGETSTATUS", "ii" },
+  { (ccallFunction) notselected, "SGETNUMPARAMS", "iii" },
+  { (ccallFunction) notselected, "SGETPARAM", "iiii" },
+  { (ccallFunction) notselected, "RUNCLIENT", "iiipi" },
+  { (ccallFunction) notselected, "CGETNUMPARAMS", "iii" },
+  { (ccallFunction) notselected, "CGETPARAM", "iiii" },
+  { (ccallFunction) notselected, "ASKING", "vs" },
+  { (ccallFunction) notselected, "TESTER", "v" },
+};
+CCallDescriptor MYRISTREAM_table[] = { 
+  { (ccallFunction) notselected, "EMS_OPEN", "ixS" },
+  { (ccallFunction) notselected, "EMS_CLOSE", "vxi" },
+  { (ccallFunction) notselected, "EMS_EOS", "bxi" },
+  { (ccallFunction) notselected, "EMS_ISATTY", "bxi" },
+  { (ccallFunction) notselected, "EMS_GETC", "cxi" },
+  { (ccallFunction) notselected, "EMS_UNGETC", "vxic" },
+  { (ccallFunction) notselected, "EMS_GETS", "Sxi" },
+  { (ccallFunction) notselected, "EMS_FILLV", "ixip" },
+  { (ccallFunction) notselected, "EMS_PUTC", "vxic" },
+  { (ccallFunction) notselected, "EMS_PUTI", "vxiii" },
+  { (ccallFunction) notselected, "EMS_WRITEI", "vxiii" },
+  { (ccallFunction) notselected, "EMS_PUTF", "vxif" },
+  { (ccallFunction) notselected, "EMS_PUTS", "vxip" },
+  { (ccallFunction) notselected, "EMS_FLUSH", "vxi" },
+  { (ccallFunction) notselected, "EMS_BIND", "iS" },
+  { (ccallFunction) notselected, "EMS_ACCEPT", "ii" },
 };
 CCallDescriptor *ccalltable[] = {
   EMSTREAM_table,
   STRING_table,
   RAND_table,
   MISK_table,
-  0,
-  0,
-  0,
-  0,
-  0,
-  0,
-  0,
+  REGEXP_table,
+  XFORMS_table,
+  XLIBA_table,
+  XTA_table,
+  XMA_table,
+  BANI_table,
+  MYRISTREAM_table,
 };
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/cctab.h ubc-1.05alpha-src/vm/src/cctab.h
--- sourceforge-1.06alpha/vm/src/cctab.h	2017-12-11 17:59:03.087714500 +0100
+++ ubc-1.05alpha-src/vm/src/cctab.h	2017-12-11 17:59:03.421711955 +0100
@@ -49,8 +49,6 @@
 #define EMS_BIND 14
 extern int streamAccept(void);
 #define EMS_ACCEPT 15
-extern int streamRawRead(void);
-#define EMS_RAWREAD 16
 #define STRING 1
 extern int charIsAlpha(void);
 #define EMCH_ISALPHA 0
@@ -98,10 +96,225 @@
 #define UEXIT 0
 extern int mgetenv(void);
 #define UGETENV 1
-extern int opendir(void);
-#define UOPENDIR 2
-extern int mreaddir(void);
-#define UREADDIR 3
-extern int closedir(void);
-#define UCLOSEDIR 4
+#define REGEXP 4
+#define REG_EXEC 0
+#define REG_SUB 1
+#define REG_COMP 2
+#define XFORMS 5
+#define FL_INITIALIZE 0
+#define FL_BGN_FORM 1
+#define FL_END_FORM 2
+#define FL_SHOW_FORM 3
+#define FL_DO_FORMS 4
+#define FL_HIDE_FORM 5
+#define FL_GET_DISPLAY 6
+#define FL_CREATE_BOX 7
+#define FL_CREATE_FRAME 8
+#define FL_CREATE_TEXT 9
+#define FL_CREATE_BITMAP 10
+#define FL_SET_BITMAP_DATA 11
+#define FL_SET_BITMAP_FILE 12
+#define FL_CREATE_CLOCK 13
+#define FL_CREATE_CHART 14
+#define FL_SET_CHART_MAXNUMB 15
+#define FL_CLEAR_CHART 16
+#define FL_ADD_CHART_VALUE 17
+#define FL_INSERT_CHART_VALUE 18
+#define FL_REPLACE_CHART_VALUE 19
+#define FL_SET_CHART_BOUNDS 20
+#define FL_SET_CHART_AUTOSIZE 21
+#define FL_CREATE_BUTTON 22
+#define FL_CREATE_LIGHTBUTTON 23
+#define FL_CREATE_ROUNDBUTTON 24
+#define FL_CREATE_CHECKBUTTON 25
+#define FL_CREATE_BITMAPBUTTON 26
+#define FL_SET_BUTTON 27
+#define FL_GET_BUTTON 28
+#define FL_GET_BUTTON_NUMB 29
+#define FL_SET_BITMAPBUTTON_DATA 30
+#define FL_SET_BITMAPBUTTON_FILE 31
+#define FL_CREATE_SLIDER 32
+#define FL_CREATE_VALSLIDER 33
+#define FL_SET_SLIDER_VALUE 34
+#define FL_GET_SLIDER_VALUE 35
+#define FL_SET_SLIDER_BOUNDS 36
+#define FL_SET_SLIDER_STEP 37
+#define FL_SET_SLIDER_SIZE 38
+#define FL_SET_SLIDER_PRECISION 39
+#define FL_CREATE_DIAL 40
+#define FL_SET_DIAL_VALUE 41
+#define FL_GET_DIAL_VALUE 42
+#define FL_SET_DIAL_BOUNDS 43
+#define FL_SET_DIAL_ANGLES 44
+#define FL_SET_DIAL_CROSS 45
+#define FL_SET_DIAL_STEP 46
+#define FL_CREATE_COUNTER 47
+#define FL_SET_COUNTER_VALUE 48
+#define FL_GET_COUNTER_VALUE 49
+#define FL_SET_COUNTER_BOUNDS 50
+#define FL_SET_COUNTER_STEP 51
+#define FL_SET_COUNTER_PRECISION 52
+#define FL_CREATE_INPUT 53
+#define FL_GET_INPUT 54
+#define FL_SET_INPUT 55
+#define FL_SET_INPUT_SELECTED 56
+#define FL_SET_INPUT_SELECTED_RANGE 57
+#define FL_SET_INPUT_CURSORPOS 58
+#define FL_GET_INPUT_CURSORXPOS 59
+#define FL_SET_INPUT_MAXCHARS 60
+#define FL_SET_INPUT_SCROLL 61
+#define FL_SETPUP_FONTSIZE 62
+#define FL_SETPUP_FONTSTYLE 63
+#define FL_CREATE_MENU 64
+#define FL_GET_MENU 65
+#define FL_GET_MENU_TEXT 66
+#define FL_GET_MENU_ITEM_TEXT 67
+#define FL_GET_MENU_MAXITEMS 68
+#define FL_SET_MENU 69
+#define FL_CLEAR_MENU 70
+#define FL_ADDTO_MENU 71
+#define FL_REPLACE_MENU_ITEM 72
+#define FL_DELETE_MENU_ITEM 73
+#define FL_SET_MENU_ITEM_MODE 74
+#define FL_GET_MENU_ITEM_MODE 75
+#define FL_SHOW_MENU_SYMBOL 76
+#define FL_SET_MENU_POPUP 77
+#define FL_CREATE_CHOICE 78
+#define FL_CLEAR_CHOICE 79
+#define FL_ADDTO_CHOICE 80
+#define FL_DELETE_CHOICE 81
+#define FL_REPLACE_CHOICE 82
+#define FL_GET_CHOICE 83
+#define FL_GET_CHOICE_TEXT 84
+#define FL_GET_CHOICE_ITEM_TEXT 85
+#define FL_GET_CHOICE_MAXITEMS 86
+#define FL_SET_CHOICE 87
+#define FL_SET_CHOICE_TEXT 88
+#define FL_SET_CHOICE_ITEM_MODE 89
+#define FL_SET_CHOICE_ALIGN 90
+#define FL_SET_CHOICE_FONTSIZE 91
+#define FL_SET_CHOICE_FONTSTYLE 92
+#define FL_CREATE_BROWSER 93
+#define FL_CLEAR_BROWSER 94
+#define FL_ADDTO_BROWSER 95
+#define FL_ADD_BROWSER_LINE 96
+#define FL_INSERT_BROWSER_LINE 97
+#define FL_DELETE_BROWSER_LINE 98
+#define FL_REPLACE_BROWSER_LINE 99
+#define FL_GET_BROWSER_LINE 100
+#define FL_SELECT_BROWSER_LINE 101
+#define FL_DESELECT_BROWSER_LINE 102
+#define FL_DESELECT_BROWSER 103
+#define FL_ISSELECTED_BROWSER_LINE 104
+#define FL_GET_BROWSER 105
+#define FL_GET_BROWSER_MAXLINE 106
+#define FL_GET_BROWSER_SCREENLINES 107
+#define FL_GET_BROWSER_TOPLINE 108
+#define FL_SET_BROWSER_TOPLINE 109
+#define FL_SET_BROWSER_XOFFSET 110
+#define FL_SET_BROWSER_FONTSIZE 111
+#define FL_SET_BROWSER_FONTSTYLE 112
+#define FL_CREATE_TIMER 113
+#define FL_SET_TIMER 114
+#define FL_GET_TIMER 115
+#define FL_CREATE_XYPLOT 116
+#define FL_SET_OBJECT_LSIZE 117
+#define FL_SET_FONT 118
+#define FL_SET_OBJECT_RETURN 119
+#define FL_ADD_OBJECT 120
+#define FL_SET_OBJECT_SHORTCUT 121
+#define FL_REDRAW_OBJECT 122
+#define FL_FLUSH 123
+#define FL_GET_STRING_WIDTH 124
+#define FL_SET_OBJECT_BOXTYPE 125
+#define FL_SET_OBJECT_LALIGN 126
+#define FL_CREATE_PIXMAP 127
+#define FL_SET_PIXMAP_FILE 128
+#define FL_SET_PIXMAP_PIXMAP 129
+#define FL_FREE_PIXMAP_PIXMAP 130
+#define FL_DELETE_OBJECT 131
+#define FL_SET_OBJECT_LABEL 132
+#define FL_HIDE_OBJECT 133
+#define FL_SHOW_OBJECT 134
+#define FL_FREEZE_FORM 135
+#define FL_UNFREEZE_FORM 136
+#define FL_SET_OBJECT_POSITION 137
+#define FL_SET_FORM_POSITION 138
+#define FL_REDRAW_FORM 139
+#define FL_RINGBELL 140
+#define FL_CREATE_FREE 141
+#define FL_FREE_FETCH 142
+#define FL_FREE_WAIT 143
+#define FL_DRAWMODE 144
+#define FL_LINE 145
+#define FL_RECTANGLE 146
+#define FL_SET_OBJECT_COLOR 147
+#define FL_SET_CLIPPING 148
+#define FL_UNSET_CLIPPING 149
+#define FL_SET_TEXT_CLIPPING 150
+#define FL_UNSET_TEXT_CLIPPING 151
+#define FL_ROUNDRECTANGLE 152
+#define FL_OVAL 153
+#define FL_PIESLICE 154
+#define FL_ACTIVATE_OBJECT 155
+#define FL_DEACTIVATE_OBJECT 156
+#define FL_FREE_OBJECT 157
+#define FL_FREE_FORM 158
+#define FL_DRAW_TEXT 159
+#define FL_SET_OBJECT_LSTYLE 160
+#define XLIBA 6
+#define XOPENDISPLAY 0
+#define XCONNECTIONNUMBER 1
+#define MTREGISTERFD 2
+#define XTA 7
+#define XTTOOLKITINITIALIZE 0
+#define XTCREATEAPPLICATIONCONTEXT 1
+#define XTOPENDISPLAY 2
+#define XTAPPCREATESHELL 3
+#define XTMANAGECHILD 4
+#define XTREALIZEWIDGET 5
+#define XTAPPMAINLOOP 6
+#define XTSETLANGUAGEPROC 7
+#define XTVAAPPINITIALIZE 8
+#define XTVACREATEMANAGEDWIDGET 9
+#define XTADDCALLBACK 10
+#define XTRETRIEVECALLBACK 11
+#define MXTSETARGINT 12
+#define MXTSETARGSTRING 13
+#define MXTCLEARARG 14
+#define MXTVACREATEMANAGEDWIDGET 15
+#define XMA 8
+#define BANI 9
+#define STARTSERVER 0
+#define STARTCLIENT 1
+#define CALLSERVER 2
+#define INITCLIENT 3
+#define INITSERVER 4
+#define CALLSERVER2 5
+#define CHECKWITHSERVER 6
+#define SERVERGETSTATUS 7
+#define SGETNUMPARAMS 8
+#define SGETPARAM 9
+#define RUNCLIENT 10
+#define CGETNUMPARAMS 11
+#define CGETPARAM 12
+#define ASKING 13
+#define TESTER 14
+#define MYRISTREAM 10
+#define EMS_OPEN 0
+#define EMS_CLOSE 1
+#define EMS_EOS 2
+#define EMS_ISATTY 3
+#define EMS_GETC 4
+#define EMS_UNGETC 5
+#define EMS_GETS 6
+#define EMS_FILLV 7
+#define EMS_PUTC 8
+#define EMS_PUTI 9
+#define EMS_WRITEI 10
+#define EMS_PUTF 11
+#define EMS_PUTS 12
+#define EMS_FLUSH 13
+#define EMS_BIND 14
+#define EMS_ACCEPT 15
 #endif
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/codeptrextra.c ubc-1.05alpha-src/vm/src/codeptrextra.c
--- sourceforge-1.06alpha/vm/src/codeptrextra.c	2017-12-11 17:59:03.087714500 +0100
+++ ubc-1.05alpha-src/vm/src/codeptrextra.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,13 +0,0 @@
-#include <stdlib.h>
-#include <stdio.h>
-
-typedef unsigned int word;
-
-int main( int argc, char **argv )
-{
-	int old_size = 2 * 1024 * 1024;
-	static word *old_start;
-	old_start = (word *) malloc (old_size);
-	printf("%#x",(int) old_start &  0xfc000000);
-	free(old_start);
-}
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/codeptrextra.h ubc-1.05alpha-src/vm/src/codeptrextra.h
--- sourceforge-1.06alpha/vm/src/codeptrextra.h	2017-12-11 17:59:03.087714500 +0100
+++ ubc-1.05alpha-src/vm/src/codeptrextra.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-#undef CODEPTREXTRA
-#define CODEPTREXTRA 0xb4000000
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/context.S ubc-1.05alpha-src/vm/src/context.S
--- sourceforge-1.06alpha/vm/src/context.S	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/context.S	2017-12-11 17:59:03.421711955 +0100
@@ -0,0 +1,614 @@
+
+/*
+ * int
+ * saveProcContext(struct savearea *savearea)
+ *
+ * Save enough of the current state in SAVEAREA so that
+ * control can later be returned to the caller of the function calling
+ * saveProcContext().  SaveProcContext() behaves like setjmp(3) in that 0 is
+ * returned when the context is saved but a non-zero value is returned
+ * when returnto() resumes execution of the saved context.
+ *
+ * void
+ * returnToProc(struct savearea *savearea)
+ *
+ * Restore the state previously stored in SAVEAREA and continue execution
+ * based on that saved state.  This resumes a suspended thread, making
+ * it look like a call to savecontext() with F == 0 is now returning.
+ *
+ * bjb/mwg Dec/89 and Jul/90
+ */
+/********************************************
+
+
+note: unless the predecrement addressing mode is used, the register mask can
+be interpreted as follows:
+
+------------------------------------------------------------------------------
+Mask:  MostSigBit  15 14 13 12 11 10 9  8  7  6  5  4  3  2  1  0  LeastSigBit
+Register:          a7 a6 a5 a4 a3 a2 a1 a0 d7 d6 d5 d4 d3 d2 d1 d0
+------------------------------------------------------------------------------
+
+ if the predecrement addressing mode is used, the mask becomes:
+------------------------------------------------------------------------------
+Mask:  MostSigBit  15 14 13 12 11 10 9  8  7  6  5  4  3  2  1  0  LeastSigBit
+Register:          d0 d1 d2 d3 d4 d5 d6 d7 a0 a1 a2 a3 a4 a5 a6 a7
+
+*********************************************/
+
+#if defined(sun3) || defined(__NeXT__)
+.text
+.globl _saveProcContext
+
+_saveProcContext:
+	movl	sp@(0x4), a0		/* get save area (1st param) */
+        movl    sp@, a0@                /* save ret address, it gets trashed*/
+	moveml	#0xfefe, a0@(4)		/* save regs to save area    */
+					/* this includes a6 (frame pointer) */
+					/* and a7 (stack pointer)    */
+        moveq   #17, d0
+	rts
+
+
+.text
+.globl _startNewProc
+
+_startNewProc:
+        movl    sp@(0x4), a0            /* get function addr from stack   */
+        movl    sp@(0x8), sp            /* set stack pointer to new stack */
+        jmp     a0@
+
+
+.text
+.globl _returnToProc
+
+_returnToProc:
+	movl	sp@(0x4), a0		/* get save area (only param) */
+	moveml	a0@(4), #0xfefe    	/* this restores the regs     */
+        movl    a0@, sp@
+        moveq   #0, d0
+        rts
+
+#endif /* sun3 */
+
+
+
+
+#if defined(sun4) || defined(sun4sol)
+#ifdef sun4
+#include    <sun4/asm_linkage.h>
+#include    <sun4/trap.h>
+#endif
+
+#ifdef sun4sol
+#define _ASM
+#include <sys/trap.h>
+#include <sys/stack.h>
+
+#endif
+	
+topstack =  0
+globals  = 12
+
+.text
+#ifdef sun4
+.global _saveProcContext
+_saveProcContext:
+#else
+.global saveProcContext
+saveProcContext:
+#endif
+    st  %g1, [%o0 + globals +  0]        ! Save all globals just in case
+    st  %g2, [%o0 + globals +  4]
+    st  %g3, [%o0 + globals +  8]
+    st  %g4, [%o0 + globals + 12]
+    st  %g5, [%o0 + globals + 16]
+    st  %g6, [%o0 + globals + 20]
+    st  %g7, [%o0 + globals + 24]
+    mov %y, %g1
+    st  %g1, [%o0 + globals + 28]
+
+    st  %sp, [%o0 + topstack + 0]
+    st  %o7, [%o0 + topstack + 4]
+
+    jmp  %o7 + 0x8
+    add %g0, 17, %o0
+
+.text
+#ifdef sun4
+.global _startNewProc
+_startNewProc:
+#else
+.global startNewProc
+startNewProc:
+#endif
+    ta  ST_FLUSH_WINDOWS                ! Flush all other active windows
+
+    add  %o1, STACK_ALIGN - 1, %o1      ! SPARC requires stricter alignment
+    and  %o1, ~(STACK_ALIGN - 1), %o1   ! than malloc gives so force alignment
+    sub  %o1, SA(MINFRAME), %fp
+    sub  %fp, SA(MINFRAME), %sp
+
+    jmpl %o0, %g0
+    nop
+
+.text
+#ifdef sun4	
+.globl _returnToProc
+_returnToProc:
+#else
+.globl returnToProc
+returnToProc:
+#endif
+    ta  ST_FLUSH_WINDOWS                ! Flush all other active windows
+
+    ld  [%o0 + globals + 28], %g1       ! Restore global regs
+    mov %g1, %y
+    ld  [%o0 + globals +  0], %g1
+    ld  [%o0 + globals +  4], %g2
+    ld  [%o0 + globals +  8], %g3
+    ld  [%o0 + globals + 12], %g4
+    ld  [%o0 + globals + 16], %g5
+    ld  [%o0 + globals + 20], %g6
+    ld  [%o0 + globals + 24], %g7
+
+    ld  [%o0 + topstack + 0], %fp
+    sub %fp, SA(MINFRAME), %sp
+    ld  [%o0 + topstack + 4], %o7
+
+    clr  %o0
+    retl
+    restore %o0, 0x0, %o0
+
+#endif /* sun4 */
+
+#ifdef hp700
+
+	.SPACE $PRIVATE$
+	.SUBSPA $DATA$,QUAD=1,ALIGN=8,ACCESS=31
+	.SUBSPA $BSS$,QUAD=1,ALIGN=8,ACCESS=31,ZERO,SORT=82
+	.SPACE $TEXT$
+	.SUBSPA $LIT$,QUAD=0,ALIGN=8,ACCESS=44
+	.SUBSPA $CODE$,QUAD=0,ALIGN=8,ACCESS=44,CODE_ONLY
+	.IMPORT $global$,DATA
+	.IMPORT $$dyncall,MILLICODE
+	.file	"context.c"
+; gcc_compiled.:
+	.SPACE $TEXT$
+	.SUBSPA $CODE$
+	.EXPORT saveProcContext,ENTRY,PRIV_LEV=3,ARGW0=GR,RTNVAL=GR
+saveProcContext
+	.PROC
+	.CALLINFO FRAME=64,NO_CALLS,SAVE_SP,ENTRY_GR=3
+	.ENTRY
+	STWM    %rp, 4(%arg0)         /* store return address */
+	STWM    3, 4(%arg0)           /* store general purpose registers */
+	STWM    4, 4(%arg0)
+	STWM    5, 4(%arg0)
+	STWM    6, 4(%arg0)
+	STWM    7, 4(%arg0)
+	STWM    8, 4(%arg0)
+	STWM    9, 4(%arg0)
+	STWM    10, 4(%arg0)
+	STWM    11, 4(%arg0)
+	STWM    12, 4(%arg0)
+	STWM    13, 4(%arg0)
+	STWM    14, 4(%arg0)
+	STWM    15, 4(%arg0)
+	STWM    16, 4(%arg0)
+	STWM    17, 4(%arg0)
+	STWM    18, 4(%arg0)
+	STWM    19, 4(%arg0)
+	STWM    20, 4(%arg0)
+	STWM    21, 4(%arg0)
+	STWM    22, 4(%arg0)
+	STWM    30, 4(%arg0)       /* store static link (necessray?) */
+	STWM    %sp, 4(%arg0)       /* store stack pointer            */
+
+	LDIL	17,%ret0            /* return the perfect number      */
+ 	bv,n	0(%r2)
+	.EXIT
+	.PROCEND
+	.align 4
+
+
+	.EXPORT startNewProc,ENTRY,PRIV_LEV=3,ARGW0=GR,ARGW1=GR
+startNewProc  
+	.PROC
+	.CALLINFO FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=4
+	.ENTRY
+	copy %arg0, %r22	/* Set up argument to dyncall */
+	.CALL	ARGW0=GR
+	bl $$dyncall, %r31	/* Call through dyncall */
+	COPY	%arg1,%sp	/* set stack pointer to new stack */
+	.EXIT
+	.PROCEND
+	.align 4
+
+
+	.EXPORT returnToProc,ENTRY,PRIV_LEV=3,ARGW0=GR
+returnToProc
+	.PROC
+	.CALLINFO FRAME=64,NO_CALLS,SAVE_SP,ENTRY_GR=3
+	.ENTRY
+	LDWM    4(%arg0), %rp         /* load return address */
+	LDWM    4(%arg0), 3           /* load general purpose registers */
+	LDWM    4(%arg0), 4
+	LDWM    4(%arg0), 5
+	LDWM    4(%arg0), 6
+	LDWM    4(%arg0), 7
+	LDWM    4(%arg0), 8
+	LDWM    4(%arg0), 9
+	LDWM    4(%arg0), 10
+	LDWM    4(%arg0), 11
+	LDWM    4(%arg0), 12
+	LDWM    4(%arg0), 13
+	LDWM    4(%arg0), 14
+	LDWM    4(%arg0), 15
+	LDWM    4(%arg0), 16
+	LDWM    4(%arg0), 17
+	LDWM    4(%arg0), 18
+	LDWM    4(%arg0), 19
+	LDWM    4(%arg0), 20
+	LDWM    4(%arg0), 21
+	LDWM    4(%arg0), 22
+	LDWM    4(%arg0), 30       /* load static link (necessray?) */
+	LDWM    4(%arg0), %sp       /* load stack pointer            */
+	LDIL	0, %ret0            /* return zero */
+ 	bv,n	0(%r2)
+	.EXIT
+	.PROCEND
+	.align 4
+        .END
+#endif /* hp700 */
+
+
+#ifdef mips
+/* mips stuff has yet to be tested */
+
+.text
+.globl saveProcContext
+.ent saveProcContext
+
+saveProcContext:
+	.set	noreorder
+        sw      $16,  0($4)             /* save regs to save area */
+        sw      $17,  4($4)
+        sw      $18,  8($4)
+        sw      $19, 12($4)
+        sw      $20, 16($4)
+        sw      $21, 20($4)
+        sw      $22, 24($4)
+        sw      $23, 28($4)
+        sw      $fp, 32($4)
+        sw      $sp, 36($4)
+        sw      $31, 40($4)
+        /* Don't know if gp needs to be saved... */
+
+        li      $2, 17
+        j       $31
+	nop
+.end saveProcContext
+
+.text
+.globl startNewProc
+.ent startNewProc
+startNewProc:
+	.set	noreorder
+	.cpload	$25
+        addu    $sp, $0, $5             /* set stack pointer to new stack */
+	move	$25,$4
+        j       $25
+	nop
+.end startNewProc
+
+
+.text
+.globl returnToProc
+.ent returnToProc
+
+returnToProc:
+	.set	noreorder
+        lw      $16,  0($4)
+        lw      $17,  4($4)
+        lw      $18,  8($4)
+        lw      $19, 12($4)
+        lw      $20, 16($4)
+        lw      $21, 20($4)
+        lw      $22, 24($4)
+        lw      $23, 28($4)
+        lw      $fp, 32($4)
+        lw      $sp, 36($4)
+
+        lw      $31, 40($4)
+        li      $2, 0
+        j       $31
+	nop
+.end returnToProc
+
+#endif /* mips */
+
+
+#ifdef ibm
+
+/* RS6000 */
+.align 2
+.toc
+.csect .text[PR]
+gcc2_compiled.:
+__gnu_compiled_c:
+	.align 2
+	.globl startNewProc
+	.globl .startNewProc
+.csect startNewProc[DS]
+startNewProc:
+	.long .startNewProc, TOC[tc0], 0
+.csect .text[PR]
+.startNewProc:
+/*
+  We need to create a link area for this procedure.  This is because
+  the function we call is allowed to write into our link area to save
+  the CR and LR.  The link area also includes space reserved for the
+  compiler and for saving the TOC.  It's currently 6 words (24 bytes)
+  long; this code will need to be changed if the value changes.
+
+  The POWER architecture specifies that the stack pointer must be
+  quad-word aligned (16 bytes), so we take the next multiple up from
+  24 as the space we need to reserve.  This assumes that the sp passed
+  in is already quad-word aligned.
+*/
+
+	.set	linkarea, 32
+	ai	1, 4, -linkarea
+	l	0, 0(3)
+	mtlr	0
+	brl
+
+LT..startNewProc:
+	.long 0
+	.byte 0,0,32,64,0,0,0,0
+	.long LT..startNewProc-.startNewProc
+	.short 12
+	.byte "startNewProc"
+	.align 2
+	.globl returnToProc
+	.globl .returnToProc
+.csect returnToProc[DS]
+returnToProc:
+	.long .returnToProc, TOC[tc0], 0
+.csect .text[PR]
+.returnToProc:
+	lm	13, 8(3)
+	l	1, 4(3)
+	l	0, 0(3)
+	mtlr	0
+	lil	3, 0
+
+	br
+LT..returnToProc:
+	.long 0
+	.byte 0,0,32,64,0,0,0,0
+	.long LT..returnToProc-.returnToProc
+	.short 12
+	.byte "returnToProc"
+	.align 2
+	.globl saveProcContext
+	.globl .saveProcContext
+.csect saveProcContext[DS]
+saveProcContext:
+	.long .saveProcContext, TOC[tc0], 0
+.csect .text[PR]
+.saveProcContext:
+	mflr	0
+	st	0, 0(3)		/* save link */
+	st	1, 4(3)		/* save sp */
+	stm	13, 8(3)	/* save regs to save area */
+
+	lil	3, 17
+	br
+LT..saveProcContext:
+	.long 0
+	.byte 0,0,32,64,0,0,0,0
+	.long LT..saveProcContext-.saveProcContext
+	.short 15
+	.byte "saveProcContext"
+_section_.text:
+.csect .data[RW]
+	.long _section_.text
+
+#endif
+
+#if defined(i386) || defined(i486)
+#if defined(__FreeBSD__) || defined(__NetBSD__)
+#define L(X) _##X
+#endif
+#if defined(__linux__) || defined(i86pc)
+#define L(X) X
+#endif
+
+.globl L(saveProcContext)
+.align 4
+
+L(saveProcContext):
+	mov %ebx, %eax      /* first thing we do is save EBX into EAX       */
+	mov 4(%esp), %ebx   /* now we get the save area into EBX            */	
+	mov %eax, 32(%ebx)  /* get old value of EBX from EAX into save area */
+	mov (%esp), %eax    /* now we get the return address into save area */
+	mov %eax, (%ebx)
+	mov %edi, 4(%ebx)   /* save registers in save area */
+	mov %esi, 8(%ebx)
+	mov %edx, 16(%ebx)
+	mov %ecx, 20(%ebx)
+	mov %ebp, 24(%ebx)
+	mov %esp, 28(%ebx)
+	mov %eax, %ebx      /* restore EBX */
+	mov $11, %eax       /* return value of 17 (decimal) :) */
+	ret
+
+.globl L(startNewProc)
+.align 4
+
+L(startNewProc):
+	mov 4(%esp),%eax    /* we get the function pointer from the stack */
+	mov 8(%esp),%esp    /* restore the stack pointer for the new thread */
+	jmp %eax
+	
+.globl L(returnToProc)
+.align 4
+
+L(returnToProc):
+	mov 4(%esp), %ebx    /* get the save area pointer into EBX */
+	mov 4(%ebx), %edi   /* restore registers from save area */
+	mov 8(%ebx), %esi
+	mov 16(%ebx), %edx
+	mov 20(%ebx), %ecx
+	mov 24(%ebx), %ebp
+	mov 28(%ebx), %esp
+	mov (%ebx), %eax   /* restore the return address */
+	mov %eax,(%esp)
+	mov 32(%ebx), %eax  /* get old value of EBX from EAX into save area */
+	mov %eax, %ebx      /* restore EBX */
+	mov $0, %eax        /* return value of zero */
+        ret
+
+#endif /* i386 || i486 */
+
+#ifdef alpha
+	.ugen	
+	.verstamp	3 11
+	.text	
+	.align	4
+	.file	2 "fakecontext.c"
+	.globl	startNewProc
+	.ent	startNewProc 2
+startNewProc:
+	ldgp	$gp, 0($27)
+	lda	$sp, -32($sp)
+	stq	$26, 0($sp)
+	.mask	0x04000000, -32
+	.frame	$sp, 32, $26, 0
+	.prologue	1
+	and	$16, 4294967295, $16
+	and	$17, 4294967295, $17
+
+	addl	$17, 0, $sp
+ #    9	  f();
+	.livereg	0x00010002,0x00000000
+	bis	$16, $16, $27
+	jsr	$26, ($16), 0
+	ldgp	$gp, 0($26)
+ #   11	}
+	.livereg	0x007F0002,0x3FC00000
+	ldq	$26, 0($sp)
+	lda	$sp, 32($sp)
+	ret	$31, ($26), 1
+	.end	startNewProc
+	.text	
+	.align	4
+	.file	2 "fakecontext.c"
+	.globl	returnToProc
+	.loc	2 14
+ #   12	
+ #   13	void returnToProc(struct savearea *ts)
+ #   14	{
+	.ent	returnToProc 2
+returnToProc:
+	ldgp	$gp, 0($27)
+	lda	$sp, -32($sp)
+	stq	$26, 0($sp)
+	.mask	0x04000000, -32
+	.frame	$sp, 32, $26, 0
+	.prologue	1
+	and	$16, 4294967295, $1
+	ldq	$0, 0($1)
+	ldq	$2, 8($1)
+	ldq	$3, 16($1)
+	ldq	$4, 24($1)
+	ldq	$5, 32($1)
+	ldq	$6, 40($1)
+	ldq	$7, 48($1)
+	ldq	$8, 56($1)
+	ldq	$9, 640($1)
+	ldq	$10, 72($1)
+	ldq	$11, 80($1)
+	ldq	$12, 88($1)
+	ldq	$13, 96($1)
+	ldq	$14, 104($1)
+	ldq	$15, 112($1)
+	ldq	$16, 120($1)
+	ldq	$17, 128($1)
+	ldq	$18, 136($1)
+	ldq	$19, 144($1)
+	ldq	$20, 152($1)
+	ldq	$21, 160($1)
+	ldq	$22, 168($1)
+	ldq	$23, 176($1)
+	ldq	$24, 184($1)
+	ldq	$25, 192($1)
+	ldq	$26, 200($1)
+	ldq	$27, 208($1)
+ /*	ldq	$28, 216($1) */
+	ldq	$29, 224($1)
+	ldq	$30, 232($1)
+	ldq	$sp, 240($1)
+	ldq	$31, 248($1)
+	.livereg	0x0001FC02,0x00000000
+
+	lda	$sp, 32($sp)
+	ldil	$0, 0
+	ret	$31, ($26), 1
+	.end	returnToProc
+	.text	
+	.align	4
+	.file	2 "fakecontext.c"
+	.globl	saveProcContext
+	.loc	2 47
+ #   45	
+ #   46	int saveProcContext(struct savearea *ts)
+ #   47	{
+	.ent	saveProcContext 2
+saveProcContext:
+	ldgp	$gp, 0($27)
+	lda	$sp, -32($sp)
+	.frame	$sp, 32, $26, 0
+	.prologue	1
+	and	$16, 4294967295, $1
+	stq	$0, 0($1)
+	stq	$2, 8($1)
+	stq	$3, 16($1)
+	stq	$4, 24($1)
+	stq	$5, 32($1)
+	stq	$6, 40($1)
+	stq	$7, 48($1)
+	stq	$8, 56($1)
+	stq	$9, 640($1)
+	stq	$10, 72($1)
+	stq	$11, 80($1)
+	stq	$12, 88($1)
+	stq	$13, 96($1)
+	stq	$14, 104($1)
+	stq	$15, 112($1)
+	stq	$16, 120($1)
+	stq	$17, 128($1)
+	stq	$18, 136($1)
+	stq	$19, 144($1)
+	stq	$20, 152($1)
+	stq	$21, 160($1)
+	stq	$22, 168($1)
+	stq	$23, 176($1)
+	stq	$24, 184($1)
+	stq	$25, 192($1)
+	stq	$26, 200($1)
+	stq	$27, 208($1)
+ /*	stq	$28, 216($1) */
+	stq	$29, 224($1)
+	stq	$30, 232($1)
+	stq	$sp, 240($1)
+	stq	$31, 248($1)
+
+	.livereg	0xFC7F0002,0x3FC00000
+	lda	$sp, 32($sp)
+	ldil	$0, 17
+	ret	$31, ($26), 1
+	.end	saveProcContext
+#endif
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/env.c ubc-1.05alpha-src/vm/src/env.c
--- sourceforge-1.06alpha/vm/src/env.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/env.c	2017-12-11 17:59:03.425711924 +0100
@@ -0,0 +1,16 @@
+int g;
+
+main()
+{
+  int l;
+  long *ll;
+  printf("Sizeof int = %d\n", sizeof(int));
+  printf("Sizeof long = %d\n", sizeof(long));
+  printf("Sizeof char * = %d\n", sizeof(char *));
+  printf("Address of global g = %lx\n", &g);
+  printf("Address of local l = %lx\n", &l);
+  ll = malloc(32);
+  *ll = 5;
+  ll = (long)ll + 4;
+  *ll = 6;
+}
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/error.c ubc-1.05alpha-src/vm/src/error.c
--- sourceforge-1.06alpha/vm/src/error.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/error.c	2017-12-11 17:59:03.425711924 +0100
@@ -0,0 +1,24 @@
+/****************************************************************************
+ File     : error.c 
+ Date     : 08-11-92
+ Author   : Mark Immel
+
+ Contents : Error handling package
+
+ Modifications
+ -------------
+
+*****************************************************************************/
+
+#pragma warning(disable: 4068)
+#pragma pointer_size long
+#include <stdio.h>
+#include <errno.h>
+#pragma pointer_size short
+#include "error.h"
+
+void FatalError(char *ErrorMessage)
+{
+  perror(ErrorMessage);
+  exit(1);
+}
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/error.h ubc-1.05alpha-src/vm/src/error.h
--- sourceforge-1.06alpha/vm/src/error.h	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/error.h	2017-12-11 17:59:03.425711924 +0100
@@ -0,0 +1,18 @@
+/****************************************************************************
+ File     : error.h 
+ Date     : 08-11-92
+ Author   : Mark Immel
+
+ Contents : Error handling package
+
+ Modifications
+ -------------
+
+*****************************************************************************/
+
+#ifndef _ERROR_H
+#define _ERROR_H
+
+extern void FatalError(char *ErrorMessage);
+
+#endif /* _ERROR_H */
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/fakecontext.c ubc-1.05alpha-src/vm/src/fakecontext.c
--- sourceforge-1.06alpha/vm/src/fakecontext.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/fakecontext.c	2017-12-11 17:59:03.425711924 +0100
@@ -0,0 +1,82 @@
+struct savearea {
+  int a, b, c, d, e, f, g, h, i, j, k, l, m;
+  int n, o, p, q, r, s, t, u, v, w, x, y, z;
+};
+
+void startNewProc(void (*f)(), void *sp)
+{
+  int x = (int)sp + 1;
+  f();
+  junk(x);
+}
+
+void returnToProc(struct savearea *ts)
+{
+  int a, b, c, d, e, f, g, h, i, j, k, l, m;
+  int n, o, p, q, r, s, t, u, v, w, x, y, z;
+  a = ts->a;
+  b = ts->b;
+  c = ts->c;
+  d = ts->d;
+  e = ts->e;
+  f = ts->f;
+  g = ts->g;
+  h = ts->h;
+  i = ts->i;
+  j = ts->j;
+  k = ts->k;
+  l = ts->l;
+  m = ts->m;
+  n = ts->n;
+  o = ts->o;
+  p = ts->p;
+  q = ts->q;
+  r = ts->r;
+  s = ts->s;
+  t = ts->t;
+  u = ts->u;
+  v = ts->v;
+  w = ts->w;
+  x = ts->x;
+  y = ts->y;
+  z = ts->z;
+  junk2(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z);
+}
+
+int saveProcContext(struct savearea *ts)
+{
+  int a, b, c, d, e, f, g, h, i, j, k, l, m;
+  int n, o, p, q, r, s, t, u, v, w, x, y, z;
+  
+  ts->a = a;
+  ts->b = b;
+  ts->c = c;
+  ts->d = d;
+  ts->e = e;
+  ts->f = f;
+  ts->g = g;
+  ts->h = h;
+  ts->i = i;
+  ts->j = j;
+  ts->k = k;
+  ts->l = l;
+  ts->m = m;
+  ts->n = n;
+  ts->o = o;
+  ts->p = p;
+  ts->q = q;
+  ts->r = r;
+  ts->s = s;
+  ts->t = t;
+  ts->u = u;
+  ts->v = v;
+  ts->w = w;
+  ts->x = x;
+  ts->y = y;
+  ts->z = z;
+}
+
+int foo()
+{
+  return 17;
+}
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/fakemain.c ubc-1.05alpha-src/vm/src/fakemain.c
--- sourceforge-1.06alpha/vm/src/fakemain.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/fakemain.c	2017-12-11 17:59:03.425711924 +0100
@@ -0,0 +1,12 @@
+#pragma warning(disable: 4068)
+#pragma pointer_size long
+#include <stdio.h>
+#pragma pointer_size short
+
+int main(ac,av)
+int ac;
+char **av;
+{
+  mainp(ac,av);
+  return 0;
+}
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/gc.c ubc-1.05alpha-src/vm/src/gc.c
--- sourceforge-1.06alpha/vm/src/gc.c	2017-12-11 17:59:03.088714493 +0100
+++ ubc-1.05alpha-src/vm/src/gc.c	2017-12-11 17:59:03.425711924 +0100
@@ -1005,26 +983,10 @@
 
     fromSpace = new_start = (word *) vmMalloc (nbytes);
     toSpace = new_end = &fromSpace[nbytes / sizeof(word)];
-    //vmMalloc er definet som malloc. Den fejler tydeligvis.
-    //Den fejler ogsaa naar vi fjerner checksene nedenfor
     nextGen = old_start = (word *) vmMalloc (old_size);
     old_end = old_start + (old_size / sizeof(word));
     new_lb = new_start;
     new_ub = new_end;
-    int tmp = (int)old_start & ~ALLBITS;
-    //MB_REMOVE
-    /*TRACE(memory, 0, ("ALLBITS = %#x", ALLBITS));
-    TRACE(memory, 0, ("~ALLBITS = %#x", ~ALLBITS));
-    TRACE(memory, 0, ("CODEPTREXTRA = %#x", CODEPTREXTRA));
-    TRACE(memory, 0, ("~ALLBITS | CODEPTREXTRA = %#x", ~ALLBITS | CODEPTREXTRA));
-    TRACE(memory, 0, ("old_start = %#x / %#d", (unsigned int)old_start, (int)old_start));
-	// Paa redhatten er old_start negativ!
-    TRACE(memory, 0, ("old_start & ~ALLBITS = %#x", (unsigned int)old_start & ~ALLBITS));
-    TRACE(memory, 0, ("old_start | CODEPTREXTRA = %#x", CODEPTREXTRA | (unsigned int)old_start));
-    TRACE(memory, 0, ("(old_start & ~ALLBITS) | CODEPTREXTRA = %#x", tmp | CODEPTREXTRA));
-    TRACE(memory, 0, ("result = %#x", ((int)old_start & ~ALLBITS) | CODEPTREXTRA)) 
-    TRACE(memory, 0, ("old_size = %#x", old_size)) 
-    */
     if (((int)old_start & CODEPTREXTRA) != CODEPTREXTRA) {
       TRACE(memory, 0, ("EXTRA: old_start = %#x", (unsigned int)old_start));
       abort();
@@ -1033,7 +995,6 @@
       TRACE(memory, 0, ("EXTRA: new_start = %#x", (unsigned int)new_start));
       abort();
     }
-    //Ikke nogle af ALLBITS og skal have CODEPTREXTRA sat i old_start
     if ((((int)old_start & ~ALLBITS) | CODEPTREXTRA) != (int)old_start) {
       TRACE(memory, 0, ("BITS: old_start = %#x", (unsigned int)old_start));
       abort();
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/gencodeptrextra.sh ubc-1.05alpha-src/vm/src/gencodeptrextra.sh
--- sourceforge-1.06alpha/vm/src/gencodeptrextra.sh	2017-12-11 17:59:03.088714493 +0100
+++ ubc-1.05alpha-src/vm/src/gencodeptrextra.sh	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-#!/bin/sh
-#errornumber=`./emx |egrep old_start\|new_start |sed s/"^.*old_start = "//|sed s/"^.*new_start = "//`
-
-echo \#undef CODEPTREXTRA > codeptrextra.h;
-echo \#define CODEPTREXTRA `./codeptrextra` >> codeptrextra.h;
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/iiiiisc.c ubc-1.05alpha-src/vm/src/iiiiisc.c
--- sourceforge-1.06alpha/vm/src/iiiiisc.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/iiiiisc.c	2017-12-11 17:59:03.425711924 +0100
@@ -0,0 +1,324 @@
+/* comment me!
+ */
+
+#include "iiiiisc.h"
+
+/*
+ * Searchable Collections:
+ *
+ * Expanding hash tables with a key and data.
+ */
+
+#ifndef NULL
+#include <stdio.h>
+#endif
+
+#ifndef assert
+#include "assert.h"
+#endif
+
+static int sizes[] = {
+  5, 7, 17, 31,
+  67, 131, 257, 521,
+  1031, 2053, 4099, 8093,
+  16193, 32377, 65557, 131071,
+  262187, 524869, 1048829, 2097223,
+  4194371, 8388697, 16777291 };
+#define MAXFILL(x) (((x) * 17) / 20)
+
+/*
+ * Turning this on will cause the package to self-check on every (modifying)
+ * operation.  The package runs very slowly when this is enabled.
+ */
+#undef DEBUGSC
+
+#define Hash(a,b,c,d,sc) (IIIIIScHASH(a,b,c,d) % sc->size)
+
+#ifdef DEBUGSC
+static void CheckOutHashTable();
+#endif
+
+/* Return a new, empty IIIIISc */
+IIIIISc IIIIIScCreate()
+{
+  register int i;
+  register IIIIISc sc;
+
+  sc = (IIIIISc) vmMalloc(sizeof(IIIIIScRecord));
+  sc->size = sizes[0];
+  sc->maxCount = MAXFILL(sc->size);
+  sc->count = 0;
+  sc->table = (IIIIIScTEPtr) vmMalloc((unsigned) sc->size * sizeof(IIIIIScTE));
+  for (i = 0; i < sc->size; i++) {
+    sc->table[i].key.a = IIIIIScNIL;
+  }
+#ifdef DEBUGSC
+  CheckOutHashTable(sc);
+#endif DEBUGSC
+  return sc;
+}
+
+void IIIIIScDestroy(sc)
+register IIIIISc sc;
+{
+  vmFree((char *)sc->table);
+  vmFree((char *)sc);
+}
+
+/* Expand the hash table.  Each element in the table is re-hashed and entered 
+ * in the new table. */
+static void ExpandHashTable(sc)
+register IIIIISc sc;
+{
+  register IIIIIScTE *nh, *oe, *ne;
+  register int oldHashTableSize = sc->size, i;
+  int index;
+
+  for (i = 0; sizes[i] <= oldHashTableSize; i++) ;
+  sc->size = sizes[i];
+  sc->maxCount = MAXFILL(sc->size);
+  nh = (IIIIIScTEPtr) vmMalloc((unsigned)(sc->size * sizeof(IIIIIScTE)));
+  for (i = 0; i < sc->size; i++) nh[i].key.a = IIIIIScNIL;
+  for (i = 0; i < oldHashTableSize; i++) {
+    oe = &sc->table[i];
+    if (oe->key.a == IIIIIScNIL) continue;
+    index = Hash(oe->key.a, oe->key.b, oe->key.c, oe->key.d, sc);
+    while (1) {
+      ne = &nh[index];
+      if (ne->key.a == IIIIIScNIL) {
+	ne->key = oe->key;
+	ne->value = oe->value;
+	break;
+      } else {
+	index++;
+	if (index >= sc->size) index = 0;
+      }
+    }
+  }
+  vmFree((char *)sc->table);
+  sc->table = nh;
+#ifdef DEBUGSC
+  CheckOutHashTable(sc);
+#endif DEBUGSC
+}
+
+/* Return the value associated with key in collection sc, or IIIIIScNIL */
+IIIIIScRangeType IIIIIScLookup(sc, a, b, c, d)
+register IIIIISc sc;
+register int  a, b, c, d;
+{
+  register int index = Hash(a,b,c,d, sc);
+  register IIIIIScTEPtr e;
+
+#ifdef DEBUGSC
+  CheckOutHashTable(sc);
+#endif DEBUGSC
+  while (1) {
+    e = &sc->table[index];
+    if (e->key.a == IIIIIScNIL) {               /* we did not find it */
+      return IIIIIScNIL;
+    } else if (IIIIIScCOMPARE(e->key, a,b,c,d)) {
+      return e->value;
+    }
+    if (++index >= sc->size) index = 0;
+  }
+}
+
+/* Bump the value associated with key in collection sc, or insert 1 */
+IIIIIScRangeType IIIIIScBump(sc, a,b,c,d)
+register IIIIISc sc;
+register int  a,b,c,d;
+{
+  register int index = Hash(a,b,c,d, sc);
+  register IIIIIScTEPtr e;
+
+#ifdef DEBUGSC
+  CheckOutHashTable(sc);
+#endif DEBUGSC
+  while (1) {
+    e = &sc->table[index];
+    if (e->key.a == IIIIIScNIL) {               /* we did not find it */
+      IIIIIScInsert(sc,a,b,c,d,1);
+      return 1;
+    } else if (IIIIIScCOMPARE(e->key, a,b,c,d)) {
+      return ++e->value;
+    }
+    if (++index >= sc->size) index = 0;
+  }
+}
+
+/* Bump the value associated with key in collection sc by value */
+IIIIIScRangeType IIIIIScBumpBy(sc, a,b,c,d, value)
+register IIIIISc sc;
+register int a,b,c,d;
+int value;
+{
+  register int index = Hash(a,b,c,d, sc);
+  register IIIIIScTEPtr e;
+
+#ifdef DEBUGSC
+  CheckOutHashTable(sc);
+#endif DEBUGSC
+  while (1) {
+    e = &sc->table[index];
+    if (e->key.a == IIIIIScNIL) {               /* we did not find it */
+      IIIIIScInsert(sc, a,b,c,d, value);
+      return 1;
+    } else if (IIIIIScCOMPARE(e->key, a,b,c,d)) {
+      e->value += value;
+      return e->value;
+    }
+    if (++index >= sc->size) index = 0;
+  }
+}
+
+/* Insert the key, value pair in sc.  If the key already exists, change its 
+ * value. */
+void IIIIIScInsert(sc, a,b,c,d, value)
+register IIIIISc sc;
+register int a,b,c,d;
+IIIIIScRangeType value;
+{
+  register int index;
+  register IIIIIScTEPtr e;
+
+  if (sc->count >= sc->maxCount) ExpandHashTable(sc);
+  index = Hash(a,b,c,d, sc);
+  while (1) {
+    e = &sc->table[index];
+    if (e->key.a == IIIIIScNIL) {               /* put it here */
+      e->key.a = a;
+      e->key.b = b;
+      e->key.c = c;
+      e->key.d = d;
+      e->value = value;
+      sc->count++;
+#ifdef DEBUGSC
+      CheckOutHashTable(sc);
+#endif DEBUGSC
+      return;
+    } else if (IIIIIScCOMPARE(e->key, a,b,c,d)) {
+      e->value = value;
+#ifdef DEBUGSC
+      CheckOutHashTable(sc);
+#endif DEBUGSC
+      return;
+    }
+    if (++index >= sc->size) index = 0;
+  }
+}
+
+/* Remove the entry, if it is there */
+void IIIIIScDelete(sc, a,b,c,d)
+register IIIIISc sc;
+register int a,b,c,d;
+{
+  register int index = Hash(a,b,c,d, sc);
+  IIIIIScDomainType key;
+  register IIIIIScRangeType value;
+  register IIIIIScTEPtr e;
+
+  while (1) {
+    e = &sc->table[index];
+    if (e->key.a == IIIIIScNIL) {               /* we did not find it */
+#ifdef DEBUGSC
+      CheckOutHashTable(sc);
+#endif DEBUGSC
+      return;
+    }
+    if (IIIIIScCOMPARE(e->key, a,b,c,d)) {
+      /* Found it, now remove it */
+      sc->count--;
+      e->key.a = IIIIIScNIL;
+      e->value = IIIIIScNIL;
+      while (1) {
+	/* rehash until we reach nil again */
+	if (++index >= sc->size) index = 0;
+	e = & sc->table[index];
+	key = e->key;
+	if (key.a == IIIIIScNIL) {
+#ifdef DEBUGSC
+	  CheckOutHashTable(sc);
+#endif DEBUGSC
+	  return;
+	}
+	/* rehashing is done by removing then reinserting */
+	value = e->value;
+	e->key.a = IIIIIScNIL;
+	e->value = IIIIIScNIL;
+	sc->count--;
+	IIIIIScInsert(sc, key.a, key.b, key.c, key.d, value);
+      }
+    }
+    if (++index >= sc->size) index = 0;
+  }
+}
+
+/* DEBUGGING: Print the sc */
+void IIIIIScPrint(sc)
+register IIIIISc sc;
+{
+  int index;
+  register IIIIIScTEPtr e;
+
+  printf(
+    "\nDump of sc @ 0x%05x, %d entr%s, current max %d\nIndex\tKey                                            \tValue\n",
+    sc, sc->count, sc->count == 1 ? "y" : "ies",  sc->maxCount);
+  for (index = 0; index < sc->size; index++) {
+    e = &sc->table[index];
+    printf("%3d\t0x%08.8x 0x%08.8x 0x%08.8x 0x%08.8x\t%08.8x\n", index, e->key.a, e->key.b, e->key.c, e->key.d, e->value);
+  }
+}
+
+#ifdef DEBUGSC
+/* Make sure that the hash table is internally consistent:
+ *      every key is findable, 
+ *      count reflects the number of elements
+ */
+static void CheckOutHashTable(sc)
+register IIIIISc sc;
+{
+  register int i;
+  register IIIIIScTEPtr realElement, e;
+  register int index, firstIndex, count;
+  count = 0;
+
+  for (i = 0; i < sc->size; i++) {
+    realElement = &sc->table[i];
+    if (realElement->key.a != IIIIIScNIL) {
+      count++;
+      index = Hash(realElement->key.a, realElement->key.b, realElement->key.c, realElement->key.d, sc);
+      firstIndex = index;
+      while (1) {
+	e = &sc->table[index];
+	if (e->key.a == IIIIIScNIL) {           /* we did not find it */
+	  break;
+	} else if (IIIIIScCOMPARE(e->key, realElement->key.a, realElement->key.b, realElement->key.c, realElement->key.d)) {
+	  break;
+	} else {
+	  index++;
+	  if (index >= sc->size) index = 0;
+	  if (index == firstIndex) {
+	    index = -1;
+	    break;
+	  }
+	}
+      }
+      
+      if (index == -1 || !IIIIIScCOMPARE(e->key, realElement->key)) {
+FIX THIS
+	fprintf(stderr,
+	  "Sc problem: Key 0x%x, rightIndex %d, realIndex %d value 0x%x\n",
+	  realElement->key, firstIndex, index, realElement->value);
+	IIIIIScPrint(sc);
+      }
+    }
+  }  
+  if (count != sc->count) {
+    fprintf(stderr,
+      "Sc problem: Should have %d entries, but found %d.\n", sc->count,
+      count);
+    IIIIIScPrint(sc);
+  }
+}
+#endif
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/iiiiisc.h ubc-1.05alpha-src/vm/src/iiiiisc.h
--- sourceforge-1.06alpha/vm/src/iiiiisc.h	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/iiiiisc.h	2017-12-11 17:59:03.425711924 +0100
@@ -0,0 +1,98 @@
+/*
+ * IIIIIScs (searchable collections) are things that map 
+ * elements of some domain onto some range.  Operations:
+ *	create, destroy, insert, lookup, size, and print
+ */
+
+#ifndef _EMERALD_IIIIISC_H
+#define _EMERALD_IIIIISC_H
+
+#include "memory.h"
+
+/*
+ * This one is crafted differently from all others in that it takes its key
+ as separate integers, and so needed a fair amount of hand editing.
+ */
+typedef struct {
+  int a, b, c, d;
+} IIIIIScDomainType;
+#define IIIIIScRangeType  int
+#define IIIIIScHASH(W,X,Y,Z) ((unsigned)((W) ^ ((X)<<4) ^ (Y) ^ ((Z) >> 4)))
+#define IIIIIScCOMPARE(K,W,X,Y,Z) ((K).a==(W)&&(K).b==(X)&&(K).c==(Y)&&(K).d==(Z))
+#define IIIIIScNIL (-1)
+
+/*
+ * Hidden, private type declarations.  The only thing
+ * that applications of this package are to see is IIIIISc,
+ * and they are to treat it as opaque:  that is, they may
+ * assign it, and pass it as arguments, but not manipulate
+ * what it points to directly.
+ */
+
+typedef struct IIIIIScTE {
+    IIIIIScDomainType	 key;		/* the key for this entry */
+    IIIIIScRangeType	 value;		/* what we want */
+} IIIIIScTE, *IIIIIScTEPtr;
+
+typedef struct IIIIIScRecord {
+    IIIIIScTEPtr table;
+    int size, maxCount, count;
+} IIIIIScRecord, *IIIIISc;
+
+/* OPERATIONS */
+
+/* Return a new, empty Searchable Collection */
+IIIIISc IIIIIScCreate(void);
+
+/* Destroy a collection */
+void IIIIIScDestroy(IIIIISc sc);
+
+/* Insert the pair <key, value> into collection IIIIISc */
+void IIIIIScInsert(/* IIIIISc sc, int a, int b, int c, int d, IIIIIScRangeType value */);
+
+/* bump the value associated with some given key in the IIIIISc */
+int IIIIIScBump(/* IIIIISc sc, int a, int b, int c, int d*/);
+
+/* bump the value associated with some given key in the IIIIISc by value */
+int IIIIIScBumpBy(/* IIIIISc sc, int a, int b, int c, int d, int value*/);
+
+/* Delete the pair with key key from the collection IIIIISc */
+void IIIIIScDelete(/* IIIIISc sc, int a, int b, int c, int d */);
+
+/* Return the value associated with key in collection 
+ * IIIIISc, or 0 if no such pair exists */
+int IIIIIScLookup(/* IIIIISc sc, int a, int b, int c, int d */);
+
+/* DEBUGGING: Print the collection IIIIISc */
+void IIIIIScPrint(/* IIIIISc sc */);
+
+/* Iterate over the elements of the collection IIIIISc.  
+ * At each iteration, IIIIISckey and IIIIIScvalue are set to the next
+ * <key, value> pair in the collection.  
+ * Usage:
+ *	IIIIIScForEach(someSc, key, value) {
+ *	  / * whatever you want to do with key, value * /
+ *	} IIIIIScNext();
+ */
+#define IIIIIScForEach(IIIIISc, IIIIISckeya, IIIIISckeyb, IIIIISckeyc, IIIIIISckeyd, IIIIIScvalue) \
+  { \
+    int IIIIIScxx_index; \
+    for (IIIIIScxx_index = 0; IIIIIScxx_index < (IIIIISc)->size; IIIIIScxx_index++) { \
+      if ((IIIIISc)->table[IIIIIScxx_index].key != IIIIIScNIL) { \
+	*(int*)(&(IIIIISckeya)) = (IIIIISc)->table[IIIIIScxx_index].key.a; \
+	*(int*)(&(IIIIISckeyb)) = (IIIIISc)->table[IIIIIScxx_index].key.b; \
+	*(int*)(&(IIIIISckeyc)) = (IIIIISc)->table[IIIIIScxx_index].key.c; \
+	*(int*)(&(IIIIISckeyd)) = (IIIIISc)->table[IIIIIScxx_index].key.d; \
+	*(IIIIIScRangeType *)(&(IIIIIScvalue)) = (IIIIISc)->table[IIIIIScxx_index].value; \
+	{ 
+
+#define IIIIIScNext() \
+	} \
+      } \
+    } \
+  }
+
+/* Return the number of elements in IIIIISc */
+#define IIIIIScSize(IIIIISc) ((IIIIISc)->count)
+
+#endif /* _EMERALD_IIIIISC_H */
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/ilist.c ubc-1.05alpha-src/vm/src/ilist.c
--- sourceforge-1.06alpha/vm/src/ilist.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/ilist.c	2017-12-11 17:59:03.426711917 +0100
@@ -0,0 +1,126 @@
+/*
+ * Sequences:  Expanding arrays of keys
+ *  Adopted by Kim Gillies from Dr. Norm Hutchinson's iset.c
+ *  In sequence structure, count is the current number of items in the 
+ *  array, size is the physical length of the array
+ */
+
+#include "system.h"
+
+#include "assert.h"
+#include "ilist.h"
+
+static int sizes[] = {
+  5, 7, 17, 31,
+  67, 131, 257, 521,
+  1031, 2053, 4099, 8093,
+  16193, 32377, 65557, 131071,
+  262187, 524869, 1048829, 2097223,
+  4194371, 8388697, 16777291 };
+
+/* Return a new, empty ISet */
+IList IListCreate()
+{
+  register int i;
+  register IList sq;
+
+  sq = (IList) vmMalloc(sizeof(IListRecord));
+  if (sq == NULL) return NULL;
+  sq->size = sizes[0];
+  sq->count = 0;
+  sq->table = (IListTEPtr) vmMalloc((unsigned) sq->size * sizeof(IListTE));
+  if (sq->table == NULL) return NULL;
+  for (i = 0; i < sq->size; i++) {
+    sq->table[i].key = (int)NULL;
+  }
+  return sq;
+}
+
+void IListDestroy(sq)
+register IList sq;
+{
+  vmFree((char *)sq->table);
+  vmFree((char *)sq);
+}
+
+/* Expand the array.  Each element in the table is copied 
+ * in the new table.  The new space is initialized to NULL
+ */
+static void ExpandTable(IList sq)
+{
+  register int oldTableSize = sq->size, i;
+
+  for (i = 0; sizes[i] <= oldTableSize; i++) ;
+  sq->size = sizes[i];			/* the new size  */
+  sq->table = (IListTEPtr)vmRealloc(sq->table, (sq->size *sizeof(IListTE)));
+  for (i = oldTableSize; i < sq->size; i++) {
+    sq->table[i].key = (int)NULL;
+  }
+}
+
+/* Is key in the sequence sq, if so--return it (probably stupid) */
+IListDomainType IListMember(sq, key)
+register IList sq;
+register IListDomainType  key;
+{
+  register IListTEPtr e;
+  register int index, count;
+
+  count = sq->count;
+  for (index = 0; index < count; index++) {
+    e = &sq->table[index];
+    if (IListCOMPARE(e->key, key)) {
+      return e->key;
+    }
+  }
+  /* nothing found */
+  return (int)NULL;
+}
+
+/* Add the key to the end of sq */
+void IListInsert(sq, key)
+register IList sq;
+register IListDomainType key;
+{
+  register int count;
+
+  count = sq->count;
+  if (count >= sq->size) ExpandTable(sq);
+  sq->table[count].key = key;
+  sq->count++;
+}
+
+/* Remove the entry, if it is there */
+void IListDelete(sq, key)
+register IList sq;
+register IListDomainType key;
+{
+  register int index, count, j;
+
+  count = sq->count;
+  for (index = 0; index < count; index++) {
+    if (IListCOMPARE(sq->table[index].key, key)) {
+      for (j = index+1; j < count; j++) {
+	sq->table[j-1].key = sq->table[j].key;
+      }
+      sq->count--;
+      return;
+    }
+  }
+}
+
+/* DEBUGGING: Print the sq */
+void IListPrint(sq)
+register IList sq;
+{
+  IListDomainType key;
+  int index;
+
+  printf(
+    "\nDump of sq @ 0x%05x, %d entr%s, current max %d\n    Index\tKey\n",
+    (int)sq, sq->count, sq->count == 1 ? "y" : "ies",  sq->size);
+  for (index = 0; index < sq->size; index++) {
+    key = sq->table[index].key;
+    printf("%3d\t%-16.16d\n", index, key);
+  }
+}
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/ilist.h ubc-1.05alpha-src/vm/src/ilist.h
--- sourceforge-1.06alpha/vm/src/ilist.h	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/ilist.h	2017-12-11 17:59:03.426711917 +0100
@@ -0,0 +1,127 @@
+/*
+ * Seqs are an array sequence of some domain.
+ * Operations:
+ *	create, destroy, insert, member, size, and print
+ */
+
+#ifndef _EMERALD_ILIST_H
+#define _EMERALD_ILIST_H
+/*
+ * Before using this, one must define the following:
+ *	IListDomainType	- a typedef for the domain
+ *	IListCOMPARE	- a macro that compares two elements of 
+ *				  the domain, evaluating to 1 if they are 
+ *				  the same
+ */
+#define IListDomainType int
+#define IListCOMPARE(X,Y) ((X)==(Y))
+
+/*
+ * Hidden, private type declarations.  The only thing
+ * that applications of this package are to see is IList,
+ * and they are to treat it as opaque:  that is, they may
+ * assign it, and pass it as arguments, but not manipulate
+ * what it points to directly.
+ */
+
+typedef struct IListTE {
+    IListDomainType key;		/* the key for this entry */
+} IListTE, *IListTEPtr;
+
+typedef struct IListRecord {
+    IListTEPtr table;
+    int size, count;
+} IListRecord, *IList;
+
+/* OPERATIONS */
+
+/* Return a new, empty Searchable Collection */
+IList IListCreate(void);
+
+/* Destroy a collection */
+void IListDestroy(IList);
+
+/* Insert the key into the set IList */
+void IListInsert(IList sq, IListDomainType key);
+
+/* Delete the key key from the set IList */
+void IListDelete(IList sq, IListDomainType key);
+
+/* Return the key if it is in the set otherwise NULL */
+IListDomainType IListMember(IList sc, IListDomainType key);
+
+/* DEBUGGING: Print the collection IList */
+void IListPrint(IList sc);
+
+/* Iterate over the elements of the collection IList.  
+ * At each iteration, IListkey is set to the next key in the set.  
+ * Usage:
+ *	IListForEach(someSq, key) {
+ *	  / * whatever you want to do with key * /
+ *	} IListNext();
+ */
+#define IListForEach(IList, IListkey) \
+  { \
+    int IListxx_index; \
+    for (IListxx_index = 0; IListxx_index < (IList)->count; IListxx_index++) { \
+      *(IListDomainType*)(&(IListkey)) = IList->table[IListxx_index].key; \
+      { 
+
+/* Iterate over the elements of the collection IList.  
+ * At each iteration, IListkey is set to the next key in the set.  
+ * Usage:
+ *	IListForEachReverse(someSq, key) {
+ *	  / * whatever you want to do with key * /
+ *	} IListNext();
+ */
+#define IListForEachReverse(IList, IListkey) \
+  { \
+    int IListxx_index; \
+    for (IListxx_index = (IList->count-1); IListxx_index >= 0; IListxx_index--) { \
+      *(IListDomainType*)(&(IListkey)) = IList->table[IListxx_index].key; \
+      { 
+
+/* Iterate over the elements of the collection IList, two at a time.
+ * At each iteration, IListkey1 and IListkey2 are set to the next keys
+ * in the list.
+ * Usage:
+ *	IListForEachByTwo(someSq, key1, key2) {
+ *	  / * whatever you want to do with key1 and key2 * /
+ *	} IListNext();
+ */
+#define IListForEachByTwo(IList, IListkey1, IListkey2) \
+  { \
+    int IListxx_index; \
+    for (IListxx_index = 0; IListxx_index < (IList)->count; IListxx_index += 2) { \
+      *(IListDomainType*)(&(IListkey1)) = IList->table[IListxx_index].key; \
+      *(IListDomainType*)(&(IListkey2)) = IList->table[IListxx_index+1].key; \
+      {
+
+/* Iterate over the elements of the collection IList, three at a time.
+ * At each iteration, IListkey1, IListkey2, IListkey3 are set to the next
+ * keys in the set.
+ * Usage:
+ *	IListForEachByThree(someSq, key1, key2, key3) {
+ *	  / * whatever you want to do with key1, key2, key3 * /
+ *	} IListNext();
+ */
+#define IListForEachByThree(IList, IListkey1, IListkey2, IListkey3) \
+  { \
+    int IListxx_index; \
+    for (IListxx_index = 0; IListxx_index < (IList)->count; IListxx_index += 3) { \
+      *(IListDomainType*)(&(IListkey1)) = IList->table[IListxx_index].key; \
+      *(IListDomainType*)(&(IListkey2)) = IList->table[IListxx_index+1].key; \
+      *(IListDomainType*)(&(IListkey3)) = IList->table[IListxx_index+2].key; \
+      {
+
+#define IListNext() \
+      } \
+    } \
+  }
+
+/* Return the number of elements in IList */
+#define IListSize(IList) ((IList)->count)
+
+#include "storage.h"
+
+#endif /* _EMERALD_ILIST_H */
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/Makefile ubc-1.05alpha-src/vm/src/Makefile
--- sourceforge-1.06alpha/vm/src/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/Makefile	2017-12-11 17:59:03.420711962 +0100
@@ -0,0 +1,332 @@
+#
+# emx Makefile
+#
+
+#
+# These are set in the macroMf file for the particular architecture
+#
+COPT   = $(OPTCOPT)
+VMOPT  = $(OPTVMOPT)
+
+CPFLAGS = -I. -DSINGLESTEP -DCOUNTBYTECODES -DSTDARG_WORKS \
+	$(XCPFLAGS) $(X11FLA) $(LWPFLA)
+
+# no dependencies, these must be kept up to date manually
+LIB = $(XLIB) $(X11LIB) $(LWPLIB) $(EXTRALIB)
+
+.c.o:
+	rm -f $*.o ; $(CC) -c $(CFLAGS) $*.c
+
+.c.s:
+	rm -f $*.o ; $(CC) -S $(CFLAGS) $*.c
+
+CFLAGS   = $(CPFLAGS) $(COPT)
+VMFLAGS  = $(CPFLAGS) $(VMOPT)
+
+INC = \
+	array.h \
+	assert.h \
+	bufstr.h \
+	builtins.h \
+	call.h \
+	concurr.h \
+	config.h \
+	creation.h \
+	dist.h \
+	extract.h \
+	filestr.h \
+	gaggle.h \
+	gc.h \
+	globals.h \
+	iisc.h \
+	iixsc.h \
+	init.h \
+	insert.h \
+	io.h \
+	iosc.h \
+	iset.h \
+	joveisc.h \
+	jsys.h \
+	jvisc.h \
+	locate.h \
+	misc.h \
+	move.h \
+	mqueue.h \
+	oidtoobj.h \
+	oisc.h \
+	ooisc.h \
+	otable.h \
+	read.h \
+	remote.h \
+	rinvoke.h \
+	squeue.h \
+	storage.h \
+	streams.h \
+	system.h \
+	timer.h \
+	trace.h \
+	types.h \
+	vm.h \
+	vm_i.h \
+	vm_exp.h \
+	write.h \
+	$(X11INC) \
+	$(LWPINC)
+
+REALSRC = \
+	array.c \
+	bufstr.c \
+	call.c \
+	conform.c \
+	creation.c \
+	debug.c \
+	dist.c \
+	distgc.c \
+	filestr.c \
+	gaggle.c \
+	gc.c \
+	globals.c \
+	iisc.c \
+	iixsc.c \
+	io.c \
+	iosc.c \
+	iset.c \
+	joveisc.c \
+	jsys.c \
+	jvisc.c \
+	locate.c \
+	main.c \
+	misc.c \
+	move.c \
+	mqueue.c \
+	oidtoobj.c \
+	oisc.c \
+	ooisc.c \
+	otable.c \
+	read.c \
+	remote.c \
+	rinvoke.c \
+	squeue.c \
+	storage.c \
+	streams.c \
+	timer.c \
+	trace.c \
+	upcall.c \
+	vm.c \
+	write.c \
+	$(X11SRC) \
+	$(LWPSRC)
+
+CCALLSOBJ = cctab.o $(CCALLS_OBJ)
+
+CCALLSSRC = cctab.c $(CCALLS_SRC) 
+
+SRC =	$(REALSRC) $(CCALLSSRC) vm.d
+
+OBJ = \
+	vm.o \
+	array.o \
+	bufstr.o \
+	call.o \
+	conform.o \
+	creation.o \
+	debug.o \
+	dist.o \
+	distgc.o \
+	filestr.o \
+	gaggle.o \
+	gc.o \
+	globals.o \
+	iisc.o \
+	iixsc.o \
+	io.o \
+	iosc.o \
+	iset.o \
+	joveisc.o \
+	jsys.o \
+	jvisc.o \
+	locate.o \
+	main.o \
+	misc.o \
+	move.o \
+	mqueue.o \
+	oidtoobj.o \
+	oisc.o \
+	ooisc.o \
+	otable.o \
+	read.o \
+	remote.o \
+	rinvoke.o \
+	squeue.o \
+	storage.o \
+	streams.o \
+	timer.o \
+	trace.o \
+	upcall.o \
+	write.o \
+	$(GCOBJ) \
+	$(CCALLSOBJ) \
+	$(X11OBJ) \
+	$(LWPOBJ)
+
+ASSRC = \
+	vm.s \
+	array.s \
+	bufstr.s \
+	call.s \
+	conform.s \
+	creation.s \
+	debug.s \
+	dist.s \
+	distgc.s \
+	filestr.s \
+	gaggle.s \
+	gc.s \
+	globals.s \
+	iisc.s \
+	iixsc.s \
+	io.s \
+	iosc.s \
+	iset.s \
+	joveisc.s \
+	jsys.s \
+	jvisc.s \
+	locate.s \
+	main.s \
+	misc.s \
+	move.s \
+	mqueue.s \
+	oidtoobj.s \
+	oisc.s \
+	ooisc.s \
+	otable.s \
+	read.s \
+	remote.s \
+	rinvoke.s \
+	squeue.s \
+	storage.s \
+	streams.s \
+	timer.s \
+	trace.s \
+	upcall.s \
+	write.s \
+	$(GCASSRC) \
+	$(CCALLSASSRC) \
+	$(X11ASSRC) \
+	$(LWPASSRC)
+
+LIBDIR = lib/$(ARCH)
+
+LOAD = $(LIBDIR)/userrt0.o $(OBJ) $(LIBDIR)/libxsim.a
+
+all:	emx
+
+install: emx $(EMLIBDIR)/bcdef $(EMLIBDIR)/jsdef
+
+$(EMLIBDIR)/jsdef : jsys.h
+	cp jsys.h $@
+	chmod 664 $@
+
+$(EMLIBDIR)/bcdef : vm.h
+	cp vm.h $@
+	chmod 664 $@
+
+cctab.h cctab.c:	$(EMERALDROOT)/ccalls/*.h $(EMERALDROOT)/lib/$(EMERALDARCH)/macroMf
+	gencctab $(CCALLS_OBJ)
+
+tags:	$(SRC) $(INC)
+	/usr/bin/ctags -tw $(SRC) $(INC)
+
+cxref:	$(SRC) $(INC)
+	cxref `make csrc inc` -xref -html $(CPFLAGS)
+	cxref -index-all -html
+
+vm.c:	vm.d
+	if issymlink vm.c ; then \
+	  mv -f ../src/vm.h ../src/vm.h.orig ; \
+	  mv -f ../src/vm_i.h ../src/vm_i.h.orig ; \
+	  rm -f ../src/vm.c ../src/vm.h ../src/vm_i.h ; \
+	else \
+	  mv -f vm.h vm.h.orig ; \
+	  mv -f vm_i.h vm_i.h.orig ; \
+	  rm -f vm.c vm.h vm_i.h ; \
+	fi
+	vmc vm.d
+	if issymlink vm.c ; then \
+	  if [ -r ../src/vm.h.orig ] && cmp -s ../src/vm.h ../src/vm.h.orig ; then mv ../src/vm.h.orig ../src/vm.h ; fi ; \
+	  if [ -r ../src/vm_i.h.orig ] && cmp -s ../src/vm_i.h ../src/vm_i.h.orig ; then mv ../src/vm_i.h.orig ../src/vm_i.h ; fi ; \
+	else \
+	  if [ -r vm.h.orig ] && cmp -s vm.h vm.h.orig ; then mv vm.h.orig vm.h ; fi ; \
+	  if [ -r vm_i.h.orig ] && cmp -s vm_i.h vm_i.h.orig ; then mv vm_i.h.orig vm_i.h ; fi ; \
+	fi
+	chmod -w vm.c vm.h vm_i.h
+
+vm.o: vm.c types.h
+	rm -f vm.o ; $(CC) $(VMFLAGS) -c vm.c
+
+emx:	$(OBJ)
+	@echo linking...
+	@-rm -f emx.dead
+	@-mv -f emx emx.dead
+	$(CC) $(CFLAGS) $(OBJ) -o emx $(LIB) -lm
+	@-rm -f emx.dead
+
+emx.s:	$(ASSRC)
+
+#
+# Because test -h doesn't work on all machines, we use a
+# machine dependent issymlink script
+#
+links:
+	for x in $(REALSRC) vm.d $(INC) ; do \
+	  if issymlink $$x ; then rm $$x ; fi ; \
+	  ln -s ../src/$$x . ; \
+	done
+
+checkout:
+	for x in $(REALSRC) vm.d $(INC) ; do \
+	  if issymlink $$x ; then \
+	    true; \
+	  else if cmp -s ../src/$$x $$x ; then \
+	    echo "$$x is a copy of the real thing." ; \
+	  else \
+	    echo "Something funny with $$x" ; \
+	    ls -l $$x ; \
+	  fi ; fi ; \
+	done
+
+mothball:	clean
+	for x in $(REALSRC) vm.d $(INC) ; do \
+	  if issymlink $$x ; then \
+	    rm -f $$x ; \
+	  else \
+	    echo "Something funny with $$x" ; \
+	    ls -l $$x ; \
+	  fi ; \
+	done
+	rm Makefile
+
+clean:
+	rm -f emx $(OBJ) $(LWPOBJ)
+
+sources src:
+	@echo $(SRC) | sed -e 's/vm.c//'
+
+csources csrc:
+	@echo $(SRC) | sed -e 's/vm.d//'
+
+objects obj:
+	@echo $(OBJ)
+
+includes inc:
+	@echo $(INC)
+
+# WARNING!  Hackish behaviour below.
+# We require $SRC == $(REALSRC) $(CCALLSSRC) vm.d
+# There appear to be dragons ^H^H^H line length limits on a Unix
+# command, so we have to build dependencies with more than one
+# command line.  Also, we can't do a make depend on vm.d,
+# as it's not legal C, so need to exclude it specifically.
+depend:	$(SRC)
+	$(DEPEND) $(CFLAGS) $(REALSRC) >  Makefile.depend
+	$(DEPEND) $(CFLAGS) $(CCALLSSRC)  >> Makefile.depend
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/Makefile.am ubc-1.05alpha-src/vm/src/Makefile.am
--- sourceforge-1.06alpha/vm/src/Makefile.am	2017-12-11 17:59:03.087714500 +0100
+++ ubc-1.05alpha-src/vm/src/Makefile.am	1970-01-01 01:00:00.000000000 +0100
@@ -1,123 +0,0 @@
-bin_PROGRAMS = emx
-
-noinst_PROGRAMS = codeptrextra 
-
-noinst_SCRIPTS = gencodeptrextra.sh
-
-EXTRA_DIST =  gencodeptrextra.sh
-
-codeptrextra_SOURCES = codeptrextra.c
-
-emx_SOURCES = array.c \
-	bufstr.c \
-	call.c \
-	conform.c \
-	creation.c \
-	debug.c \
-	dist.c \
-	distgc.c \
-	filestr.c \
-	gaggle.c \
-	gc.c \
-	globals.c \
-	iisc.c \
-	iixsc.c \
-	io.c \
-	iosc.c \
-	iset.c \
-	joveisc.c \
-	jsys.c \
-	jvisc.c \
-	locate.c \
-	main.c \
-	misc.c \
-	move.c \
-	mqueue.c \
-	oidtoobj.c \
-	oisc.c \
-	ooisc.c \
-	otable.c \
-	read.c \
-	remote.c \
-	rinvoke.c \
-	squeue.c \
-	storage.c \
-	streams.c \
-	timer.c \
-	trace.c \
-	upcall.c \
-	vm.c \
-	write.c \
-	cctab.c 
-#\
-#	$(X11SRC) \
-#	$(LWPSRC)
-include_HEADERS = \
-	array.h \
-	assert.h \
-	bufstr.h \
-	builtins.h \
-	call.h \
-	concurr.h \
-	config.h \
-	creation.h \
-	dist.h \
-	extract.h \
-	filestr.h \
-	gaggle.h \
-	gc.h \
-	globals.h \
-	iisc.h \
-	iixsc.h \
-	init.h \
-	insert.h \
-	io.h \
-	iosc.h \
-	iset.h \
-	joveisc.h \
-	jsys.h \
-	jvisc.h \
-	locate.h \
-	misc.h \
-	move.h \
-	mqueue.h \
-	oidtoobj.h \
-	oisc.h \
-	ooisc.h \
-	otable.h \
-	read.h \
-	remote.h \
-	rinvoke.h \
-	squeue.h \
-	storage.h \
-	streams.h \
-	system.h \
-	timer.h \
-	trace.h \
-	types.h \
-	vm.h \
-	vm_i.h \
-	vm_exp.h \
-	write.h \
-	cctab.h \
-	codeptrextra.h 
-#\
-#	$(X11INC) \
-#	$(LWPINC)
-
-emx_LDADD = ../../ccalls/libccalls.a
-
-EMERALDROOT=$(top_srcdir)
-
-BUILT_SOURCES = cctab.c codeptrextra.h
-
-CLEANFILES = cctab.c cctab.h codeptrextra.h
-
-codeptrextra.h:	codeptrextra
-	./gencodeptrextra.sh
-
-cctab.h: cctab.c
-
-cctab.c: Makefile
-	EMERALDROOT=$(top_srcdir) $(top_srcdir)/bin/gencctab.sh `cd $(top_srcdir)/ccalls;ls *.o`
-
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/Makefile.DOS ubc-1.05alpha-src/vm/src/Makefile.DOS
--- sourceforge-1.06alpha/vm/src/Makefile.DOS	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/Makefile.DOS	2017-12-11 17:59:03.420711962 +0100
@@ -0,0 +1,460 @@
+#
+# definitions of Emerald
+# global macros
+#
+
+# global definitions
+
+# instead of $(MAKE), use $(EMMAKE) within Makefiles
+
+# some versions of make (notably sgi's and m88k's) use the user's
+# current shell rather than sh to execute commands by default.
+# Twits.
+
+# source for the ccalls lives here
+CCALLSDIR = /emerald/ccalls
+
+# lib material; includes live here, and libraries live in architecture
+# specific subdirectories of here
+EMLIBDIR = /emerald/lib
+EMBINDIR = /emerald/bin
+
+# Installation paths for DOS
+EMLIBXDIR = \emerald\lib
+EMBINXDIR = \emerald\bin
+
+# defaults.  May be overridden in architecture specific macroMakefiles
+
+# ranlib
+RANLIB = ranlib
+
+# awk
+AWK = awk
+
+# sed
+SED = sed
+
+CP = copy
+CHMOD = rem
+#
+# i386mach specific definitions
+# of commonly-used macros
+#
+
+# architecture definition
+
+# (ANSI) C compiler
+CC = gcc
+
+# definitions to enable common extensions in headers and libraries
+XGCCPFLAGS =
+
+XCPFLAGS = -DDOS -DEMERALDROOT=\"/emerald\"
+
+XLIB =
+
+# C preprocessor
+CPP = gcc -E
+
+# dependency generator
+DEPEND = gcc -MM
+
+# debugging information, no warnings
+CFLAGSDBG = -g -O2
+DBGCOPT   = $(CFLAGSDBG)
+DBGCPROPT = $(CFLAGSDBG)
+DBGVMOPT  = $(CFLAGSDBG)
+
+# maximum optimization, no warnings
+CFLAGSOPT = -O2
+OPTCOPT   = $(CFLAGSOPT)
+OPTCPROPT = $(CFLAGSOPT) -fno-force-mem
+OPTVMOPT  = $(CFLAGSOPT)
+
+#
+# emx Makefile
+#
+
+#
+# For debugging
+#
+# COPT   = $(DBGCOPT)
+# CPROPT = $(DBGCPROPT)
+# VMOPT  = $(DBGVMOPT)
+
+#
+# For optimizing
+#
+COPT   = $(OPTCOPT)
+CPROPT = $(OPTCPROPT)
+VMOPT  = $(OPTVMOPT)
+
+#
+# For xkernel
+#
+# LWPFLA = -DCONCURRENT -DXKERNEL -Ishare -Iprotocols -Isimul -DUNIX
+# LWPLIB =
+
+#
+# For suns sunlwp
+#
+# LWPFLA = -DCONCURRENT -DSUNLWP '-DLWPINDIR='
+# LWPLIB = -lnbio -llwp
+
+
+CCALLSCPFLAGS = -I$(EMLIBDIR) -I$(CCALLSDIR)/misc \
+        -I$(CCALLSDIR)/regexp -I$(CCALLSDIR)/streams
+
+CPFLAGS = $(XCPFLAGS) \
+	-I. -I$(EMLIBDIR) \
+	-DIMPLEMENTCONCURRENCY -UTIMESLICE \
+	-DSINGLESTEP -DCOUNTBYTECODES \
+	$(X11FLA) $(LWPFLA)
+
+# no dependencies, these must be kept up to date manually
+LIB = -L$(EMLIBDIR) $(XLIB) $(X11LIB) $(LWPLIB)
+
+.c.o:
+	$(CC) -c $(CFLAGS) $*.c
+
+CFLAGS   = $(COPT)   $(CPFLAGS)
+CPRFLAGS = $(CPROPT) $(CPFLAGS)
+VMFLAGS  = $(VMOPT)  $(CPFLAGS)
+
+INC = \
+	array.h \
+	assert.h \
+	builtins.h \
+	codemsg.h \
+	concurr.h \
+	creation.h \
+	decmsg.h \
+	encmsg.h \
+	error.h \
+	filestr.h \
+	gc.h \
+	globals.h \
+	hash.h \
+	iisc.h \
+	iixsc.h \
+	ilist.h \
+	init.h \
+	iosc.h \
+	iset.h \
+	joveisc.h \
+	jsys.h \
+	jvisc.h \
+	memory.h \
+	message.h \
+	misc.h \
+	oidtoobj.h \
+	oisc.h \
+	ooisc.h \
+	read.h \
+	sisc.h \
+	sockstr.h \
+	squeue.h \
+	streams.h \
+	trace.h \
+	types.h \
+	unalign.h \
+	vm.h \
+	vm_i.h \
+	vm_exp.h \
+	write.h \
+	$(X11INC)
+
+REALSRC = \
+	array.c \
+	codemsg.c \
+	conform.c \
+	creation.c \
+	debug.c \
+	decmsg.c \
+	encmsg.c \
+	error.c \
+	filestr.c \
+	gc.c \
+	globals.c \
+	hash.c \
+	iisc.c \
+	iixsc.c \
+	ilist.c \
+	iosc.c \
+	iset.c \
+	joveisc.c \
+	jsys.c \
+	jvisc.c \
+	main.c \
+	message.c \
+	misc.c \
+	oidtoobj.c \
+	oisc.c \
+	ooisc.c \
+	read.c \
+	sisc.c \
+	sockstr.c \
+	squeue.c \
+	streams.c \
+	trace.c \
+	vm.c \
+	write.c \
+	$(X11SRC)
+
+CCALLSOBJ = cctab.o emstream.o hello.o regexp.o regsub.o regerror.o string.o
+
+CCALLSSRC = $(EMLIBDIR)/cctab.c $(CCALLSDIR)/streams/emstream.c \
+        $(EMLIBDIR)/misc/hello.c $(EMLIBDIR)/regexp/regexp.c \
+        $(EMLIBDIR)/regexp/regsub.c $(EMLIBDIR)/regexp/regerror.c \
+	$(EMLIBDIR)/string/string.c
+
+SRC =   $(REALSRC) $(CCALLSSRC) vm.d
+
+OBJ = \
+	array.o \
+	codemsg.o \
+	conform.o \
+	creation.o \
+	debug.o \
+	decmsg.o \
+	encmsg.o \
+	error.o \
+	filestr.o \
+	gc.o \
+	globals.o \
+	hash.o \
+	iisc.o \
+	iixsc.o \
+	ilist.o \
+	iosc.o \
+	iset.o \
+	joveisc.o \
+	jsys.o \
+	jvisc.o \
+	main.o \
+	message.o \
+	misc.o \
+	oidtoobj.o \
+	oisc.o \
+	ooisc.o \
+	read.o \
+	sisc.o \
+	sockstr.o \
+	squeue.o \
+	streams.o \
+	trace.o \
+	vm.o \
+	write.o \
+	$(GCOBJ) \
+	$(CCALLSOBJ) \
+	$(X11OBJ)
+
+LIBDIR = lib/$(ARCH)
+
+LOAD = $(LIBDIR)/userrt0.o $(OBJ) $(LIBDIR)/libxsim.a
+
+all:    emx.exe
+
+install: $(EMBINDIR)/emx.exe $(EMLIBDIR)/bcdefs
+
+$(EMLIBDIR)/bcdefs : vm.h
+	$(CP) vm.h $(EMLIBXDIR)\bcdefs
+	$(CHMOD) 664 $(EMLIBXDIR)\bcdefs
+
+$(EMBINDIR)/emx.exe : emx.exe
+	$(CP) emx.exe $(EMBINXDIR)\emx.exe
+
+cctab.o:
+	$(CC) -c $(CCALLSCPFLAGS) $(CFLAGS) $(EMLIBDIR)/cctab.c
+
+emstream.o:
+	$(CC) -c $(CCALLSCPFLAGS) $(CFLAGS) $(CCALLSDIR)/streams/emstream.c
+
+hello.o:
+	$(CC) -c $(CCALLSCPFLAGS) $(CFLAGS) $(CCALLSDIR)/misc/hello.c
+
+regexp.o:
+	$(CC) -c $(CCALLSCPFLAGS) $(CFLAGS) $(CCALLSDIR)/regexp/regexp.c
+
+regsub.o:
+	$(CC) -c $(CCALLSCPFLAGS) $(CFLAGS) $(CCALLSDIR)/regexp/regsub.c
+
+regerror.o:
+	$(CC) -c $(CCALLSCPFLAGS) $(CFLAGS) $(CCALLSDIR)/regexp/regerror.c
+
+string.o:
+	$(CC) -c $(CCALLSCPFLAGS) $(CFLAGS) $(CCALLSDIR)/string/string.c
+
+tags:   $(SRC) $(INC)
+	ctags -tw $(SRC) $(INC)
+
+unalign.h:
+	sed -n -e '1,/define IFETCH1/p' < vm.c > unalign.h
+
+vm.h vm_i.h vm.c:       vm.d
+	if issymlink vm.c ; then \
+	  rm -f ../src/vm.c ../src/vm.h ../src/vm_i.h ; \
+	else \
+	  rm -f vm.c vm.h vm_i.h ; \
+	fi
+	vmc vm.d
+	chmod -w vm.c vm.h vm_i.h
+
+vm.o: vm.c types.h
+	$(CC) $(VMFLAGS) -c vm.c
+
+vm.s: vm.c types.h
+	$(CC) -S $(VMFLAGS) vm.c
+
+vm.x: vm.c types.h
+	$(CPP) $(VMFLAGS) vm.c > vm.x
+
+#ncpr.o: ncpr.c types.h
+#       $(CC) $(CPRFLAGS) -c ncpr.c
+
+xvm.o: vm.c types.h
+	$(CC) $(VMFLAGS) -o xvm.o -c vm.c
+
+xcreation.o: creation.c types.h
+	$(CC) $(CFLAGS) -o xcreation.o -c creation.c
+
+user:   $(LOAD)
+	ld -r -o user $(LOAD)
+
+emx.exe: emx
+	coff2exe emx
+
+emx:    $(OBJ)
+	@echo linking ...
+	$(CC) $(CFLAGS) $(OBJ) -o emx $(LIB)
+
+#
+# Because test -h doesn't work on all machines, we use a
+# machine dependent issymlink script
+#
+links:
+	for x in $(REALSRC) vm.d $(INC) ; do \
+	  if issymlink $$x ; then rm $$x ; fi ; \
+	  ln -s ../src/$$x . ; \
+	done
+
+checkout:
+	for x in $(REALSRC) vm.d $(INC) ; do \
+	  if issymlink $$x ; then \
+	    true; \
+	  else if cmp -s ../src/$$x $$x ; then \
+	    echo "$$x is a copy of the real thing." ; \
+	  else \
+	    echo "Something funny with $$x" ; \
+	    ls -l $$x ; \
+	  fi ; fi ; \
+	done
+
+mothball:       clean
+	for x in $(REALSRC) vm.d $(INC) ; do \
+	  if issymlink $$x ; then \
+	    rm -f $$x ; \
+	  else \
+	    echo "Something funny with $$x" ; \
+	    ls -l $$x ; \
+	  fi ; \
+	done
+	rm Makefile
+
+clean:
+	rm -f xvm emx user $(OBJ)
+
+sources src:
+	@echo $(SRC)
+
+objects obj:
+	@echo $(OBJ)
+
+includes inc:
+	@echo $(INC)
+
+# WARNING!  Hackish behaviour below.
+# We require $SRC == $(REALSRC) $(CCALLSSRC) vm.d
+# There appear to be dragons ^H^H^H line length limits on a Unix
+# command, so we have to build dependencies with more than one
+# command line.  Also, we can't do a make depend on vm.d,
+# as it's not legal C, so need to exclude it specifically.
+depend: $(SRC)
+	$(DEPEND) $(CFLAGS) $(REALSRC)    >  makedep
+	$(DEPEND) $(CFLAGS) $(CCALLSSRC)  >> makedep
+	@echo '$$r makedep' > eddep
+	@echo '/^# DO NOT DELETE THIS LINE/+1,$$d' >>eddep
+	@echo '$$r makedep' >>eddep
+	@echo 'w' >>eddep
+	@cp Makefile Makefile.bak
+	@ex - Makefile < eddep
+	@rm eddep makedep
+
+# DO NOT DELETE THIS LINE -- make depend uses it
+array.o : array.c misc.h types.h streams.h memory.h array.h 
+codemsg.o : codemsg.c codemsg.h types.h streams.h vm_exp.h vm_i.h \
+  vm.h assert.h globals.h builtins.h iisc.h memory.h misc.h jsys.h creation.h \
+  oidtoobj.h oisc.h iosc.h squeue.h concurr.h iset.h trace.h hash.h 
+conform.o : conform.c types.h streams.h assert.h ooisc.h memory.h trace.h globals.h \
+  builtins.h iisc.h oidtoobj.h oisc.h iosc.h 
+creation.o : creation.c memory.h types.h streams.h vm_exp.h vm_i.h vm.h assert.h \
+  globals.h builtins.h iisc.h misc.h jsys.h creation.h oidtoobj.h oisc.h \
+  iosc.h squeue.h concurr.h iset.h trace.h 
+debug.o : debug.c assert.h vm_exp.h vm_i.h vm.h types.h globals.h builtins.h \
+  iisc.h memory.h misc.h jsys.h creation.h oidtoobj.h oisc.h iosc.h squeue.h \
+  concurr.h iset.h trace.h read.h array.h streams.h 
+decmsg.o : decmsg.c assert.h builtins.h globals.h iisc.h memory.h \
+  types.h streams.h decmsg.h codemsg.h vm_exp.h vm_i.h vm.h misc.h \
+  jsys.h creation.h oidtoobj.h oisc.h iosc.h squeue.h concurr.h iset.h trace.h \
+  hash.h message.h sockstr.h 
+encmsg.o : encmsg.c encmsg.h codemsg.h types.h streams.h \
+  vm_exp.h vm_i.h vm.h assert.h globals.h builtins.h iisc.h memory.h misc.h \
+  jsys.h creation.h oidtoobj.h oisc.h iosc.h squeue.h concurr.h iset.h trace.h \
+  hash.h 
+error.o : error.c error.h 
+filestr.o : filestr.c filestr.h streams.h assert.h error.h memory.h 
+gc.o : gc.c gc.h types.h streams.h assert.h 
+globals.o : globals.c types.h streams.h globals.h builtins.h iisc.h memory.h \
+  jsys.h 
+hash.o : hash.c assert.h hash.h memory.h 
+iisc.o : iisc.c iisc.h memory.h assert.h 
+ilist.o : ilist.c assert.h ilist.h memory.h 
+iosc.o : iosc.c iosc.h memory.h types.h streams.h assert.h 
+iset.o : iset.c assert.h iset.h memory.h 
+joveisc.o : joveisc.c assert.h joveisc.h types.h streams.h array.h memory.h \
+  iisc.h 
+jsys.o : jsys.c init.h trace.h types.h streams.h globals.h builtins.h iisc.h \
+  memory.h oidtoobj.h oisc.h iosc.h assert.h 
+jvisc.o : jvisc.c jvisc.h memory.h types.h streams.h assert.h 
+main.o : main.c types.h streams.h iisc.h memory.h trace.h assert.h vm_exp.h \
+  vm_i.h vm.h globals.h builtins.h misc.h jsys.h creation.h oidtoobj.h oisc.h \
+  iosc.h squeue.h concurr.h iset.h 
+message.o : message.c error.h message.h types.h streams.h vm_exp.h vm_i.h vm.h \
+  assert.h globals.h builtins.h iisc.h memory.h misc.h jsys.h creation.h oidtoobj.h \
+  oisc.h iosc.h squeue.h concurr.h iset.h trace.h \
+  decmsg.h codemsg.h hash.h encmsg.h sockstr.h 
+misc.o : misc.c iset.h memory.h iisc.h hash.h trace.h types.h streams.h misc.h \
+  error.h assert.h vm_exp.h vm_i.h vm.h globals.h builtins.h jsys.h creation.h \
+  oidtoobj.h oisc.h iosc.h squeue.h concurr.h \emerald\lib\cctab.h 
+oidtoobj.o : oidtoobj.c iset.h memory.h oidtoobj.h types.h streams.h \
+  oisc.h iosc.h ooisc.h globals.h builtins.h iisc.h trace.h read.h array.h 
+oisc.o : oisc.c oisc.h memory.h types.h streams.h assert.h 
+ooisc.o : ooisc.c ooisc.h memory.h types.h streams.h assert.h 
+read.o : read.c memory.h array.h assert.h write.h types.h streams.h read.h iisc.h \
+  oisc.h codemsg.h vm_exp.h vm_i.h vm.h globals.h builtins.h misc.h jsys.h \
+  creation.h oidtoobj.h iosc.h squeue.h concurr.h iset.h trace.h hash.h \
+  joveisc.h jvisc.h message.h filestr.h 
+sisc.o : sisc.c assert.h sisc.h memory.h 
+sockstr.o : sockstr.c sockstr.h streams.h types.h error.h \
+  memory.h misc.h assert.h 
+squeue.o : squeue.c squeue.h memory.h assert.h 
+streams.o : streams.c error.h streams.h memory.h assert.h 
+trace.o : trace.c assert.h trace.h 
+vm.o : vm.c vm_i.h vm.h assert.h types.h streams.h globals.h builtins.h iisc.h \
+  memory.h misc.h jsys.h creation.h oidtoobj.h oisc.h iosc.h squeue.h concurr.h \
+  iset.h trace.h sisc.h ilist.h 
+write.o : write.c array.h builtins.h codemsg.h types.h streams.h vm_exp.h \
+  vm_i.h vm.h assert.h globals.h iisc.h memory.h misc.h jsys.h creation.h oidtoobj.h \
+  oisc.h iosc.h squeue.h concurr.h iset.h trace.h hash.h error.h filestr.h \
+  read.h write.h 
+cctab.o : ..\..\lib\cctab.c ..\..\lib\cctab.h 
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/memory.h ubc-1.05alpha-src/vm/src/memory.h
--- sourceforge-1.06alpha/vm/src/memory.h	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/memory.h	2017-12-11 17:59:03.427711909 +0100
@@ -0,0 +1,26 @@
+/****************************************************************************
+ File     : memory.h
+ Date     : 06-22-92
+ Author   : Mark Immel
+
+ Contents : Memory allocation functions
+
+ Modifications
+ -------------
+
+*****************************************************************************/
+
+#ifndef _EMERALD_MEMORY_H
+#define _EMERALD_MEMORY_H
+
+#include "threads.h"
+
+extern int strncmp(const char *, const char *, size_t);
+extern void *gc_malloc(int);
+extern void *gc_malloc_nogc(int), *gc_malloc_old(int nb, int remember);
+extern void *extraRoots[];
+extern int     extraRootsSP;
+#define regRoot(x) (extraRoots[extraRootsSP++] = (void *)&(x))
+#define unregRoot() ( extraRoots[--extraRootsSP] = 0)
+#endif /* _EMERALD_MEMORY_H */
+
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/mthreads.c ubc-1.05alpha-src/vm/src/mthreads.c
--- sourceforge-1.06alpha/vm/src/mthreads.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/mthreads.c	2017-12-11 17:59:03.427711909 +0100
@@ -0,0 +1,642 @@
+/*
+ * Copyright (C) Norman C. Hutchinson and the University of British Columbia
+ */
+#pragma warning(disable: 4068)
+#pragma pointer_size long
+#include <sys/types.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+
+#ifdef WIN32
+#  ifdef MSVC40
+#    include <winsock.h>
+#  else
+#    include <winsock2.h>
+#  endif
+#  include <io.h>
+#  include <errno.h>
+#  include <assert.h>
+#  include <errno.h>
+#else /* not WIN32 */
+#  include <unistd.h>
+#  include <sys/socket.h>
+#  if !defined(linux) && !defined(hpux) && !defined(sun4) && !defined(__NeXT__)
+#    include <sys/select.h>
+#  endif
+#  include <sys/uio.h>
+#  include <sys/errno.h>
+   extern int errno;
+#  include <signal.h>
+#  include <netinet/in.h>
+#  include <netinet/tcp.h>
+#  include <netdb.h>
+#endif /* not WIN32 */
+
+#pragma pointer_size short
+#include "assert.h"
+
+#include "mthreads.h"
+#include "io.h"
+#include "mqueue.h"
+
+#ifdef WIN32
+extern int gettimeofday(struct timeval *, void *);
+#else /* not WIN32 */
+#ifndef SELECTSIZE_T
+#define SELECTSIZE_T size_t
+#endif
+#ifndef SELECTFD_T
+#define SELECTFD_T fd_set
+#endif
+#ifndef SELECTCONST
+#define SELECTCONST const
+#endif
+
+#ifndef FAKEREAD
+#define reax(fd, buf, nbytes) read(fd, buf, nbytes)
+#else
+extern int reax(int fd, void *buf, int nbytes);
+#endif
+#ifndef FAKEWRITE
+#define writx(fd, buf, nbytes) write(fd, buf, nbytes)
+#else
+extern int writx(int fd, const void *buf, int nbytes);
+#endif
+#ifndef FAKESELECT
+#define selecx(fd, r, w, x, t) select(fd, r, w, x, t)
+#else
+extern int selecx(SELECTSIZE_T fd, SELECTFD_T *r, SELECTFD_T *w, SELECTFD_T *x, SELECTCONST struct timeval *t);
+#endif
+
+
+#define MAXOTHERS 128
+static int nothers;
+struct other {
+  NodeAddr id;
+  int s;
+} others[MAXOTHERS], cache;
+
+MQueue incoming, deferred;
+
+/*
+ * Forward declarations.
+ */
+static void setupReader(struct other *ri);
+
+#ifdef MTDEBUG
+#define TRACE(level, stuff) if (level <= MTdebuglevel) printf stuff
+int MTdebuglevel = 99;
+#else
+#define TRACE(level, stuff)
+#endif
+
+extern int checkSameUser;
+
+void MTPoll(void);
+
+static void (*mter)(void);
+
+void MTRegisterExitRoutine(void (*r)(void))
+{
+  assert(!mter);
+  mter = r;
+}
+
+static void callExitRoutines(void)
+{
+  if (mter) mter();
+}
+
+static void pipeHandler(int signalnumber)
+{
+}
+
+static void intrHandler(int signalnumber)
+{
+  callExitRoutines();
+  exit(1);
+}
+
+#endif /* WIN32 */
+
+ssize_t MTwrite2(int fd, void *buf1, size_t n1, void *buf2, size_t n2)
+{
+  int res;
+  struct iovec v[2];
+  int howmany = 2;
+  v[0].iov_base = buf1;
+  v[0].iov_len = n1;
+  v[1].iov_base = buf2;
+  v[1].iov_len = n2;
+  TRACE(4, ("write2 on %d for %d+%d bytes\n", fd, n1, n2));
+  if (fd < 0) return -1;
+  while (1) {
+#ifdef WIN32
+    res = send(fd, v[0].iov_base, v[0].iov_len, 0);
+#else
+    res = writev(fd, v, howmany);
+#endif /* WIN32 */
+    TRACE(4, ("write2 wrote %d\n", res));
+    if ((unsigned)res == v[0].iov_len + v[1].iov_len) {
+      res = n1 + n2;
+      break;
+    } else if (res > 0) {
+      /* Only wrote a part, fix up things */
+      if ((unsigned)res < v[0].iov_len) {
+	v[0].iov_len -= res;
+	v[0].iov_base += res;
+      } else {
+	res -= v[0].iov_len;
+	v[0].iov_len = v[1].iov_len - res;
+	v[0].iov_base = v[1].iov_base + res;
+	v[1].iov_base = 0;
+	v[1].iov_len = 0;
+	howmany = 1;
+      }
+    } else {
+      printf("write2 error %d\n", res);
+      perror("write2");
+      break;
+    }
+  }
+  TRACE(4, ("write2 returning %d\n", res));
+  return res;
+}
+
+#if 0
+static int doem(fd_set *fds, MTWhy why)
+{
+  int index, offset, found = 0, which;
+  for (offset = 0, index = 0; offset <= realnfds; offset += 32, index++) {
+    while ((which = ffs(fds->fds_bits[index])) > 0) {
+      found ++;
+      assert(FD_ISSET(offset + which - 1, fds));
+      FD_CLR(offset + which - 1, fds);
+      TRACE(7, ("Found %d ready for %d\n", offset + which - 1, why));
+      if (fdsems[offset + which - 1][why].count < 0) {
+	MTSemV(&fdsems[offset + which - 1][why]);
+      } else {
+	/* This had better be the multi waiter from select */
+	MTSemV(&waitonmulti);
+      }
+    }
+  }
+  return found;
+}
+#endif
+
+#ifdef __linux
+# define sigvec		sigaction
+# define sv_mask	sa_mask
+# define sv_flags	sa_flags
+# define sv_handler	sa_handler
+# define sv_onstack	sa_mask /* ouch, this one really hurts */
+#endif /* __linux */
+
+#ifdef hp700
+#define SIGVEC sigvector
+#else
+#define SIGVEC sigvec
+#endif /* hp700 */
+
+struct header {
+  int length;
+};
+
+NodeAddr myid;
+static int mysocket;
+
+struct nbo {
+  unsigned int ipaddress;
+  unsigned short port, incarnation;
+  int userid;
+};
+
+static NotifyFunction notifyFunction;
+
+void MTRegisterNotify(NotifyFunction f)
+{
+  assert(notifyFunction == 0);
+  notifyFunction = f;
+}
+
+static void nukeother(struct other o)
+{
+  int from, to;
+  TRACE(8, ("Nuking %x.%x (%d)\n", o.id.ipaddress, o.id.port, o.s));
+  for (from = 0, to = 0; from < nothers; from++) {
+    if (others[from].s == o.s) {
+      TRACE(8, ("  Nuking %x.%x (%d)\n", others[from].id.ipaddress, others[from].id.port, others[from].s));
+      /* don't do this one */
+    } else {
+      if (from != to) {
+	others[to++] = others[from];
+      } else {
+	to++;
+      }
+    }
+  }
+  TRACE(7, ("Nothers went from %d to %d\n", nothers, to));
+  nothers = to;
+  cache.id.ipaddress = cache.id.port = cache.s = 0;
+}
+
+int findsocket(NodeAddr *t)
+{
+  int i, addrlen, s;
+  struct sockaddr_in addr;
+  struct other *o, localcopy;
+  struct nbo nbo;
+
+  TRACE(7, ("in find socket for %#x.%4x\n", t->ipaddress, t->port));
+  if (cache.id.ipaddress == t->ipaddress && cache.id.port == t->port && cache.s) {
+    TRACE(8, ("find socket returning %d from cache\n", cache.s));
+    return cache.s;
+  }
+  for (i = 0; i < nothers; i++) {
+    TRACE(9, ("  Looking at %#x.%4x\n", others[i].id.ipaddress, others[i].id.port));
+    if (others[i].id.ipaddress == t->ipaddress && others[i].id.port == t->port) {
+      cache = others[i];
+      TRACE(8, ("find socket returning %d\n", cache.s));
+      return cache.s;
+    }
+  }
+#if defined(WIN32) && defined(SO_SYNCHRONOUS_NONALERT)
+  {
+    int optionValue = SO_SYNCHRONOUS_NONALERT;
+    int err;
+    err = setsockopt(INVALID_SOCKET,
+		     SOL_SOCKET,
+		     SO_OPENTYPE,
+		     (char *)&optionValue,
+		     sizeof(optionValue));
+    if (err != NO_ERROR) {
+      printf("setsockopt: OPENTYPE failed with %d\n", err);
+      abort();
+    }
+  }
+#endif
+  if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) return -1;
+  memset(&addr, 0, sizeof(addr));
+  addr.sin_family = AF_INET;
+  addr.sin_port = htons(0);
+  addr.sin_addr.s_addr = 0;
+  if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+    perror("findsocket.bind");
+    close(s);
+    return -1;
+  }
+  memset(&addr, 0, sizeof(addr));
+  addr.sin_family = AF_INET;
+  addr.sin_port = htons(t->port);
+  addr.sin_addr.s_addr = t->ipaddress;
+  addrlen = sizeof(addr);
+  TRACE(3, ("Trying to connect to %08lx.%04x\n", addr.sin_addr.s_addr, ntohs(addr.sin_port)));
+  if (connect(s, (struct sockaddr *)&addr, addrlen) < 0) {
+#ifdef MTDEBUG
+    if (MTdebuglevel >= 3) perror("findsocket.connect");
+#endif
+    close(s);
+    return -1;
+  }
+  {
+    int on = 1;
+    if (setsockopt(s, IPPROTO_TCP, TCP_NODELAY, (char *)&on, sizeof (on)) < 0) {
+      close(s);
+      perror("setsockopt");
+      return -1;
+    }
+  }
+
+  localcopy.id = *t;
+  localcopy.s = s;
+  TRACE(9, ("Inserting %#x.%d -> %d in others\n", t->ipaddress, t->port, localcopy.s));
+  others[nothers++] = localcopy;
+  {
+    nbo.ipaddress = myid.ipaddress;
+    nbo.port = htons(myid.port);
+    nbo.incarnation = htons(myid.incarnation);
+    nbo.userid = htonl(getuid());
+    if (writeToSocketN(localcopy.s, &nbo, sizeof(nbo)) != sizeof(nbo) ||
+	readFromSocketN(localcopy.s, &nbo, sizeof(nbo)) != sizeof(nbo)) {
+      TRACE(0, ("Couldn't exchange incarnation info\n"));
+      close(localcopy.s);
+      nothers--;
+      return -1;
+    } else if(checkSameUser && getuid() != ntohl(nbo.userid)) {
+      fprintf(stderr, "Permission denied - user mismatch local %d != remote %d\n", (int)getuid(), ntohl(nbo.userid));
+      close(localcopy.s);
+      nothers--;
+      return -1;
+    }
+    localcopy.id.ipaddress = nbo.ipaddress;
+    localcopy.id.incarnation = ntohs(nbo.incarnation);
+    assert(localcopy.id.port == ntohs(nbo.port));
+    *t = localcopy.id;
+  }
+  o = (struct other *)malloc(sizeof *o);
+  *o = localcopy;
+  setupReader(o);
+  TRACE(8, ("find socket returning new %d\n", localcopy.s));
+  cache = localcopy;
+  return cache.s;
+}
+
+static void callNotifyFunction(NodeAddr id, int comingup)
+{
+  notifyFunction(id, comingup);
+}
+
+typedef struct ReaderState {
+  struct other *ri;
+  readBuffer rb;
+  int readingLength, length;
+} ReaderState;
+
+static void ReaderCB(int sock, EDirection d, void *state)
+{
+  ReaderState *rs = state;
+  int res;
+  void *buffer = 0;
+
+  if (!(res = tryReading(&rs->rb, sock))) return;
+  if (res < 0 || res != rs->rb.goal) {
+    /*
+     * Give up on this socket.
+     */
+    resetHandler(sock, EIO_Read);
+    resetHandler(sock, EIO_Except);
+    close(sock);
+    if (notifyFunction) notifyFunction(rs->ri->id, 0);
+    nukeother(*rs->ri);
+    free(rs->ri);
+    free(rs);
+  } else if (rs->readingLength) {
+    rs->length = ntohl(rs->length);
+    rs->readingLength = 0;
+    if (rs->length > 0) {
+      buffer = malloc(rs->length);
+      setupReadBuffer(&rs->rb, buffer, rs->length, 0, readFromSocket);
+    } else {
+      TRACE(0, ("Negative length %d\n", rs->length));
+    }
+  } else {
+    assert(ntohl(*(int *)rs->rb.buffer) == 0xdeafdeaf);
+    MQueueInsert(incoming, rs->ri->id, rs->length, rs->rb.buffer);
+    setupReadBuffer(&rs->rb, &rs->length, sizeof(rs->length), 0, readFromSocket);
+    rs->readingLength = 1;
+  }
+}
+
+static void setupReader(struct other *ri)
+{
+  ReaderState *rs = (ReaderState *)malloc(sizeof(*rs));
+  rs->ri = ri;
+  rs->readingLength = 1;
+  setupReadBuffer(&rs->rb, &rs->length, sizeof(rs->length), 0, readFromSocket);
+  setHandler(rs->ri->s, ReaderCB, EIO_Read, rs);
+  setHandler(rs->ri->s, ReaderCB, EIO_Except, rs);
+}
+
+void showIncoming(void)
+{
+  MQueuePrint(incoming);
+}
+
+typedef struct {
+  struct other *ri;
+  struct nbo nbo;
+  readBuffer rb;
+} ListenerState;
+  
+static int checkUserOK(int local, int remote)
+{
+  if (checkSameUser && local != remote) {
+      fprintf(stderr, "Permission denied - user mismatch local %d != remote %d\n",
+	      local, remote);
+      return 0;
+  } else {
+    return 1;
+  }
+}
+
+static void ListenerStage2(int sock, EDirection d, void *arg)
+{
+  int res;
+  ListenerState *ls = arg;
+  if (!(res = tryReading(&ls->rb, ls->ri->s))) return;
+  resetHandler(sock, EIO_Read);
+  resetHandler(sock, EIO_Except);
+  if (res != sizeof(ls->nbo) || !checkUserOK(getuid(), ntohl(ls->nbo.userid))) {
+    nukeother(*ls->ri);
+    close(ls->ri->s);
+    free(ls->ri);
+  } else {
+    ls->ri->id.port = ntohs(ls->nbo.port);
+    ls->ri->id.ipaddress = ls->nbo.ipaddress;
+    ls->ri->id.incarnation = ntohs(ls->nbo.incarnation);
+    TRACE(8, ("Inserting %#x.%4x.%4x -> %d in others\n", ls->ri->id.ipaddress, ls->ri->id.port, ls->ri->id.incarnation, ls->ri->s));
+    others[nothers++] = *ls->ri;
+    setupReader(ls->ri);
+    if (notifyFunction) callNotifyFunction(ls->ri->id, 1);
+  }
+  vmFree((char *)ls);
+}
+
+static void ListenerCB(int sock, EDirection d, void *s)
+{
+  int newsocket;
+  struct sockaddr_in addr;
+  int addrlen = sizeof(addr), on = 1;
+  ListenerState *ls = (ListenerState *)malloc(sizeof(*ls));
+
+  newsocket = accept(sock, (struct sockaddr *)&addr, &addrlen);
+  if (newsocket < 0) return;
+  if (setsockopt(newsocket, IPPROTO_TCP, TCP_NODELAY, (char *)&on, sizeof (on)) < 0) {
+    close(newsocket);
+    perror("setsockopt");
+    return;
+  }
+  ls->ri = (struct other *)malloc(sizeof *ls->ri);
+  ls->ri->s = newsocket;
+  ls->ri->id.ipaddress = addr.sin_addr.s_addr;
+  ls->ri->id.port = ntohs(addr.sin_port);
+
+  TRACE(8, ("Inserting %#x.%x -> %d in others\n", ls->ri->id.ipaddress, ls->ri->id.port, ls->ri->s));
+  others[nothers++] = *ls->ri;
+  ls->nbo.ipaddress = myid.ipaddress;
+  ls->nbo.port = htons(myid.port);
+  ls->nbo.incarnation = htons(myid.incarnation);
+  ls->nbo.userid = htonl(getuid());
+  if (send(ls->ri->s, (char *)&ls->nbo, sizeof(ls->nbo), 0) != sizeof(ls->nbo)) {
+    nukeother(*ls->ri);
+    close(ls->ri->s);
+    free(ls->ri);
+    return;
+  }
+  setupReadBuffer(&ls->rb, &ls->nbo, sizeof(ls->nbo), 0, readFromSocket);
+  setHandler(ls->ri->s, ListenerStage2, EIO_Read, ls);
+  setHandler(ls->ri->s, ListenerStage2, EIO_Except, ls);
+}
+
+static void setupListener(int sock)
+{
+  setHandler(sock, ListenerCB, EIO_Read, NULL);
+}
+
+int MTNetStart(unsigned int ipaddress, unsigned short port, unsigned short incarnation)
+{
+  struct sockaddr_in addr;
+  int addrlen, on = 1;
+  char hostname[128];
+#ifdef alpha
+#pragma pointer_size long
+#endif
+  struct hostent *h;
+#ifdef alpha
+#pragma pointer_size short
+#endif
+
+  assert(myid.ipaddress == 0 && myid.port == 0 && myid.incarnation == 0);
+  if ((mysocket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+    return -1;
+  }
+  memset(&addr, 0, sizeof(addr));
+  addr.sin_family = AF_INET;
+  addr.sin_port = htons(port);
+  addr.sin_addr.s_addr = ipaddress;
+  if (bind(mysocket, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+    close(mysocket);
+    return -1;
+  }
+  addrlen = sizeof(addr);
+  if (getsockname(mysocket, (struct sockaddr *)&addr, &addrlen) < 0) {
+    close(mysocket);
+    return -1;
+  }
+  TRACE(3, ("NetStart on %#lx.%d\n", addr.sin_addr.s_addr, ntohs(addr.sin_port)));
+  if (listen(mysocket, 5) < 0) {
+    close(mysocket);
+    return -1;
+  }
+  if (setsockopt(mysocket, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof (on)) < 0) {
+    close(mysocket);
+    perror("setsockopt");
+    return -1;
+  }
+  /*
+   * Originally we did this all the time on not windows
+   */
+  if (addr.sin_addr.s_addr == 0) {
+    if (gethostname(hostname, sizeof hostname) < 0) {
+      TRACE(1, ("Can't get my own host name\n"));
+      close(mysocket);
+      return -1;
+    }
+    /* A Hack */
+    if ((h = gethostbyname(hostname)) == 0) {
+      printf("Can't look up my own host name\n");
+      strcpy(hostname, "hutchinson2.home.cs.ubc.ca");
+      if ((h = gethostbyname(hostname)) == 0) {
+		printf("Still can't look up my own host name\n");
+	
+	close(mysocket);
+	return -1;
+      }
+    }
+    memcpy(&addr.sin_addr.s_addr, h->h_addr, sizeof(unsigned int));
+  }
+  myid.ipaddress = addr.sin_addr.s_addr;
+  myid.port = ntohs(addr.sin_port);
+  myid.incarnation = incarnation;
+  TRACE(2, ("Net start on %04x.%04x.%04x\n", myid.ipaddress, myid.port, myid.incarnation));
+  setupListener(mysocket);
+  return 0;
+}
+
+int MTReceive(NodeAddr *senderid, void **rbuf, int *rlen)
+{
+  TRACE(1, ("MTReceive called\n"));
+  MQueueRemove(incoming, senderid, rlen, rbuf);
+  TRACE(2, ("MTReceive returning %d\n", *rlen));
+  return 1;
+}
+
+int MTProd(NodeAddr *receiver)
+{
+  int s = findsocket(receiver);
+  return s;
+}
+
+int MTSend(NodeAddr receiver, void *sbuf, int slen)
+{
+  unsigned int length;
+  int s = findsocket(&receiver), res;
+  extern char *NodeAddrString(NodeAddr);
+  extern int nMessagesSent, nBytesSent;
+
+  nMessagesSent++;
+  nBytesSent += slen;
+
+  TRACE(3, ("Send\n"));
+
+  length = htonl(slen);
+  res = MTwrite2(s, &length, sizeof(length), sbuf, slen);
+  if (res != sizeof(length) + slen) {
+    perror("  mtsend");
+    printf("MTSend to %s, socket %d, for %d bytes returned %d\n",
+	   NodeAddrString(receiver), s, slen + sizeof(length), res);
+    return -1;
+  }
+  TRACE(3, ("Send returning\n"));
+  return 1;
+}
+
+void MTSetDebugLevel(int x)
+{
+#if defined(MTDEBUG)
+  MTdebuglevel = x;
+#endif
+}
+void MTInit()
+{
+#if defined(__svr4__) || defined(__SYSTYPE_SVR4__)
+  struct sigaction action;
+
+  memset(&action, 0, sizeof(action));
+  action.sa_handler = intrHandler;
+  sigaction(SIGINT, &action, NULL);
+  action.sa_handler = pipeHandler;
+  sigaction(SIGPIPE, &action, NULL);
+#else
+  struct sigvec vec;
+  memset(&vec, 0, sizeof(vec));
+
+  vec.sv_handler = intrHandler;
+  SIGVEC(SIGINT, &vec, NULL);
+  vec.sv_handler = pipeHandler;
+  SIGVEC(SIGPIPE, &vec, NULL);
+#endif
+  incoming = MQueueCreate();
+  deferred = MQueueCreate();
+}
+
+#ifdef WIN32
+void perror(const char *msg)
+{
+  printf("%s: %d\n", msg, errno);
+  fflush(stdout);
+}
+#endif /* WIN32 */
+
+void processBoringMessages(void)
+{
+  while (MQueueSize(incoming) == 0) {
+    checkForIO(1);
+  }
+  serveRequest();
+}
+
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/mthreads.h ubc-1.05alpha-src/vm/src/mthreads.h
--- sourceforge-1.06alpha/vm/src/mthreads.h	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/mthreads.h	2017-12-11 17:59:03.427711909 +0100
@@ -0,0 +1,40 @@
+#ifndef _EMERALD_MTHREADS_H
+#define _EMERALD_MTHREADS_H
+#pragma warning(disable: 4068)
+#pragma pointer_size save
+#pragma pointer_size long
+#include <sys/types.h>
+
+#ifndef WIN32
+#include <sys/time.h>
+#include <stdarg.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#endif
+#pragma pointer_size restore
+
+#ifdef WIN32
+#ifdef MSVC40
+#include <winsock.h>
+#else
+#include <winsock2.h>
+#endif
+#endif
+
+typedef struct NodeAddr {
+  unsigned int ipaddress;
+  unsigned short port;
+  unsigned short incarnation;
+} NodeAddr;
+
+extern void MTInit(void);
+void MTStart(void);
+
+void MTRegisterExitRoutine(void (*)(void));
+
+int MTNetStart(unsigned int, unsigned short, unsigned short);
+int MTSend(NodeAddr receiver, void *sbuf, int slen);
+int MTProd(NodeAddr *receiver);
+typedef void (*NotifyFunction)(NodeAddr id, int isup);
+void MTRegisterNotify(NotifyFunction);
+#endif /* _EMERALD_MTHREADS_H */
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/ntoh.h ubc-1.05alpha-src/vm/src/ntoh.h
--- sourceforge-1.06alpha/vm/src/ntoh.h	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/ntoh.h	2017-12-11 17:59:03.427711909 +0100
@@ -0,0 +1,15 @@
+#ifndef _EMERALD_NTOH_H
+#define _EMERALD_NTOH_H
+#ifdef WIN32
+/*
+ * For some reason ntoh is in some standard place in WIN32.  I don't know why?
+ */
+#else
+#include <types.h>
+#include <netinet/in.h>
+#ifdef sgi
+#include <endian.h>
+#endif
+#endif
+
+#endif /* _EMERALD_NTOH_H */
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/remote.c ubc-1.05alpha-src/vm/src/remote.c
--- sourceforge-1.06alpha/vm/src/remote.c	2017-12-11 17:59:03.091714470 +0100
+++ ubc-1.05alpha-src/vm/src/remote.c	2017-12-11 17:59:03.428711901 +0100
@@ -367,8 +345,7 @@
   stack[1] = (int)ctdg;
   rootdir = CreateObjectFromOutside(ctd, (u32)stack);
   if (doDistribution) {
-    fprintf(stdout,"Emerald listening on port %d %x, epoch %d %x\n", myid.port, myid.port, myid.epoch, myid.epoch);
-    fflush(stdout);
+    printf("Emerald listening on port %d %x, epoch %d %x\n", myid.port, myid.port, myid.epoch, myid.epoch);
   }
 #endif
 
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/sisc.c ubc-1.05alpha-src/vm/src/sisc.c
--- sourceforge-1.06alpha/vm/src/sisc.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/sisc.c	2017-12-11 17:59:03.428711901 +0100
@@ -0,0 +1,273 @@
+/*
+ * Searchable Collections:
+ *
+ * Expanding hash tables with a key and data.
+ */
+
+#include "system.h"
+
+#include "assert.h"
+#include "sisc.h"
+
+static int sizes[] = {
+  5, 7, 17, 31,
+  67, 131, 257, 521,
+  1031, 2053, 4099, 8093,
+  16193, 32377, 65557, 131071,
+  262187, 524869, 1048829, 2097223,
+  4194371, 8388697, 16777291 };
+#define MAXFILL(x) (((x) * 17) / 20)
+
+/*
+ * Turning this on will cause the package to self-check on every (modifying)
+ * operation.  The package runs very slowly when this is enabled.
+ */
+#undef DEBUGSC
+
+static unsigned stringintHash(unsigned char *);
+
+#define Hash(key, sc) (HASH(key) % sc->size)
+
+#ifdef DEBUGSC
+static void CheckOutHashTable();
+#define CHECKOUTHASHTABLE(sc) CheckOutHashTable(sc)
+#else
+#define CHECKOUTHASHTABLE(sc) 
+#endif
+
+/* Return a new, empty SISc */
+SISc SIScCreate()
+{
+  register int i;
+  register SISc sc;
+
+  sc = (SISc) vmMalloc(sizeof(SIScRecord));
+  sc->size = sizes[0];
+  sc->maxCount = MAXFILL(sc->size);
+  sc->count = 0;
+  sc->table = (SIScTEPtr) vmMalloc((unsigned) sc->size * sizeof(SIScTE));
+  for (i = 0; i < sc->size; i++) {
+    sc->table[i].key = NULL;
+  }
+  CHECKOUTHASHTABLE(sc);
+  return sc;
+}
+
+void SIScDestroy(sc)
+register SISc sc;
+{
+  vmFree((char *)sc->table);
+  vmFree((char *)sc);
+}
+
+/* Expand the hash table.  Each element in the table is re-hashed and entered 
+ * in the new table. */
+static void ExpandHashTable(SISc sc)
+{
+  register SIScTE *nh, *oe, *ne;
+  register int oldHashTableSize = sc->size, i;
+  register DomainType key;
+  int index;
+
+  for (i = 0; sizes[i] <= oldHashTableSize; i++) ;
+  sc->size = sizes[i];
+  sc->maxCount = MAXFILL(sc->size);
+  nh = (SIScTEPtr) vmMalloc((unsigned)(sc->size * sizeof(SIScTE)));
+  for (i = 0; i < sc->size; i++) nh[i].key = NULL;
+  for (i = 0; i < oldHashTableSize; i++) {
+    oe = &sc->table[i];
+    key = oe->key;
+    if (key == NULL) continue;
+    index = Hash((unsigned char *)key, sc);
+    while (1) {
+      ne = &nh[index];
+      if (ne->key == NULL) {
+	ne->key = oe->key;
+	ne->value = oe->value;
+	break;
+      } else {
+	assert(ne->key !=key);
+	index++;
+	if (index >= sc->size) index = 0;
+      }
+    }
+  }
+  vmFree((char *)sc->table);
+  sc->table = nh;
+  CHECKOUTHASHTABLE(sc);
+}
+
+/* Return the value associated with key in collection sc, or SIScNIL */
+RangeType SIScLookup(sc, key)
+register SISc sc;
+register DomainType  key;
+{
+  register int index = Hash((unsigned char *)key, sc);
+  register SIScTEPtr e;
+
+  CHECKOUTHASHTABLE(sc);
+  while (1) {
+    e = &sc->table[index];
+    if (e->key == NULL) {               /* we did not find it */
+      return SIScNIL;
+    } else if (COMPARE(e->key, key)) {
+      return e->value;
+    }
+    if (++index >= sc->size) index = 0;
+  }
+}
+
+/* Insert the key, value pair in sc.  If the key already exists, change its 
+ * value. */
+void SIScInsert(sc, key, value)
+register SISc sc;
+register DomainType key;
+RangeType value;
+{
+  register int index;
+  register SIScTEPtr e;
+
+  if (sc->count >= sc->maxCount) ExpandHashTable(sc);
+  index = Hash((unsigned char *)key, sc);
+  while (1) {
+    e = &sc->table[index];
+    if (e->key == NULL) {               /* put it here */
+      e->key = key;
+      e->value = value;
+      sc->count++;
+      CHECKOUTHASHTABLE(sc);
+      return;
+    } else if (COMPARE(e->key, key)) {
+      e->value = value;
+      CHECKOUTHASHTABLE(sc);
+      return;
+    }
+    if (++index >= sc->size) index = 0;
+  }
+}
+
+/* Remove the entry, if it is there */
+void SIScDelete(sc, key)
+register SISc sc;
+register DomainType key;
+{
+  register int index = Hash((unsigned char *)key, sc);
+  register RangeType value;
+  register SIScTEPtr e;
+
+  while (1) {
+    e = &sc->table[index];
+    if (e->key == NULL) {               /* we did not find it */
+      CHECKOUTHASHTABLE(sc);
+      return;
+    }
+    if (COMPARE(e->key, key)) {
+      /* Found it, now remove it */
+      sc->count--;
+      e->key = NULL;
+      e->value = (int)NULL;
+      while (1) {
+	/* rehash until we reach nil again */
+	if (++index >= sc->size) index = 0;
+	e = & sc->table[index];
+	key = e->key;
+	if (key == NULL) {
+	  CHECKOUTHASHTABLE(sc);
+	  return;
+	}
+	/* rehashing is done by removing then reinserting */
+	value = e->value;
+	e->key = NULL;
+	e->value = (int)NULL;
+	sc->count--;
+	SIScInsert(sc, key, value);
+      }
+    }
+    if (++index >= sc->size) index = 0;
+  }
+}
+
+/* DEBUGGING: Print the sc */
+void SIScPrint(sc)
+register SISc sc;
+{
+  DomainType key;
+  RangeType value;
+  int index;
+
+  printf(
+    "\nDump of sc @ 0x%05x, %d entr%s, current max %d\nIndex\tKey\t\tValue\n",
+    (int)sc, sc->count, sc->count == 1 ? "y" : "ies",  sc->maxCount);
+  for (index = 0; index < sc->size; index++) {
+    key = sc->table[index].key;
+    value = sc->table[index].value;
+    printf("%3d\t%-16.16s0x%08x\n", index, key, value);
+  }
+}
+
+#ifdef DEBUGSC
+/* Make sure that the hash table is internally consistent:
+ *      every key is findable, 
+ *      count reflects the number of elements
+ */
+static void CheckOutHashTable(sc)
+register SISc sc;
+{
+  register int i;
+  register SIScTEPtr realElement, e;
+  register int index, firstIndex, count;
+  count = 0;
+
+  for (i = 0; i < sc->size; i++) {
+    realElement = &sc->table[i];
+    if (realElement->key != NULL) {
+      count++;
+      index = Hash((unsigned char *)realElement->key, sc);
+      firstIndex = index;
+      while (1) {
+	e = &sc->table[index];
+	if (e->key == NULL) {           /* we did not find it */
+	  break;
+	} else if (COMPARE(e->key, realElement->key)) {
+	  break;
+	} else {
+	  index++;
+	  if (index >= sc->size) index = 0;
+	  if (index == firstIndex) {
+	    index = -1;
+	    break;
+	  }
+	}
+      }
+      
+      if (index == -1 || !COMPARE(e->key, realElement->key)) {
+	/* FIX THIS */
+	fprintf(stderr,
+	  "Sc problem: Key %s, rightIndex %d, realIndex %d value 0x%x\n",
+	  realElement->key, firstIndex, index, realElement->value);
+	SIScPrint(sc);
+      }
+    }
+  }  
+  if (count != sc->count) {
+    fprintf(stderr,
+      "Sc problem: Should have %d entries, but found %d.\n", sc->count,
+      count);
+    SIScPrint(sc);
+  }
+}
+#endif
+/* String hashing function, from Red Dragon Book */
+
+static unsigned stringintHash(unsigned char *key)
+{
+  register unsigned h = 0, g;
+  for (; *key; key++) {
+    h =  (h << 4) + (*key);
+    if ((g = h & 0xf0000000)) {
+      h = h ^ (g >> 24);
+      h = h ^ g;
+    }
+  }
+  return h;
+}
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/sisc.h ubc-1.05alpha-src/vm/src/sisc.h
--- sourceforge-1.06alpha/vm/src/sisc.h	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/sisc.h	2017-12-11 17:59:03.428711901 +0100
@@ -0,0 +1,94 @@
+/* 
+ * SIScs (searchable collections) are things that map 
+ * elements of some domain onto some range.  Operations:
+ *	create, destroy, insert, lookup, size, and print
+ */
+
+#ifndef _EMERALD_SISC_H
+#define _EMERALD_SISC_H
+/*
+ * Before using this, one must define the following:
+ *	DomainType	- a typedef for the domain
+ *	RangeType	- a typedef for the range
+ *	HASH		- a macro that computes an integer from a given
+ *			  element of the domain
+ *	COMPARE		- a macro that compares two elements of the domain,
+ *			  evaluating to 1 if they are the same
+ */
+typedef char *DomainType;
+typedef int   RangeType;
+
+#define COMPARE(A, B) (!strcmp((A), (B)))
+
+#define HASH(key) stringintHash((unsigned char *)key)
+#define SIScNIL (-1)
+#define SIScIsNIL(x) (((int)x) == SIScNIL)
+
+/*
+ * Hidden, private type declarations.  The only thing
+ * that applications of this package are to see is SISc,
+ * and they are to treat it as opaque:  that is, they may
+ * assign it, and pass it as arguments, but not manipulate
+ * what it points to directly.
+ */
+
+typedef struct SIScTE {
+    DomainType	 key;		/* the key for this entry */
+    RangeType	 value;		/* what we want */
+} SIScTE, *SIScTEPtr;
+
+typedef struct SIScRecord {
+    SIScTEPtr table;
+    int size, maxCount, count;
+} SIScRecord, *SISc;
+
+/* OPERATIONS */
+
+/* Return a new, empty Searchable Collection */
+SISc SIScCreate(void);
+
+/* Destroy a collection */
+void SIScDestroy(SISc sc);
+
+/* Insert the pair <key, value> into collection SISc */
+void SIScInsert(SISc sc, DomainType key, RangeType value);
+
+/* Delete the pair with key key from the collection SISc */
+void SIScDelete(SISc sc, DomainType key);
+
+/* Return the value associated with key in collection 
+ * SISc, or 0 if no such pair exists */
+int SIScLookup(SISc sc, DomainType key);
+
+/* DEBUGGING: Print the collection SISc */
+void SIScPrint(SISc sc);
+
+/* Iterate over the elements of the collection SISc.  
+ * At each iteration, SISckey and SIScvalue are set to the next
+ * <key, value> pair in the collection.  
+ * Usage:
+ *	SIScForEach(someSc, key, value) {
+ *	  / * whatever you want to do with key, value * /
+ *	} SIScNext();
+ */
+#define SIScForEach(SISc, SISckey, SIScvalue) \
+  { \
+    int SIScxx_index; \
+    for (SIScxx_index = 0; SIScxx_index < (SISc)->size; SIScxx_index++) { \
+      if ((SISc)->table[SIScxx_index].key != NULL) { \
+	(SISckey) = SISc->table[SIScxx_index].key; \
+	*(RangeType *)(&(SIScvalue)) = SISc->table[SIScxx_index].value; \
+	{ 
+
+#define SIScNext() \
+	} \
+      } \
+    } \
+  }
+
+/* Return the number of elements in SISc */
+#define SIScSize(SISc) ((SISc)->count)
+
+#include "storage.h"
+
+#endif /* _EMERALD_SISC_H */
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/sockstr.c ubc-1.05alpha-src/vm/src/sockstr.c
--- sourceforge-1.06alpha/vm/src/sockstr.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/sockstr.c	2017-12-11 17:59:03.428711901 +0100
@@ -0,0 +1,221 @@
+/****************************************************************************
+ File     : socketstreams.c 
+ Date     : 08-11-92
+ Author   : Mark Immel
+
+ Contents : Socket Streams package
+
+ Modifications
+ -------------
+
+*****************************************************************************/
+
+#include <stddef.h>
+#ifdef WIN32
+#include <io.h>
+#else /* not WIN32 */
+#include <sys/file.h>
+#endif /* not WIN32 */
+#include <sys/stat.h>
+#ifndef WIN32
+#include <sys/socket.h>
+#endif
+#include "sockstr.h"
+#include "error.h"
+#include "memory.h"
+#include "misc.h"
+#include "assert.h"
+
+/*
+ * NOTE: The code in this file assumes that sizeof(int) <= sizeof(void *).
+ *       The Hook pointer is used to store a file descriptor.  If this is
+ *       inappropriate, set the Hook pointer to point to the file descriptor.
+ */
+
+#define READSOCKETBUFFERSIZE  4096
+#define WRITESOCKETBUFFERSIZE 4096
+
+static struct StreamConstructor ReadSocketStreamConstructor;
+static struct StreamConstructor WriteSocketStreamConstructor;
+
+StreamConstructor ReadSocketStream = &ReadSocketStreamConstructor;
+StreamConstructor WriteSocketStream = &WriteSocketStreamConstructor;
+
+static int  CreateReadSocketStream(StreamBuffer theBuffer, void **Hook);
+static int  FillReadSocketStream(StreamBuffer theBuffer, void **Hook);
+static int  DestroyReadSocketStream(StreamBuffer theBuffer, void **Hook);
+
+static int  CreateWriteSocketStream(StreamBuffer theBuffer, void **Hook);
+static int  FlushWriteSocketStream(StreamBuffer theBuffer, void **Hook);
+static int  DestroyWriteSocketStream(StreamBuffer theBuffer, void **Hook);
+
+static struct StreamConstructor ReadSocketStreamConstructor = {
+  Read,
+  CreateReadSocketStream,
+  FillReadSocketStream,
+  DestroyReadSocketStream,
+  NULL };
+
+static struct StreamConstructor WriteSocketStreamConstructor = {
+  Write,
+  CreateWriteSocketStream,
+  FlushWriteSocketStream,
+  DestroyWriteSocketStream,
+  NULL }; 
+
+static StreamBuffer BufferCache[MAX_FILE_DESCRIPTORS];
+
+/*
+ * Initialize a new ReadSocketStream
+ *
+ * Hook should point to the file descriptor of the socket.
+ * This function then resets Hook to contain the file descriptor.
+ */
+
+static int
+CreateReadSocketStream(StreamBuffer theBuffer, void **Hook)
+{
+  int   fd;
+
+  assert(sizeof(int) <= sizeof(void *)); /* Make sure it's OK to store
+					    fd in *Hook */
+
+  fd = *((int *) *Hook);
+  *((int *) Hook) = fd;
+
+  theBuffer->Start = (StreamByte *) vmMalloc(READSOCKETBUFFERSIZE);
+  theBuffer->End = theBuffer->Start + READSOCKETBUFFERSIZE;
+  theBuffer->Head = theBuffer->Start;
+  theBuffer->ValidBytes = 0;
+
+  BufferCache[fd] = theBuffer;
+  RegisterFD(fd, ProcessNewSocketData);
+  return 0;
+}
+
+/*
+ * Fill the file buffer
+ */
+
+#ifdef WIN32
+#define read _read
+#define close _close
+#define write _write
+#endif
+
+static int
+FillReadSocketStream(StreamBuffer theBuffer, void **Hook)
+{
+  int fd, BytesRead;
+
+  fd = *((int *) Hook);
+
+  BytesRead = read(fd, theBuffer->Start + theBuffer->ValidBytes,
+		   theBuffer->End - theBuffer->Start - theBuffer->ValidBytes);
+
+  if (BytesRead < 0) {
+#ifndef WIN32
+    if (errno == EWOULDBLOCK)
+      return 0;
+    else
+#endif /* not WIN32 */
+      FatalError("FillReadSocketStream ");
+  }
+  
+  if (BytesRead == 0)
+    theBuffer->AtEOF = 1;
+
+  return BytesRead;
+}
+
+/*
+ * Destroy the ReadSocketStream 
+ */
+
+static int
+DestroyReadSocketStream(StreamBuffer theBuffer, void **Hook)
+{
+  int fd;
+
+  fd = *((int *) Hook);
+
+  UnRegisterFD(fd);
+  if (close(fd) < 0) 
+    FatalError("DestroyReadSocketStream ");
+
+  if (theBuffer->Start)
+    vmFree(theBuffer->Start);
+  return 0;
+}
+
+/*
+ * Initialize a new WriteSocketStream
+ *
+ * Hook should point to a char * containing the name of the file to open.
+ * This function then resets Hook to contain the file descriptor.
+ */
+
+static int
+CreateWriteSocketStream(StreamBuffer theBuffer, void **Hook)
+{
+  int   fd;
+
+  assert(sizeof(int) <= sizeof(void *)); /* Make sure it's OK to store
+					    fd in *Hook */
+
+  fd = *((int *) *Hook);
+  *((int *) Hook) = fd;
+
+  theBuffer->Start = (StreamByte *) vmMalloc(WRITESOCKETBUFFERSIZE);
+  theBuffer->End = theBuffer->Start + WRITESOCKETBUFFERSIZE;
+  theBuffer->Head = theBuffer->Start;
+  theBuffer->ValidBytes = 0;
+  return 0;
+}
+
+/*
+ * Flush the file buffer
+ */
+
+static int
+FlushWriteSocketStream(StreamBuffer theBuffer, void **Hook)
+{
+  int fd, BytesWritten;
+
+  fd = *((int *) Hook);
+
+  BytesWritten = write(fd, theBuffer->Start, theBuffer->ValidBytes);
+
+  if (BytesWritten < 0)
+    FatalError("FlushWriteSocketStream ");
+
+  assert(BytesWritten == theBuffer->ValidBytes);
+
+  return BytesWritten;
+}
+
+/*
+ * Destroy the WriteSocketStream 
+ */
+
+static int
+DestroyWriteSocketStream(StreamBuffer theBuffer, void **Hook)
+{
+  if (theBuffer->Start)
+    vmFree(theBuffer->Start);
+  return 0;
+}
+
+/*
+ * Deal with new data arriving on a socket.
+ */
+
+void ProcessNewSocketData(Socket theSocket) 
+{
+  int BytesRead;
+
+  BytesRead = FillReadSocketStream(BufferCache[theSocket], (void**)&theSocket);
+  BufferCache[theSocket]->ValidBytes += BytesRead;
+
+  ActivateFD(theSocket);
+}
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/sockstr.h ubc-1.05alpha-src/vm/src/sockstr.h
--- sourceforge-1.06alpha/vm/src/sockstr.h	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/sockstr.h	2017-12-11 17:59:03.428711901 +0100
@@ -0,0 +1,32 @@
+/****************************************************************************
+ File     : socketstreams.h 
+ Date     : 08-11-92
+ Author   : Mark Immel
+
+ Contents : Socket Streams package
+
+ Modifications
+ -------------
+
+*****************************************************************************/
+
+#ifndef _EMERALD_SOCKETSTREAMS_H
+#define _EMERALD_SOCKETSTREAMS_H
+
+/*
+  This module provides a stream implementation for sockets.
+
+  The Hook argument to CreateStream should be the address of a integer
+  containing the file descriptor associated with the socket to be used.
+
+  All sockets given to these routines should be marked non-blocking.
+*/
+
+#include "streams.h"
+#include "types.h"
+
+extern StreamConstructor ReadSocketStream;
+extern StreamConstructor WriteSocketStream;
+extern void              ProcessNewSocketData(Socket theSocket);
+
+#endif /* _EMERALD_SOCKESTREAMS_H */
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/strtol.c ubc-1.05alpha-src/vm/src/strtol.c
--- sourceforge-1.06alpha/vm/src/strtol.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/strtol.c	2017-12-11 17:59:03.429711894 +0100
@@ -0,0 +1,57 @@
+#if !defined(lint) && defined(SCCSIDS)
+static	char sccsid[] = "@(#)strtol.c 1.4 88/02/08 SMI"; /* from S5R2 2.1 */
+#endif
+
+/*LINTLIBRARY*/
+#include <ctype.h>
+#define DIGIT(x)	(isdigit(x) ? (x) - '0' : \
+			islower(x) ? (x) + 10 - 'a' : (x) + 10 - 'A')
+#define MBASE	('z' - 'a' + 1 + 10)
+
+long
+strtol(str, ptr, base)
+register char *str;
+char **ptr;
+register int base;
+{
+	register long val;
+	register int c;
+	int xx, neg = 0;
+
+	if (ptr != (char **)0)
+		*ptr = str; /* in case no number is formed */
+	if (base < 0 || base > MBASE)
+		return (0); /* base is invalid -- should be a fatal error */
+	if (!isalnum(c = *str)) {
+		while (isspace(c))
+			c = *++str;
+		switch (c) {
+		case '-':
+			neg++;
+		case '+': /* fall-through */
+			c = *++str;
+		}
+	}
+	if (base == 0)
+		if (c != '0')
+			base = 10;
+		else if (str[1] == 'x' || str[1] == 'X')
+			base = 16;
+		else
+			base = 8;
+	/*
+	 * for any base > 10, the digits incrementally following
+	 *	9 are assumed to be "abc...z" or "ABC...Z"
+	 */
+	if (!isalnum(c) || (xx = DIGIT(c)) >= base)
+		return (0); /* no number formed */
+	if (base == 16 && c == '0' && isxdigit(str[2]) &&
+	    (str[1] == 'x' || str[1] == 'X'))
+		c = *(str += 2); /* skip over leading "0x" or "0X" */
+	for (val = -DIGIT(c); isalnum(c = *++str) && (xx = DIGIT(c)) < base; )
+		/* accumulate neg avoids surprises near MAXLONG */
+		val = base * val - xx;
+	if (ptr != (char **)0)
+		*ptr = str;
+	return (neg ? val : -val);
+}
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/threads.c ubc-1.05alpha-src/vm/src/threads.c
--- sourceforge-1.06alpha/vm/src/threads.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/threads.c	2017-12-11 17:59:03.429711894 +0100
@@ -0,0 +1,344 @@
+/* threads.c - threads abstractions (for MTHREADS)
+ */
+
+#pragma warning(disable: 4068)
+#pragma pointer_size long
+#include <stdio.h>
+#include <stdlib.h>
+#pragma pointer_size short
+#include "threads.h"
+#include "types.h"
+#include "trace.h"
+#include "read.h"
+#include "write.h"
+#include "assert.h"
+#include "misc.h"
+#include "vm_exp.h"
+
+extern int nMessagesSent, nMessagesReceived, nBytesSent, nBytesReceived;
+#ifdef WIN32
+extern semaphore theBigLock;
+#endif /* not WIN32 */
+
+#if defined(MALLOCPARANOID)
+#if 1
+static FILE *junk;
+#define PMEXTRA 0
+#define MAXBLOCKS 1024
+#define TRWINDOW 1
+static int trindex = 0;
+typedef struct {
+  char command;
+  short size;
+  void *buf1, *buf2;
+  unsigned NodeAddr;
+} trrec;
+trrec trbuf[TRWINDOW];
+#define lassert(b) if (!(b)) { printf("lassert failure at %s, %d\n", __FILE__, __LINE__); trdump(); fflush(stdout); abort(); }
+void trdump(void);
+
+static void trm(char c, int size, void *buf1, void *buf2)
+{
+  trbuf[trindex].command = c;
+  trbuf[trindex].size = size;
+  trbuf[trindex].buf1 = buf1;
+  trbuf[trindex].buf2 = buf2;
+  trbuf[trindex].NodeAddr = MTGetCurrentNodeAddr();
+  trindex = (trindex + 1) % TRWINDOW;
+  if (trindex == 0) trdump();
+#if 0
+  if (c == 'M') {
+    int i = (trindex - 2 + TRWINDOW) % TRWINDOW;
+    while (i != trindex) {
+      if (trbuf[i].command == 'R' && trbuf[i].buf2 == buf1) break;
+      if (trbuf[i].buf1 == buf1) {
+	lassert(trbuf[i].command == 'F');
+	break;
+      }
+      i = (i - 1 + TRWINDOW) % TRWINDOW;
+    }
+  }
+#endif
+}
+
+void trdump(void)
+{
+  int i, j;
+  for (i = 0; i < TRWINDOW; i++) {
+    j = (trindex + i) % TRWINDOW;
+    printf("%08x: [%4d] %c %d ", trbuf[j].NodeAddr, j, trbuf[j].command, trbuf[j].size);
+    if (trbuf[j].command == 'R')
+      printf(" %x", trbuf[j].buf2);
+    printf(" -> %x\n", trbuf[j].buf1);
+  }
+  fflush(stdout);
+}
+
+static unsigned *allblocks[MAXBLOCKS];
+
+static void setupOne(unsigned *t, int b)
+{
+  int i;
+  t[0] = 0xaaaabbbb;
+  t[1] = 0xbbbbcccc;
+  t[2] = b;
+  t[3] = (unsigned)t;
+  t[((b + 3)>>2) + 4] = 0xccccdddd;
+  t[((b + 3)>>2) + 5] = 0xddddeeee;
+  t[((b + 3)>>2) + 6] = 0xeeeeffff;
+  t[((b + 3)>>2) + 7] = 0xffffaaaa;
+  for (i = 0; i < PMEXTRA; i++) {
+    t[((b + 3)>>2) + 8 + i] = 0xffffaaaa + i;
+  }
+}
+
+static void checkOne(unsigned *t)
+{
+  int a, i;
+  lassert(t[0] == 0xaaaabbbb);
+  lassert(t[1] == 0xbbbbcccc);
+  a = t[2];
+  lassert(t[3] == (unsigned)t);
+  lassert(t[((a + 3)>>2) + 4] == 0xccccdddd);
+  lassert(t[((a + 3)>>2) + 5] == 0xddddeeee);
+  lassert(t[((a + 3)>>2) + 6] == 0xeeeeffff);
+  lassert(t[((a + 3)>>2) + 7] == 0xffffaaaa);
+  for (i = 0; i < PMEXTRA; i++) {
+    lassert(t[((a + 3)>>2) + 8 + i] == 0xffffaaaa + i);
+  }
+}
+
+void checkAll(void)
+{
+  int i;
+  return;
+  for (i = 0; i < MAXBLOCKS; i++) {
+    if (allblocks[i] != NULL) {
+      checkOne(allblocks[i]);
+    }
+  }
+}
+
+void rememberOne(unsigned *t)
+{
+  int i;
+  return;
+  for (i = 0; i < MAXBLOCKS; i++) {
+    if (allblocks[i] == 0) {
+      allblocks[i] = t;
+      return;
+    }
+  }
+  assert(0);
+}
+
+void forgetOne(unsigned *t)
+{
+  int i;
+  return;
+  for (i = 0; i < MAXBLOCKS; i++) {
+    if (allblocks[i] == t) {
+      allblocks[i] = NULL;
+      return;
+    }
+  }
+  assert(0);
+}
+  
+void *vmMalloc(a)
+{
+  unsigned *t = (unsigned *)malloc(((a + 3)&~3) + (8 + PMEXTRA) * sizeof(int));
+
+  /*  if (!junk) junk = fopen("junk", "w");*/
+  setupOne(t, a);
+  rememberOne(t);
+  trm('M', a, &t[4], 0);
+  /*  fprintf(junk, "M %d -> %#x\n", a, &t[4]); fflush(junk); */
+  checkAll();
+  return (void *)&t[4];
+}
+
+void *vmRealloc(void *old, int b)
+{
+  int a;
+  unsigned *t = (unsigned *)old - 4;
+  a = t[2];
+  checkOne(t);
+  forgetOne(t);
+  t = (unsigned *)realloc(t, ((b + 3)&~3) + (8 + PMEXTRA) * sizeof(int));
+  setupOne(t, b);
+  rememberOne(t);
+  trm('R', b, &t[4], old);
+  /*  fprintf(junk, "R %#x[%d] %d -> %#x\n", old, a, b, &t[4]); fflush(junk); */
+  checkAll();
+  return (void *)&t[4];
+}
+void *vmCalloc(int a, int b)
+{
+  void *t = vmMalloc(a * b);
+  memset(t, 0, a * b);
+  return t;
+}
+
+void vmFree(void *old)
+{
+  int a;
+  unsigned *t = (unsigned *)old - 4;
+  if (!old) return;
+  checkAll();
+  checkOne(t);
+  a = t[2];
+  forgetOne(t);
+  trm('F', a, old, 0);
+  /*  fprintf(junk, "F %#x[%d]\n", old, a); fflush(junk); */
+  free(t);
+}
+#else
+static int nmallocs, nfrees, nbigmallocs;
+void *vmMalloc(int a)
+{
+  if (a > 40000) {
+    nbigmallocs ++;
+  }
+  nmallocs++;
+  return malloc(a);
+}
+
+void *vmRealloc(void *old, int b)
+{
+  if (b > 40000) {
+    nbigmallocs++;
+  }
+  return realloc(old, b);
+}
+void *vmCalloc(int a, int b)
+{
+  if (a * b > 40000) {
+    nbigmallocs ++;
+  }
+  nmallocs++;
+  return malloc(a * b);
+}
+
+void vmFree(void *old)
+{
+  if (old) nfrees++;
+  free(old);
+}
+#endif
+#endif
+#ifdef MTHREADS
+
+#ifdef WIN32MALLOCDEBUG
+_CrtMemState onceinitialized;
+#endif
+
+int
+vmInitThreads()
+{
+  extern Node MyNode;
+  extern OID MyBaseOID;
+  int port;
+  char *plane;
+  extern char *getenv(const char *);
+
+#ifdef WIN32MALLOCDEBUG
+   // Send all reports to STDOUT
+
+#define  SET_CRT_DEBUG_FIELD(a) \
+	_CrtSetDbgFlag((a) | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG))
+
+#if 0
+   // Set the debug-heap flag so that freed blocks are kept on the
+   // linked list, to catch any inadvertent use of freed memory
+   // You only can do this if you are allocating a few blocks
+   SET_CRT_DEBUG_FIELD( _CRTDBG_DELAY_FREE_MEM_DF );
+#endif
+
+   _CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_FILE );
+   _CrtSetReportFile( _CRT_WARN, _CRTDBG_FILE_STDOUT );
+   _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_FILE );
+   _CrtSetReportFile( _CRT_ERROR, _CRTDBG_FILE_STDOUT );
+   _CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_FILE );
+   _CrtSetReportFile( _CRT_ASSERT, _CRTDBG_FILE_STDOUT );
+#endif
+
+  MyNode.Epoch = random() & 0xffff;
+  /* start up the network subsystem */
+  port = EMERALDFIRSTPORT;
+  plane = getenv("EMPLANE");
+  if (plane) port += mstrtol(plane, 0, 10);
+
+  while (MTNetStart(0,  port, MyNode.Epoch) != 0) {
+    port = EMERALDPORTPROBE(port);
+    if (port > 0x10000) return -1;
+  }
+  MyNode.IPAddress = myid.ipaddress;
+  MyNode.EmeraldInstance = myid.port;
+  MyNode.Epoch = myid.incarnation;
+  MyBaseOID.IPAddress = ntohl(MyNode.IPAddress);
+  MyBaseOID.EmeraldInstance = MyNode.EmeraldInstance;
+  MyBaseOID.Epoch = MyNode.Epoch;
+
+  return 0;
+}
+
+#ifndef WORKERSTACKSIZE
+#define WORKERSTACKSIZE (32 * 1024)
+#endif
+
+#ifdef WIN32MALLOCDEBUG
+void vmDoneInit()
+{
+    // Store a memory checkpoint in the memory-state structure
+	_CrtMemCheckpoint( &onceinitialized );
+}
+
+void vmMallocCheck()
+{
+  _CrtCheckMemory();
+}
+
+void vmMallocDump()
+{
+  _CrtMemState temp;
+  _CrtMemCheckpoint( &temp );  
+  _CrtMemDumpStatistics(&temp);
+
+  _CrtCheckMemory( );
+
+  /* This one dumps all objects. */
+  /* _CrtDumpMemoryLeaks( ); */
+
+  /*
+   * This will only dump the objects that have been allocated
+   * since the node finished initializing
+   */
+  _CrtMemDumpAllObjectsSince( &onceinitialized );
+
+}
+
+
+void vmMallocDumpAll()
+{
+  _CrtMemState temp;
+  _CrtMemCheckpoint( &temp );  
+  _CrtMemDumpStatistics(&temp);
+
+  _CrtCheckMemory( );
+
+  _CrtDumpMemoryLeaks( );
+}
+#endif
+
+char *NodeAddrString(NodeAddr srv)
+{
+  static char buf[5][60];
+  static int i = 0;
+  char *rval;
+
+  rval = buf[i]; i = (i+1) % 5;
+  sprintf(rval, "%08lx.%04x.%04x", srv.ipaddress, srv.port, srv.incarnation);
+  return rval;
+}
+#endif /* MTHREADS */
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/threads.h ubc-1.05alpha-src/vm/src/threads.h
--- sourceforge-1.06alpha/vm/src/threads.h	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/threads.h	2017-12-11 17:59:03.429711894 +0100
@@ -0,0 +1,79 @@
+/*
+ * threads.h
+ */
+
+#ifndef _EMERALD_THREADS_H
+#define _EMERALD_THREADS_H
+
+#ifndef _EMERALD_STORAGE_H
+#include "storage.h"
+#endif
+extern int useThreads;
+
+#define EMERALDFIRSTPORT 0x3ee3
+#define EMERALDPORTSKIP 0x100
+#define EMERALDPORTPROBE(n) ((n) + EMERALDPORTSKIP)
+#ifdef MTHREADS
+
+#include "mthreads.h"
+#ifdef WIN32
+#include <io.h>
+#endif /* not WIN32 */
+#define filesizeofNodeAddr (sizeof(unsigned int) + 2 * sizeof(unsigned short))
+int vmInitThreads(void);
+char *NodeAddrString(NodeAddr);
+extern NodeAddr myid;
+
+#define SameNodeAddrHost(a,b) ((a).ipaddress == (b).ipaddress && (a).port == (b).port)
+#define SameNodeAddr(a,b) ((a).ipaddress == (b).ipaddress && (a).port == (b).port && (a).incarnation == (b).incarnation)
+
+#define vmOpen(a,b,c) open(a,b,c)
+#ifdef WIN32
+#define reax(fd, buf, nbytes) _read(fd, buf, nbytes)
+extern size_t vmRead(int fd, void *buf, size_t nbytes);
+#define writx(fd, buf, nbytes) _write(fd, buf, nbytes)
+extern size_t vmWrite(int fd, void *buf, size_t nbytes);
+#define selecx(fd, r, w, x, t) select(fd, r, w, x, t)
+#else /* not WIN32 */
+
+#define vmRead(fd, buf, nbytes) read(fd, buf, nbytes)
+#define vmWrite(fd, buf, nbytes) write(fd, buf, nbytes)
+#ifndef FAKESELECT
+#define selecx(fd, r, w, x, t) select(fd, r, w, x, t)
+#endif
+#endif /* not WIN32 */
+#define vmClose(a) close(a)
+#define vmSocket(a,b,c) socket(a,b,c)
+#define vmAccept(a,b,c) accept(a,b,c)
+
+#else
+
+typedef int NodeAddr;
+#define filesizeofNodeAddr sizeof(unsigned)
+typedef int semaphore;
+#define vmInitThreads() (-1)
+#define vmCreateThread(b,c) (-1)
+#define vmThreadSleep(a) sleep(a)
+#define vmThreadMSleep(a, b) sleep(a)
+#define SameNodeAddrHost(a,b) (0)
+
+#define vmMain(a,b) main(a,b)
+#define vmOpen(a,b,c) open(a,b,c)
+#define vmRead(a,b,c) read(a,b,c)
+#define vmWrite(a,b,c) write(a,b,c)
+#define vmClose(a) close(a)
+#ifdef WIN32
+#define vmSocket(a,b,c) xxxxsocket(a,b,c)
+#else /* not WIN32 */
+#define vmSocket(a,b,c) socket(a,b,c)
+#endif /* not WIN32 */
+#define vmAccept(a,b,c) accept(a,b,c)
+
+#define WriteNodeAddr(a, b) abort()
+#define ReadNodeAddr(a, b) abort()
+#define NodeAddrString(x) "a thread"
+#endif /* MTHREADS */
+
+#endif /* _EMERALD_THREADS_H */
+
+/* EOF */
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/types.h ubc-1.05alpha-src/vm/src/types.h
--- sourceforge-1.06alpha/vm/src/types.h	2017-12-11 17:59:03.092714462 +0100
+++ ubc-1.05alpha-src/vm/src/types.h	2017-12-11 17:59:03.429711894 +0100
@@ -479,4 +457,3 @@
 ****************************************************************************/
 
 #endif /* _EMERALD_TYPES_H */
-#include "codeptrextra.h"
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/vm.d ubc-1.05alpha-src/vm/src/vm.d
--- sourceforge-1.06alpha/vm/src/vm.d	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/vm.d	2017-12-11 17:59:03.429711894 +0100
@@ -0,0 +1,1834 @@
+{/* This file should probably be read in -*- c -*- mode. */
+/*
+ * Jekyll Virtual Machine description file, for use with VMC
+ */
+
+#define _EMERALD_VM_I_H
+#define E_NEEDS_MATH
+#define E_NEEDS_NTOH
+#define E_NEEDS_STRING
+#include "system.h"
+#ifndef max
+#define max(x,y) (((x)<(y))?(y):(x))
+#endif
+#ifndef min
+#define min(x,y) (((x)<(y))?(x):(y))
+#endif
+#define ARGOFF (-24)
+
+#include "trace.h"
+#include "assert.h"
+#include "rinvoke.h"
+#include "globals.h"
+#include "iisc.h"
+#include "misc.h"
+#include "jsys.h"
+#include "creation.h"
+#include "oidtoobj.h"
+#include "squeue.h"
+#include "concurr.h"
+#include "iset.h"
+#include "call.h"
+#include "gc.h"
+
+extern ISet allProcesses;
+extern SQueue ready;
+extern int runningProcesses;
+#if defined(SINGLESTEP)
+extern int instructionsToExecute, gotsigint;
+#if !defined(COUNTBYTECODES)
+#define COUNTBYTECODES
+#endif
+#endif
+
+extern int debug(struct State *state, char *m);
+extern int doNCCall(struct State *state);
+extern void stoCheck (Object intoObj, Object storedObj);
+extern void obsolete(char *name, struct State *state);
+extern void setBits(Vector v, int off, int len, u32 val);
+extern void ntohBits(Vector v, int off, int len);
+extern int invoke(Object obj, ConcreteType ct, int opindex, struct State *state);
+extern struct State *newStackChunk(struct State *);
+extern void doret(int fp, int sb, int pc, ConcreteType ct);
+extern void thaw(Object obj, Reason why);
+extern void freeze(Object obj, Reason why);
+extern void processMovedOut(struct State *state);
+extern void CheckpointToFile(Object o, ConcreteType ct, String file);
+extern void gcollect(void);
+extern void gcollect_old(void);
+extern void docall(int op, int sp, int fp, ConcreteType ct, Object oop, int sb);
+extern void docallct(OpVectorElement ove, int sp, int fp, ConcreteType ct, Object oop, int sb);
+extern int conforms(AbstractType a, AbstractType b);
+
+extern void createGaggle(OID g);
+extern void add_gmember(OID gid, OID newMember);
+extern void sendGaggleUpdate(OID moid, OID ooid, OID ctoid, int dead);
+extern void loadNGo(String s);
+extern void fixObjectReferenceFromSeq(unsigned seq, Object within, int offset);
+extern void fixCTLiterals(ConcreteType ct);
+extern void stringTok(String s, String brk, int *startp, int *endp);
+extern void disassemble(unsigned int ptr, int len, FILE *f);
+#ifdef hp700
+extern int random(void);
+extern int srandom(unsigned int);
+#endif
+extern int interpret(struct State *);
+
+/* 
+ * Compute the offset of a field within a structure.
+ */
+#define OffsetOf(within, addr) ((char *)(addr) - (char *)(within))
+
+/*
+ * macros for load/store operations
+ */
+#define PF(x,y) PUSH(u32,FETCH(u32,x,y))
+#define PS(x,y) POP(u32,v); STORE(u32,x,y,v)
+#define LD(x)   u32 t;   IFETCH4(t); PUSH(u32, x)
+#define EST(x,y) u32 t,v; IFETCH4(t); PS(x,y)
+/* although the immediates we fetch are 16-bits, push a 32 bit result */
+#define LDS(x)   s16 t;   IFETCH2(t); PUSH(u32, (u32)(x))
+#define STS(x,y) s16 t; u32 v; IFETCH2(t); PS(x,y)
+/* although the immediates we fetch are 8-bits, push a 32 bit result */
+#define LDB(x)   s8 t;   IFETCH1(t); PUSH(u32, (u32)(x))
+#define STB(x,y) s8 t; u32 v; IFETCH1(t); PS(x,y)
+/*
+ * macros for arithmetic and logic operations
+ */
+#define UNARY(type,c_op) type a; TOP(type, a); SETTOP(type, c_op a);
+#define UNARYZ(type,c_op) type a; TOP(type, a); SETTOP(type, a c_op 0);
+#define BINARY(type,c_op) \
+  type a, b; POP(type,a); TOP(type,b); SETTOP(type, b c_op a);
+/*
+ * Miscellany
+ */
+
+#define ASSTR(type,fmt) { type a; String s; \
+  POP(type, a); sprintf(buf,fmt,a); \
+  F_SYNCH(); s = CreateString(buf); F_UNSYNCH(); \
+  PUSH(String, s); }
+
+#if defined(TIMESLICE)
+#   define CONTEXTSWITCHINVOKES (random() % 200)
+#   define CONTEXTSWITCHBRANCHS (random() % 500)
+#   define CONTEXTSWITCH					\
+	TRACE(process, 3, ("Preempting process %x", state));	\
+	SYNCH();						\
+	makeReady(state);					\
+	return 1;
+
+#   define CHECKSWITCH(count, limit)				\
+       if (runningProcesses && (--count < 0)) {			\
+	count = limit;						\
+	CONTEXTSWITCH						\
+      }
+
+#   define TIMESLICELOCALS \
+      static int totalinvocs = 50; \
+      static int branches = 10;
+#else
+#   define CHECKSWITCH(a, b)
+#   define TIMESLICELOCALS 
+#endif /* TIMESLICE */
+
+#define BRANCHCHECKSWITCH CHECKSWITCH(branches, CONTEXTSWITCHBRANCHS)
+#define INVOKECHECKSWITCH CHECKSWITCH(totalinvocs, CONTEXTSWITCHINVOKES)
+
+#ifdef SINGLESTEP
+#   define DEBUG(m) { \
+	       SYNCH(); \
+	       if (debug(state, m)) { \
+		 return 1; \
+	       } else { \
+	         UNSYNCH(); \
+	       } \
+      }
+#else
+#   define DEBUG(m) { \
+	       SYNCH(); \
+	       if (debug(state, m)) { \
+		 return 1; \
+	       } else { \
+		 UNSYNCH(); \
+	       } \
+      }
+#endif
+
+#define CHECKNILV(v,m) CHECKNIL(Vector, v, m)
+#define CHECKNILS(s,m) CHECKNIL(String, s, m)
+#define CHECKNILO(o,m) CHECKNIL(Object, o, m)
+#define CHECKNILU(u,m) CHECKNIL(u32, u, m)
+
+#if defined(NEMCHECK)
+#   define BOUNDSCHECK(v, i)
+#   define CHECKNIL(t, v, m)
+#else
+#   define BOUNDSCHECK(v, i)					\
+      if (i < 0 || i >= (v)->d.items) {				\
+	sprintf(buf, "Subscript %d out of range [0:%d] on access to %.*s", \
+		i, (v)->d.items - 1,				\
+		CODEPTR(v->flags)->d.name->d.items,		\
+		(char *)CODEPTR(v->flags)->d.name->d.data);	\
+	DEBUG(buf);						\
+	continue;						\
+      }
+#   define CHECKNIL(t, v, m) if (ISNIL(v)) DEBUG(m);
+#endif
+
+#if defined(PROFILEINVOKES)
+#   define TOPOFTHEINTERPRETLOOPA if (doInvokeProfiling) ++*currentOPECount;
+#   define PROFILEBUMP(pc,ove,a) if (doInvokeProfiling) profileBump(pc,ove,a)
+#   define PROFILERET() profileRet()
+#else
+#   define TOPOFTHEINTERPRETLOOPA
+#   define PROFILEBUMP(pc,ove,a) 
+#   define PROFILERET()
+#endif
+
+#define TOPOFTHEINTERPRETLOOPB 
+#if defined(SINGLESTEP)
+#   define TOPOFTHEINTERPRETLOOPC \
+	if (instructionsToExecute > 0 && addtototalbytecodes >= instructionsToExecute) { DEBUG(gotsigint ? "Interrupt" : "Single step"); }
+#else
+#   define TOPOFTHEINTERPRETLOOPC
+#endif
+
+#define TOPOFTHEINTERPRETLOOP \
+  TOPOFTHEINTERPRETLOOPA \
+  TOPOFTHEINTERPRETLOOPB \
+  TOPOFTHEINTERPRETLOOPC
+
+#ifdef SINGLESTEP
+#   define INTERPRETERLOCALS \
+      u32 opoid; \
+      char buf[80]; \
+      TIMESLICELOCALS
+#else
+#   define INTERPRETERLOCALS \
+      u32 opoid; \
+      char buf[80]; \
+      TIMESLICELOCALS
+#endif /* SINGLESTEP */
+
+}
+
+@ Design decisions:
+@   When variables are pushed on the stack, they are pushed data then AbCon
+@   Object creations push a code pointer, and return an object pointer
+@   An activation record looks like:
+@
+@	return value 1	(variable)	8
+@	...
+@	return value n	(variable)	8
+@	argument     1	(variable)	8
+@	...
+@	argument     n	(variable)	8     <-- fp - ARGOFF 
+@       saved cp                        4
+@	saved op			4
+@	saved fp			4
+@	saved pc			4
+@	local 1		(whatever)	?     <--- new fp
+@	...
+@	local n		(whatever)	?
+@
+@
+
+State:
+@	implicit registers include:
+@	pc	"Program counter"	"u32"
+@	my explicit registers:
+	sp	"Stack pointer"		"u32"
+	fp	"Frame pointer"		"u32"
+	_sb     "Stack base"            "u32"
+	op	"Object pointer"	"Object"
+	cp	"Concrete type"		"ConcreteType"
+	_ep	"Environment pointer"	"Object"
+	_et	"Environment type"	"ConcreteType"
+	_nsoid	"Next SS OID"		"OID"
+	_nstoid	"Next target OID"	"OID"
+	_psoid	"Prev SS OID"		"OID"
+	_psnres	"Results to return"	"u32"
+
+Interrupts:
+	IO	{ microcode ... }
+	INT	{ microcode ... }
+
+Instructions:
+@ Most load instructions use an implicit temporary t, which is the
+@ argument to the load instruction.
+    LDI "u32"	{ LD(t); }
+@ Load a relative address.
+    LDIR "u32"	{ LD(FETCH(u32,pc,t)); }
+@ Load a local variable.
+    LDL "u32"	{ LD(FETCH(u32,fp,t)); }
+    LDO "u32"	{ LD(FETCH(u32,op,t)); }
+@ Load an argument.
+    LDA "u32"	{ LD(FETCH(u32,fp,-(int)t+ARGOFF)); }
+@ general purpose escape to the system
+    NCCALL "u8u8"  {
+		  int res;
+		  SYNCH();
+		  res = doNCCall(state);
+		  if (res) return 1;
+		  UNSYNCH();
+		}
+    STL "u32"	{ EST(fp,t); }
+    STO "u32"	{ EST(op,t); stoCheck(op, (Object)v); }
+    STA "u32"	{ EST(fp,-(int)t+ARGOFF); }
+
+    LDVL "u32"	{ LD(FETCH(u32,fp,t)); PF(fp,t+4); }
+    LDVO "u32"	{ LD(FETCH(u32,op,t)); PF(op,t+4); }
+    LDVA "u32"	{ LD(FETCH(u32,fp,-(int)t+ARGOFF)); PF(fp,-(int)t+ARGOFF+4); }
+    STVL "u32"	{ EST(fp,t+4); PS(fp,t); }
+    STVO "u32"	{ EST(op,t+4); stoCheck(op, (Object)v); PS(op,t); stoCheck(op, (Object)v); }
+    STVA "u32"	{ EST(fp,-(int)t+ARGOFF+4); PS(fp,-(int)t+ARGOFF); }
+
+@ 16-bit versions of the loads and stores; branches are already 16-bit ops
+@ These use a 16-bit immediate offset but otherwise deal in 32-bit entities
+    LDIS "s16"	{ LDS(t); }
+    FPOW ""	{ f32 a, b; POP(f32,a); TOP(f32, b); SETTOP(f32, (float)pow((double)b, (double)a)); }
+    LDLS "s16"	{ LDS(FETCH(u32,fp,t)); }
+    LDOS "s16"	{ LDS(FETCH(u32,op,t)); }
+    LDAS "s16"	{ LDS(FETCH(u32,fp,-t+ARGOFF)); }
+
+    STLS "s16"	{ STS(fp,t); }
+    STOS "s16"	{ STS(op,t); stoCheck(op, (Object)v); }
+    STAS "s16"	{ STS(fp,-t+ARGOFF); }
+
+    LDVLS "s16"	{ LDS(FETCH(u32,fp,t)); PF(fp,t+4); }
+    LDVOS "s16"	{ LDS(FETCH(u32,op,t)); PF(op,t+4); }
+    LDVAS "s16"	{ LDS(FETCH(u32,fp,-t+ARGOFF)); PF(fp,-t+ARGOFF+4); }
+    STVLS "s16"	{ STS(fp,t+4); PS(fp,t); }
+    STVOS "s16"	{ STS(op,t+4); stoCheck(op, (Object)v); PS(op,t); stoCheck(op, (Object)v); }
+    STVAS "s16"	{ STS(fp,-t+ARGOFF+4); PS(fp,-t+ARGOFF); }
+
+@ 8-bit versions of the loads and stores; branches are already 8-bit ops
+@ These use a 8-bit immediate offset but otherwise deal in 32-bit entities
+    LDIB "s8"	{ LDB(t); }
+    ISTRX ""    { ASSTR(s32,"%08x"); }
+    LDLB "s8"	{ LDB(FETCH(u32,fp,t)); }
+    LDOB "s8"	{ LDB(FETCH(u32,op,t)); }
+    LDAB "s8"	{ LDB(FETCH(u32,fp,-t+ARGOFF)); }
+
+    STLB "s8"	{ STB(fp,t); }
+    STOB "s8"	{ STB(op,t); stoCheck(op, (Object)v); }
+    STAB "s8"	{ STB(fp,-t+ARGOFF); }
+
+    LDVLB "s8"	{ LDB(FETCH(u32,fp,t)); PF(fp,t+4); }
+    LDVOB "s8"	{ LDB(FETCH(u32,op,t));
+		  PF(op,t+4); }
+    LDVAB "s8"	{ LDB(FETCH(u32,fp,-t+ARGOFF)); PF(fp,-t+ARGOFF+4); }
+    STVLB "s8"	{ STB(fp,t+4); PS(fp,t); }
+    STVOB "s8"	{ STB(op,t+4); stoCheck(op, (Object)v); PS(op,t); stoCheck(op, (Object)v); }
+    STVAB "s8"	{ STB(fp,-t+ARGOFF+4); PS(fp,-t+ARGOFF); }
+
+@ Miscellaneous stack machine operations
+    DUP   ""    { u32 a;   POP(u32,a); PUSH(u32,a); PUSH(u32,a); }
+    DUPV  ""    { SYNCH(); obsolete("DUPV", state); }
+    SWAP  ""    { SYNCH(); obsolete("SWAP", state); }
+
+@ Arithmetic operations find operands on the stack, and push the result
+@ Floating point versions are preceded by F
+@ String versions are preceded by S
+    ADD ""	{ BINARY(s32,+) }
+    SUB ""	{ BINARY(s32,-) }
+    MUL ""	{ BINARY(s32,*) }
+    DIV ""	{ BINARY(s32,/) }
+    MOD ""	{ BINARY(s32,%) }
+    NEG ""      {  UNARY(s32,-) }
+    FADD ""	{ BINARY(f32,+) }
+    FSUB ""	{ BINARY(f32,-) }
+    FMUL ""	{ BINARY(f32,*) }
+    FDIV ""	{ BINARY(f32,/) }
+    FNEG ""     {  UNARY(f32,-) }
+@ Comparison operations
+    EQ  ""      { UNARYZ(s32,==) }
+    NE  ""      { UNARYZ(s32,!=) }
+    GT  ""      { UNARYZ(s32,> ) }
+    GE  ""      { UNARYZ(s32,>=) }
+    LT  ""      { UNARYZ(s32,< ) }
+    LE  ""      { UNARYZ(s32,<=) }
+@   ICMP is now called SUB!
+    FCMP ""     {
+                  f32 a, b;
+		  POP(f32,b); POP(f32,a);
+		  a = a-b;
+		  PUSH(s32,((a>0)?1:((a<0)?(-1):0)));
+		}
+    SCMP ""     {
+                  String a, b;
+		  int i;
+		  POP(String,b);
+		  POP(String,a);
+		  CHECKNILS(b, "SCMP on a string which is nil");
+		  CHECKNILS(a, "SCMP on a string which is nil");
+		  i = memcmp((char *)a->d.data, (char *)b->d.data,min(a->d.items,b->d.items));
+		  if (!i) i = a->d.items - b->d.items;
+		  PUSH(s32,i);
+                }
+@ Logical operations
+    AND ""      { BINARY(s32,&&) }
+    OR  ""      { BINARY(s32,||) }
+    NOT ""      {  UNARY(s32, !) }
+    ASSERT ""   { s32 a; POP(s32,a);
+                  if(!a) DEBUG("Assertion failed");
+                }
+@ Conversions
+    CSTR ""     { s32 a;
+                  String s;
+
+                  POP(s32,a);
+		  F_SYNCH();
+		  s = (String)CreateVector(BuiltinInstCT(STRINGI),1);
+		  F_UNSYNCH();
+                  s->d.items = 1;
+		  s->d.data[0] = (char)a;
+		  PUSH(String,s);
+                }
+    FINT ""     { f32 a; POP(f32,a); PUSH(s32,(s32)a); }
+    IFLO ""     { s32 a; POP(s32,a); PUSH(f32,(f32)a); }
+    ISTR ""     { ASSTR(s32,"%d"); }
+    FSTR ""     { ASSTR(f32,"%g"); }
+    EBSTR ""     { s32 a;
+		  POP(s32,a);
+		  PUSH(String, (a?TrueString:FalseString));
+                }
+@ Bitchunk operations
+@
+@ At the moment, these are only defined for lengths <= 32.
+     BGETS ""      {
+                     u32 off, len;
+		     s32 temp;
+		     Vector v;
+
+                     POP(u32,len);
+                     POP(u32,off);
+                     POP(Vector,v);
+		     CHECKNILV(v, "BGETS on nil");
+		     temp = ((int *)v->d.data)[off >> 5];
+		     temp = temp << (off & 31);
+		     temp = temp >> (32 - len);
+		     PUSH(u32,temp);
+                   }
+     BGETU ""      {
+                     u32 off, len;
+		     u32 temp;
+		     Vector v;
+
+                     POP(u32,len);
+                     POP(u32,off);
+                     POP(Vector,v);
+		     CHECKNILV(v, "BGETU on nil");
+		     temp = ((int *)v->d.data)[off >> 5];
+		     temp = temp << (off & 31);
+		     temp = temp >> (32 - len);
+		     PUSH(u32,temp);
+                   }
+     BSET  ""      {
+                     u32 off, len;
+		     u32 setval;
+		     Vector v;
+
+		     POP(u32, setval);
+                     POP(u32,len);
+                     POP(u32,off);
+                     POP(Vector,v);
+		     CHECKNILV(v, "BSET on nil");
+		     setBits(v, off, len, setval);
+                   }
+     NTOH  ""      {
+                     u32 off, len;
+		     Vector v;
+
+                     POP(u32,len);
+                     POP(u32,off);
+                     POP(Vector,v);
+		     CHECKNILV(v, "NTOH on nil");
+		     ntohBits(v, off, len);
+                   }
+@ Vector operations
+     GETB   ""     {
+                     Vector v;
+                     s32 i;
+
+                     POP(s32,i);
+                     POP(Vector,v);
+		     CHECKNILV(v, "GETB on a vector which is nil");
+		     BOUNDSCHECK(v, i);
+		     PUSH(s32,(s32)(v->d.data[i]));
+                   }
+     GET    ""     {
+                     Vector o1;
+		     s32 i, v;
+		     ConcreteType ct;
+
+		     POP(s32,i);
+		     POP(Vector,o1);
+		     CHECKNILV(o1, "GET on a vector which is nil");
+		     ct = CODEPTR(o1->flags);
+		     BOUNDSCHECK(o1, i);
+		     if (ct->d.instanceSize == -1 || ct->d.instanceSize == 1) {
+		       v = o1->d.data[i];
+		     } else {
+		       v = *(((s32 *)(o1->d.data)) + i);
+		     }
+		     PUSH(s32, v);
+                   }
+     GETV   ""     {
+                     Vector o1;
+		     s32 i, *p;
+		     POP(s32,i);
+		     POP(Vector,o1);
+
+		     CHECKNILV(o1, "GETV on a vector which is nil");
+		     BOUNDSCHECK(o1, i);
+                     p = (((s32 *)(o1->d.data)) + (i<<1));
+		     PUSH(s32,*p++);
+		     PUSH(s32,*p);
+                   }
+     SET    ""     {
+                     Vector o1;
+		     s32 i, o;
+		     ConcreteType ct, valct;
+		     POP(s32,o);
+		     POP(s32,i);
+		     POP(Vector,o1);
+		     CHECKNILV(o1, "SET on a vector which is nil");
+		     ct = CODEPTR(o1->flags);
+		     BOUNDSCHECK(o1, i);
+		     stoCheck((Object)o1, (Object)o);
+		     if (ct->d.instanceSize == -1 || ct->d.instanceSize == 1) {
+		       o1->d.data[i] = o;
+		     } else if (ct->d.instanceSize == -4 || ct->d.instanceSize == 4) {
+		       *(s32 *)(&(o1->d.data[i<<2])) = o;
+		     } else {
+		       assert(ct->d.instanceSize == -8 || ct->d.instanceSize == 8);
+		       /* We have to be in the SET in IVec.Literal */
+		       if (ISNIL(o)) {
+			 valct = (ConcreteType)JNIL;
+		       } else {
+			 valct = CODEPTR(((Object)o)->flags);
+		       }
+		       stoCheck((Object)o1, (Object)valct);
+		       ((u32 *)o1->d.data)[i * 2] = o;
+		       ((ConcreteType *)o1->d.data)[i * 2 + 1] = valct;
+		     }
+                   }
+     SETV    ""    {
+                     Vector o1;
+		     u32 ct, o;
+		     s32 i;
+		     POP(u32, ct);
+		     POP(u32, o);
+		     POP(s32, i);
+		     POP(Vector, o1);
+		     CHECKNILV(o1, "SETV on a vector which is nil");
+		     BOUNDSCHECK(o1, i);
+		     stoCheck((Object)o1, (Object)o);
+		     stoCheck((Object)o1, (Object)ct);
+		     ((u32 *)o1->d.data)[i * 2] = o;
+		     ((u32 *)o1->d.data)[i * 2 + 1] = ct;
+                   }
+
+@ As defined here, slice ops are object : startindex : numbertoslice
+     GSLICE ""     {
+                     Vector o1, o2;
+		     s32 index, number;
+		     ConcreteType t1;
+                     POP(s32, number);
+                     POP(s32, index);
+		     POP(Vector,o1);
+		     CHECKNILV(o1, "GSLICE on a vector which is nil");
+		     if (number > 0) {
+		       BOUNDSCHECK(o1, index);
+		       BOUNDSCHECK(o1, index + number - 1);
+		     }
+		     t1 = CODEPTR(o1->flags);
+		     regRoot(o1);
+		     regRoot(t1);
+		     F_SYNCH();
+		     o2 = CreateVector(t1, number);
+		     F_UNSYNCH();
+		     unregRoot();
+		     unregRoot();
+#define abs(x) (((x)<0)?-(x):(x))
+		     index *= abs(t1->d.instanceSize);
+		     number *= abs(t1->d.instanceSize);
+#undef abs
+		     memmove(o2->d.data, &(o1->d.data[index]), number);
+		     PUSH(Vector,o2);
+                   }
+     SETLOCSRV ""   {
+		      Object newlocsrv;
+		      POP(Object, newlocsrv);
+		      if (ISNIL(locsrv)) {
+			locsrv = newlocsrv;
+		      }
+                    }
+     CAT    ""     {
+                     Vector o1, o2, o3;
+		     int size;
+		     ConcreteType t1; /* assumed identical for o1, o2 */
+		     POP(Vector,o2);
+		     POP(Vector,o1);
+		     CHECKNILV(o1, "CAT on a vector which is nil");
+		     CHECKNILV(o2, "CAT with an argument vector which is nil");
+		     CHECKNILV(o1->flags, "CAT with an argument vector which is scrambled");
+		     CHECKNILV(o2->flags, "CAT with an argument vector which is scrambled");
+		     t1 = CODEPTR(o1->flags);
+		     if (HASINITIALLY(t1)) DEBUG("Cat on a funny CT");
+		     regRoot(o1);
+		     regRoot(o2);
+		     regRoot(t1);
+		     F_SYNCH();
+		     o3 = (Vector)CreateVector(t1, o1->d.items + o2->d.items);
+		     F_UNSYNCH();
+		     unregRoot();
+		     unregRoot();
+		     unregRoot();
+#define abs(x) (((x)<0)?-(x):(x))
+		     size = abs(t1->d.instanceSize);
+#undef abs
+		     memmove(o3->d.data, o1->d.data, o1->d.items * size);
+		     memmove(o3->d.data+(o1->d.items * size), o2->d.data,
+			   o2->d.items * size);
+		     PUSH(Vector,o3);
+                   }
+     LEN   ""     {
+                    Vector o1;
+		    POP(Vector,o1);
+		    CHECKNILV(o1,"LEN on a vector which is nil");
+		    PUSH(s32,o1->d.items);
+                  }
+@ Call finds the target object on the stack, and the operation number as an
+@ immediate operand.  Call is only used under USEABCONS
+    SETDEBUGGER ""  {
+		      Object newdebugger;
+		      POP(Object, newdebugger);
+		      if (ISNIL(debugger)) {
+			debugger = newdebugger;
+		      }
+                    }
+@ Calloid finds the target object on the stack, and the operation oid as an
+@ immediate operand (4 bytes)
+    CALLOID "u32" {
+      int opindex;
+      ConcreteType a;
+      Object o;
+      IFETCH4(opoid);
+restofcalloid: ;
+
+      POP(ConcreteType, a);
+      POP(Object, o);
+
+      if (ISNIL(a)) { 
+	(opindex) = 0; 
+      } else { 
+	OpVector ov = (a)->d.opVector;
+	OpVectorElement ope;
+	int i;
+	(opindex) = 0;
+	for (i = 3; i < ov->d.items; i++) {
+	  ope = ov->d.data[i];
+	  if (ope->d.id == (opoid)) {
+	    (opindex) = i; 
+	    break;
+	  }
+	}
+	if ((opindex) == 0){
+	  TRACE(interpret, 0, ("FindCode: op %s id %d undefined for ct %.*s (0x%08x)",
+		  OperationName(opoid),(opoid),
+		  (a)->d.name->d.items,
+		  (a)->d.name->d.data,
+		  (u32)(a)));
+	  DEBUG("");
+	}
+      }
+      SYNCH();
+      if (invoke(o, a, opindex, state)) {
+	return 1;
+      } else {
+	UNSYNCH();
+	INVOKECHECKSWITCH;
+      }
+    }
+    LINK "u16"	{
+		  /* allocate space for locals */
+		  u16 space;
+		  IFETCH2(space);
+		  space /= 4;
+		  if (sp + space * 4 + 200 > sb + stackSize) {
+		    SYNCH();
+		    state = newStackChunk(state);
+		    UNSYNCH();
+		  }
+		  for (; space; space--) {
+		    *(int *)sp = JNIL;
+		    sp += 4;
+		  }
+    		}
+    LINKB "u8"	{
+		  /* allocate space for locals, in words! */
+		  u32 space;
+		  IFETCH1(space);
+		  if (sp + space * 4 + 200 > sb + stackSize) {
+		    SYNCH();
+		    state = newStackChunk(state);
+		    UNSYNCH();
+		  }
+		  for (; space; space--) {
+		    *(int *)sp = JNIL;
+		    sp += 4;
+		  }
+    		}
+    RET "u8"	{
+		  u8 nargs;
+		  ConcreteType xcp;
+
+		  IFETCH1(nargs);
+		  PROFILERET();
+
+		  xcp = cp;
+		  sp = fp;
+		  POP(u32, pc);
+		  POP(u32, fp);
+		  POP(Object, op);
+		  POP(ConcreteType, cp);
+		  IFTRACE(call, 1) {
+		    doret(fp, sb, pc, xcp);
+		  }
+		  sp -= (nargs * 2 * sizeof(u32));
+#ifdef DISTRIBUTED
+		  if (BROKEN(op->flags)) {
+		    SYNCH();
+		    if (!RESDNT(op->flags)) {
+		      /* It left */
+		      returnToForeignObject(state, JNIL);
+		      return 1;
+		    } else if (isBroken(op) && returnToBrokenObject(state)) {
+		      return 1;
+		    } else {
+		      UNSYNCH();
+		    }
+		  }
+#endif
+		}
+    QUIT "u8"	{ 
+                  u8 nargs;
+		  Object xop;
+		  ConcreteType xcp;
+		  IFETCH1(nargs);
+
+		  PROFILERET();
+		  thaw(op, RInitially);
+
+		  xcp = cp; xop = op; sp = fp;
+		  POP(u32, pc);
+		  POP(u32, fp);
+		  POP(Object, op);
+		  POP(ConcreteType, cp);
+		  IFTRACE(call, 1) {
+		    doret(fp, sb, -1, xcp);
+		  }
+		  sp -= (nargs * 2 * sizeof(u32));
+
+		  TRACE( initiallies, 1,
+			( "QUIT at sb=%#x, sp=%#x in object %#x (%.*s)",
+			 sb, sp, xop, xcp->d.name->d.items, xcp->d.name->d.data ) );
+
+		  if (HASPROCESS(xcp)) {
+		    TRACE(process, 1,
+			  ("QUIT forking process in object %#x (%.*s)",
+			   xop, xcp->d.name->d.items, xcp->d.name->d.data ) );
+		    run(xop, OVE_PROCESS, 1);
+		  } 
+		}
+    GETLOCSRV "" { 
+  		  Object o;
+		  o = locsrv;
+		  PUSH(Object, o);
+		  if (ISNIL(o)) {
+		    PUSH(ConcreteType, (ConcreteType)JNIL);
+		  } else {
+		    PUSH(ConcreteType, CODEPTR(o->flags));
+		  }
+		 }
+    CREATE ""	{
+                  ConcreteType p;
+		  Object o;
+		  OpVectorElement ove;
+
+		  POP(ConcreteType, p);
+		  F_SYNCH();
+		  regRoot(p);
+                  o = (Object) gc_malloc(sizeofObject + p->d.instanceSize);
+		  unregRoot();
+                  SETRESDNT(o->flags);
+                  SETCODEPTR(o->flags, p);
+		  if (inDistGC()) SETDISTGC(o->flags);
+
+		  ove = p->d.opVector->d.data[OVE_INITIALLY];
+		  if (ISNIL(ove)) {
+		    STORE(Object, sp, -4, o);
+		    if (HASPROCESS(p)) {
+		      TRACE( process, 1,
+			    ( "CREATE invoking process in object %#x (%.*s)",
+			     o, p->d.name->d.items, p->d.name->d.data ) );
+		      run(o, OVE_PROCESS, 1);
+		    }
+		  } else {
+		    STORE(Object, sp, -(4 + ove->d.nargs * 8), o);
+		    freeze(o, RInitially);
+		    TRACE( initiallies, 1,
+			  ( "CREATE invoking initially in object %#x (%.*s)",
+			   o, p->d.name->d.items, p->d.name->d.data ) );
+		    IFTRACE(call, 1) { docall(-1, sp, fp, p, o, sb); }
+		    pushAR(state, o, p, OVE_INITIALLY);
+		  }
+		  F_UNSYNCH();
+	        }
+    CREATEVEC ""  {
+                  ConcreteType p;
+		  Vector o;
+		  unsigned n;
+                  int is;
+
+		  POP(unsigned, n);
+		  POP(ConcreteType, p);
+                  is = (p->d.instanceSize < 0 ?
+                	-p->d.instanceSize : p->d.instanceSize);
+		  regRoot(p);
+		  F_SYNCH();
+                  o = (Vector) gc_malloc(sizeofObject + n * is + sizeof(int));
+		  F_UNSYNCH();
+		  unregRoot();
+                  SETRESDNT(o->flags);
+                  SETCODEPTR(o->flags, p);
+		  if (inDistGC()) SETDISTGC(o->flags);
+                  if (HASINITIALLY(p)) DEBUG("Create vec on a funny CT");
+                  o->d.items = n;
+		  SETTOP(Vector, o);
+		}
+@ Terminate a process
+    QUITP ""    { 
+      extern State *processDone(State *, int);
+      if (TRACING(call, 1)) doret(fp, sb, -2, cp);
+      SYNCH(); 
+      TRACE( process, 2,
+	    ( "End of process in object %#x (%.*s)", state->op,
+	     state->cp->d.name->d.items, state->cp->d.name->d.data ) );
+      if ((state = processDone(state, 0))) {
+	makeReady(state);
+      }
+      return 0;
+    }		   
+@ branching instructions
+    BR "s16"	{ s16 o; IFETCH2(o); pc += o; if (o < 0) BRANCHCHECKSWITCH;}
+    BRT "s16"	{ s16 o; u32 t; IFETCH2(o); POP(u32, t);
+		  if (t) pc += o; }
+    BRF "s16"	{ s16 o; u32 f; IFETCH2(o); POP(u32, f);
+		  if (!f) pc += o; }
+    CASE "case32"	{ s16 low, high, off; s32 v;
+    		  IFETCH2(low); 
+		  IFETCH2(high);
+		  POP(s32, v);
+		  v -= low; high -= low;
+		  if (v < 0 || v > high) v = high + 1;
+		  pc += v * 2;
+		  IFETCH2(off);
+		  pc += off;
+		  BRANCHCHECKSWITCH;
+		}
+    TRAPF ""	{ u32 t; POP(u32, t); if (!t) DEBUG("Assertion failure"); }
+    RETFAIL "u8"{ DEBUG("Return and fail"); }
+    LDSELF ""	{ PUSH(Object, op); }
+    LDSELFV ""	{ 
+		  PUSH(Object, op);
+#ifdef USEABCONS
+		  if (ISNIL(cp->d.type)) {
+		    PUSH(AbCon, findConCon(cp));
+		  } else {
+		    PUSH(AbCon, findAbCon(OIDOf(cp->d.type), OIDOf(cp)));
+		  }
+#else
+		  PUSH(ConcreteType, cp); 
+#endif
+		}
+    PUSHNIL ""  { PUSH(u32, 0x80000000); }
+    PUSHNILV ""  { PUSH(u32, 0x80000000); PUSH(u32, 0x80000000); }
+@ Throw away top of stack.
+    POOP      "" { u32 t; POP(u32, t); }
+@ general purpose escape to the system
+    SYS "u8u8"   {
+                  s32 rv, sysindex, ac;
+                  /* Fetch the operation and number of args from the
+		     instruction stream. */
+		  IFETCH1(sysindex);
+		  IFETCH1(ac);
+		  if (sysindex < 0 || sysindex >= JSYS_OPS) {
+		    sprintf(buf, "Illegal sys index %d (ac = %d)", 
+			    sysindex, ac);
+		    DEBUG(buf);
+		    continue;
+		  }
+		  /* Change the stack so the arguments are above the
+		     stack pointer. */
+		  sp -= (ac<<2);
+		  SYNCH();
+		  /* Call the actual code for the operation. */
+  		  rv = sysfuncs[sysindex](state);
+		  switch (rv) {
+		  case 0:
+		    UNSYNCH();
+		    break;
+		  case 1:
+		    return 1;
+		    break;
+		  case 0x1000:
+		    sprintf( buf, "exception in JSYS %d", sysindex );
+		    DEBUG( buf );
+		    break;
+		  default:
+		    assert(0);
+		    break;
+		  }
+		}
+@ Environment manipulation
+    GETENV ""	{
+		  PUSH(Object, ep);
+		  PUSH(ConcreteType, et);
+		}
+    SETENV ""	{
+		  POP(ConcreteType, et);
+		  POP(Object, ep);
+		}
+    STRI ""	{
+		  String s;
+		  s32 x;
+		  POP(String, s);
+		  CHECKNILS(s, "Nil in STRI");
+		  memmove(buf, s->d.data, s->d.items);
+		  buf[s->d.items] = '\0';
+		  x = mstrtol(buf, 0, 0);
+		  PUSH(s32, x);
+    		}
+    CREATEVECLIT "" {
+                      ConcreteType p;
+		      Vector o;
+		      unsigned n, e, est;
+		      int i;
+
+		      POP(unsigned, n);
+		      POP(ConcreteType, p);
+		      regRoot(p);
+		      F_SYNCH();
+		      o = CreateVector(p,n);
+		      F_UNSYNCH();
+		      unregRoot();
+		      for (i = n-1; i >= 0; i--) {
+			switch (p->d.instanceSize) {
+			case 1:
+			case -1:
+			  POP(u32, e);
+			  o->d.data[i] = e;
+			  break;
+			case -4:
+			case 4:
+			  POP(u32, e);
+			  *(s32 *)(&(o->d.data[i<<2])) = e;
+			  break;
+			case -8:
+			case 8:
+			  POP(u32, est);
+			  POP(u32, e);
+			  *(s32 *)(&(o->d.data[i<<3])) = e;
+			  *(s32 *)(&(o->d.data[(i<<3) + 4])) = est;
+			  break;
+			default:
+			  DEBUG("Bogus size of vector elements");
+			  goto nextInstruction;
+			  break;
+			}
+		      }
+		      PUSH(Vector, o);
+nextInstruction: ;
+		    }
+    STRHASH ""	{
+		  String s;
+		  u32 h = 0, g, i, l;
+		  POP(String, s);
+		  CHECKNILS(s, "Nil in STRHASH");
+		  l = s->d.items;
+		  for (i = 0; i < l; i++) {
+		    h = (h << 4) + s->d.data[i];
+		    if ((g = h & 0xf0000000)) {
+		      h = h ^ (g >> 24);
+		      h = h ^ g;
+		    }
+		  }
+		  h = h & 0x7fffffff;
+		  PUSH(u32, h);
+    		}
+@
+@ "Boring stuff" above this point.  "Research" starts here.
+@
+    BREAKME ""  {
+		  Object o;
+		  extern void breakObject(Object o);
+		  POP(Object, o);
+		  breakObject(o);
+		  if (o == op) DEBUG("Breakme executed");
+		}
+    FORWARD "" {
+	       SYNCH(); obsolete("FORWARD", state);
+               }
+    BREAKPT "" {
+		 DEBUG("Breakpoint");
+    	       }
+    UPB   ""     {
+                    Vector o1;
+		    POP(Vector,o1);
+		    CHECKNILV(o1, "Nil in UPB");
+		    PUSH(s32,o1->d.items-1);
+                  }
+    STRLIT ""  {
+                 Vector v;
+		 String o;
+		 u32 off, length;
+		 POP(u32, length);
+		 POP(u32, off);
+		 POP(Vector, v);
+		 CHECKNILV(v, "Nil in STRLIT");
+		 regRoot(v);
+		 F_SYNCH();
+		 o = (String)CreateVector(BuiltinInstCT(STRINGI),length);
+		 F_UNSYNCH();
+		 unregRoot();
+		 memmove(&o->d.data[0], &v->d.data[off], length);
+		 PUSH(String, o);
+	       }
+    LDINDS "u16" {
+                   Object o;
+
+		   POP(Object, o);
+		   CHECKNILO(o, "Nil invoked (LDINDS)");
+		   {
+		     LDS(FETCH(u32, (int) o, t));
+		   }
+		 }
+    LDVINDS "u16" {
+		   u32 v;
+		   POP(u32, v);
+		   CHECKNILU(v, "Nil invoked (LDVINDS)");
+		   {
+		     LDS(FETCH(u32,v,t));
+		     PF(v, t+4);
+		   }
+		 }
+    PUSHCT ""	{
+		  Object o;
+		  ConcreteType xct;
+		  TOP(Object, o);
+		  if (ISNIL(o)) {
+		    PUSH(ConcreteType, (ConcreteType)JNIL);
+		  } else {
+ 		    xct = CODEPTR(o->flags);
+		    assert(xct);
+#ifdef USEABCONS
+		    if (ISNIL(xct->d.type)) {
+		      PUSH(AbCon, findConCon(xct));
+		    } else {
+		      PUSH(AbCon, findAbCon(OIDOf(xct->d.type), OIDOf(xct)));
+		    }
+#else
+		    PUSH(ConcreteType, xct);
+#endif
+		  }
+		}
+    STRF ""	{
+		  String s;
+		  float x;
+		  POP(String, s);
+		  CHECKNILS(s, "Nil in STRF");
+		  memmove(buf, s->d.data, s->d.items);
+		  buf[s->d.items] = '\0';
+		  x = (float)atof(buf);
+		  PUSH(float, x);
+    		}
+    XCREATE ""	{
+                  ConcreteType p;
+		  Vector v;
+		  Object o;
+		  int i;
+		  OpVectorElement ove;
+
+		  POP(Vector, v);
+		  POP(ConcreteType, p);
+		  regRoot(v);
+		  regRoot(p);
+		  F_SYNCH();
+                  o = (Object) gc_malloc(sizeofObject + p->d.instanceSize);
+		  F_UNSYNCH();
+		  unregRoot();
+		  unregRoot();
+                  SETRESDNT(o->flags);
+                  SETCODEPTR(o->flags, p);
+		  if (inDistGC()) SETDISTGC(o->flags);
+		  PUSH(Object, o);
+		  ove = p->d.opVector->d.data[OVE_INITIALLY];
+		  /* I really should push the concrete type too, but this */
+		  /* would break where we use XCREATE for now */
+		  /* This currently leaves the stack unaligned (4 not 8) */
+		  /* PUSH(ConcreteType, p); */
+		  if (!ISNIL(ove)) {
+		    if (ove->d.nargs > 0 && 
+			(ISNIL(v) || ove->d.nargs < v->d.items)) {
+		      DEBUG("Not enough arguments to XCREATE");
+		      continue;
+		    }
+		    TRACE(initiallies, 1, ("Invoking initially of a %.*s",
+					   p->d.name->d.items,
+					   p->d.name->d.data));
+		    for (i = 0; i < ove->d.nargs; i++) {
+		      PUSH(u32, ((u32 *)v->d.data)[2 * i]);
+		      PUSH(u32, ((u32 *)v->d.data)[2 * i + 1]);
+		    }
+		    F_SYNCH();
+		    pushAR(state, o, p, OVE_INITIALLY);
+		    F_UNSYNCH();
+		  }
+	        }
+@ X Window escape
+    XSYS "u8u8"   {
+		    SYNCH(); obsolete("XSYS", state);
+		  }
+@ Concurrency stuff
+    MONINIT ""	{
+		  monitor *m = (monitor *)((Object) op)->d;
+		  m->busy = 0;
+		  m->waiting = 0;
+		}
+    MONENTER "" {
+		  monitor *m = (monitor *)((Object) op)->d;
+		  if (m->busy) {
+		    SYNCH();
+		    if (!m->waiting) m->waiting = SQueueCreate();
+		    SQueueInsert(m->waiting, state);
+		    TRACE(process, 3, ("Blocking process %x - monitor entry",
+				       state));
+		    return 1;
+		  } else {
+		    TRACE(process, 3, ("Monitor entry, no delay"));
+		    m->busy = 1;
+		  }
+		}
+    MONEXIT "" {
+		  monitor *m = (monitor *)((Object) op)->d;
+		  void *new;
+		  if ((new = (void*) SQueueRemove(m->waiting)) == NULL) {
+		    TRACE(process, 3, ("Monitor exit, no waiters"));
+		    m->busy = 0;
+		  } else {
+		    makeReady((State*) new);
+		    TRACE(process, 3, ("Unblocking process %x - monitor exit",
+			   new));
+		  }
+		}
+    CONDINIT ""	{
+		  /* containingop holds the object for this CV */
+		  int *fpintp = (int *)fp;
+		  Object o;
+		  condition *c;
+
+		  /* first fetch the saved fp from acondition.initially */
+		  fpintp = (int *)fpintp[-2];
+		  /* Now get the saved op from that frame */
+		  o = (Object) fpintp[-3];
+		  c = (condition *) ((Object) op)->d;
+		  c->o = o;
+		  c->waiting = 0;
+		}
+    CONDWAIT ""	{
+		  Object o;
+		  condition *c;
+		  monitor *m;
+		  void *s;
+
+		  POP(Object, o);
+		  CHECKNILO(o, "Nil in condition wait");
+		  c = (condition *)((Object) o)->d;
+		  if (c->o != op) {
+		    DEBUG("condition wait on foreign condition");
+		    continue;
+		  }
+		  SYNCH();
+		  if (!c->waiting) c->waiting = SQueueCreate();
+		  SQueueInsert(c->waiting, state);
+		  TRACE(process, 3, ("Blocking process %x - condition wait",
+				     state));
+		  m = (monitor *)c->o->d;
+		  if ((s = (void*) SQueueRemove(m->waiting)) != NULL) {
+		    state = (State*) s;
+		    TRACE(process, 3, ("Resuming process %x - monitor queue",
+				       state));
+		    UNSYNCH();
+		  } else {
+		    m->busy = 0;
+		    return 1;
+		  }
+		}
+    CONDSIGNAL "" {
+		  Object o;
+		  condition *c;
+		  monitor *m;
+		  void *s;
+		  POP(Object, o);
+		  CHECKNILO(o, "Nil in condition signal");
+		  c = (condition *)((Object) o)->d;
+		  if (c->o != op) {
+		    DEBUG("condition signal on foreign condition");
+		    continue;
+		  }
+		  m = (monitor *)c->o->d;
+		  if ((s = SQueueRemove(c->waiting)) != NULL) {
+		    SYNCH();
+		    TRACE(process, 3,
+			   ("Blocking process %x - condition signal", state));
+		    if (m->waiting == 0) m->waiting = SQueueCreate();
+		    SQueueInsertFront(m->waiting, state);
+		    state = (State*) s;
+		    TRACE(process, 3,
+			  ("Resuming process %x - condition signal", state));
+		    if (SQueueSize(c->waiting) == 0) {
+		      SQueueDestroy(c->waiting);
+		      c->waiting = 0;
+		    }
+		    UNSYNCH();
+		  } else {
+		    TRACE(process, 3, ("Signal, but no waiters"));
+		  }
+		}
+    CONDAWAITING "" {
+		  Object o;
+		  u32 nwaiters;
+		  condition *c;
+		  POP(Object, o);
+		  CHECKNILO(o, "Nil in condition awaiting");
+		  c = (condition *)((Object) o)->d;
+		  if (c->o != op) {
+		    DEBUG("condition awaiting on foreign condition");
+		    continue;
+		  }
+		  nwaiters = SQueueSize(c->waiting);
+		  PUSH(u32, nwaiters);
+		}
+    DOLITERALS "" {
+		    Code c;
+		    POP(Code, c);
+		    SYNCH(); obsolete("DOLITERALS", state);
+		  }
+    INSTALLINOID "" {
+		    Object o;
+		    u32 seq;
+		    POP(Object, o);
+		    POP(u32, seq);
+		    OIDInsertFromSeq(seq, o);
+		  }
+    GETROOTDIR "" {
+		    char *buf;
+		    String s;
+		    buf = getenv("EMERALDROOT");
+		    if (buf == NULL) buf = EMERALDROOT;
+		    F_SYNCH();
+		    s = CreateString(buf);
+		    F_UNSYNCH();
+		    PUSH(String, s);
+		  }
+    CHECKPOINT "" {
+		    Object o;
+		    ConcreteType ct;
+		    String filename;
+
+		    POP(ConcreteType, ct);	  /* String's CT - ignore */
+		    POP(String, filename);
+#ifdef USEABCONS
+		    {
+		      AbCon abcon;
+		      POP(AbCon, abcon);
+		      ct = abcon->d.con;
+		    }
+#else
+		    POP(ConcreteType, ct);
+#endif
+		    POP(Object, o);
+		    CHECKNILO(o, "Nil in checkpoint");
+		    CheckpointToFile(o, ct, filename);
+		  }
+@ X Window escape --- could block the caller
+    BXSYS "u8u8"   {
+		     SYNCH(); obsolete("BXSYS", state);
+		   }
+    GCOLLECT "" {
+		  {
+		    extern void startDistGC(void);
+		    gcollect();
+		    gcollect_old();
+		    startDistGC();
+		  }
+		}
+    LAND ""     { BINARY(s32,&) }
+    LOR  ""     { BINARY(s32,|) }
+    LSETBIT ""  { 
+		  u32 a, b, v;
+		  POP(u32, v);
+		  POP(u32, b);
+		  TOP(u32, a);
+		  if (v) {
+		    a = a | (1 << (32 - b - 1));
+		  } else {
+		    a = a & ~(1 << (32 - b - 1));
+		  }
+		  SETTOP(u32, a);
+		}
+    LGETBIT ""  {
+		  u32 a, b;
+		  POP(u32, b);
+		  TOP(u32, a);
+		  SETTOP(u32, (a & (1 << (32 - b - 1))) ? 1 : 0);
+		}
+    CALCSIZE "" {
+		  SYNCH(); obsolete("CALCSIZE", state);
+	        }
+    IABS ""     { s32 a;
+		  TOP(s32, a);
+		  SETTOP(s32, ISNIL(a) ? 0 : a < 0 ? -a : a);
+		}
+@ Calloids finds the target object on the stack, and the operation oid as an
+@ immediate operand (2 bytes)
+    CALLOIDS "u16"	{
+		  IFETCH2(opoid);
+		  goto restofcalloid;
+		}
+    CALLSTAR "" {
+		  SYNCH(); obsolete("CALLSTAR", state);
+		}
+    CALLSTARCLEAN "" {
+		       SYNCH(); obsolete("CALLSTARCLEAN", state);
+		     }
+    CONFORMS "" {
+		  AbstractType a, b;
+		  POP(AbstractType, b);
+		  POP(AbstractType, a);
+		  CHECKNIL(AbstractType, a, "Nil a in conforms");
+		  CHECKNIL(AbstractType, b, "Nil b in conforms");
+		  PUSH(u32, conforms(a, b));
+		}
+
+    DSTR ""     { 
+		  u32 secs;
+		  String s, timeToDate(int);
+		  POP(u32, secs);
+		  F_SYNCH();
+		  s = timeToDate(secs);
+		  F_UNSYNCH();
+		  PUSH(String, s);
+		}
+    DLOAD ""	{
+		  String s;
+		  POP(String, s);
+		  CHECKNILS(s, "Nil in DLOAD");
+		  loadNGo(s);
+		}
+    RELOCATEVECTOR ""	{
+		  u32 id, i;
+		  ATTypeVector v;
+		  POP(u32, id);
+		  POP(u32, i);
+		  POP(ATTypeVector, v);
+		  fixObjectReferenceFromSeq(id, (Object)v, OffsetOf(v, &v->d.data[i]));
+		}
+    RELOCATETYPE ""	{
+		  u32 id;
+		  ConcreteType xct;
+		  POP(u32, id);
+		  POP(ConcreteType, xct);
+		  fixObjectReferenceFromSeq(id, (Object)xct, OffsetOf(xct, &xct->d.type));
+		}
+@ STUBCALL and STUBRETURN are obsolete opcodes from an old attempt at
+@ remote invocation  -bwe
+    STUBCALL "" {
+                   SYNCH(); obsolete("STUBCALL", state);
+		 }
+   STUBRETURN "" {
+                   SYNCH(); obsolete("STUBRETURN", state);
+                 }
+@GETOID returns three integers: the ipaddress, the incarnation (port and epoch), and the seq
+@ of the OID of the argument object.  If the 
+@ argument object doesn't yet have an OID it is assigned one.
+   GETOID     "" {
+                    OID theOID;
+		    Object obj; ConcreteType ct;
+
+		    POP(ConcreteType, ct);
+		    POP(Object, obj);
+		    if (HASODP(ct->d.instanceFlags)) {
+		      if (!HASOID(obj->flags)) {
+			NewOID(&theOID);
+			UpdateOIDTables(theOID, obj);
+		      } else {
+			theOID = OIDOf(obj);
+		      }
+		    } else {
+		      theOID.ipaddress = 0xffffffff;
+		      theOID.port = 0xffff;
+		      theOID.epoch = 0xffff;
+		      theOID.Seq = (Bits32)obj;
+		    }
+		    PUSH(u32, theOID.ipaddress);
+		    PUSH(ConcreteType, intct);
+		    PUSH(u32, (theOID.port << 16 | theOID.epoch));
+		    PUSH(ConcreteType, intct);
+		    PUSH(u32, theOID.Seq);
+		    PUSH(ConcreteType, intct);
+		  }
+@ TESTREMOTE is an obsolete opcode in the same way as STUB* above
+  TESTREMOTE "" {
+                  SYNCH(); obsolete("TESTREMOTE", state);
+		}
+    GETIDSEQ ""	{
+		  OID oid;
+		  Object o;
+		  POP(Object, o);
+		  CHECKNILO(o, "Nil in GETIDSEQ");
+		  oid = OIDOf(o);
+		  if (isNoOID(oid)) {
+		    /* Merge: This is wrong - look at GETOID. */
+		    NewOID(&oid);
+		    OIDInsert(oid, o);
+		  }
+		  PUSH(u32, oid.Seq);
+		}
+@ general purpose escape to the system
+    CCALL "u8"  {
+		  SYNCH(); obsolete("CCALL", state);
+		}
+    LDLITB "u8"	{ 
+      		  u8 t;
+		  IFETCH1(t);
+		  PUSH(Object, cp->d.literals->d.data[t].ptr);
+		}
+
+    SWAPV  ""    { u32 ad, at, bd, bt; 
+		   POP(u32, at); 
+		   POP(u32, ad); 
+		   POP(u32, bt);
+		   POP(u32, bd);
+		   PUSH(u32, ad);
+		   PUSH(u32, at);
+		   PUSH(u32, bd);
+		   PUSH(u32, bt);
+		 }
+    DOCTLITERALS "" {
+		    ConcreteType c;
+		    POP(ConcreteType, c);
+		    /* fix the literals in c */
+		    TRACE(trans, 1, ("Fixing literals in %#x (OID %#x) a %.*s",
+				     c, OIDSeqOf((Object)c), 
+				     c->d.name->d.items, c->d.name->d.data));
+		    fixCTLiterals(c);
+		  }
+    CVX "u8" {
+      u32 n, i;
+      u32 *tsp;
+      IFETCH1(n);
+      tsp = (u32 *) sp - 2 * n;
+      for (i = 1; i < n; i++) {
+	tsp[i] = tsp[2 * i];
+      }
+      sp -= 4 * n;
+    }
+
+    TESTREMOTE2 "" {
+      SYNCH(); obsolete("TESTREMOTE2", state);
+    }
+  
+    CODEOF "" {
+#ifdef USEABCONS
+      AbCon abcon;
+      Object o;
+      POP(AbCon, abcon);
+      POP(Object, o);
+      if (ISNIL(o)) {
+	PUSH(ConcreteType, BuiltinInstCT(NILI));
+      } else {
+	PUSH(ConcreteType, abcon->d.con);
+      }
+#else
+      ConcreteType ct;
+      Object o;
+      POP(ConcreteType, ct);
+      POP(Object, o);
+      if (ISNIL(o)) {
+	PUSH(ConcreteType, BuiltinInstCT(NILI));
+      } else {
+	PUSH(ConcreteType, ct);
+      }
+#endif
+    }
+
+    BUILDABCON "" {
+#ifdef USEABCONS
+      ConcreteType con;
+      AbstractType ab;
+      AbCon abcon;
+      POP(ConcreteType, con);
+      POP(AbstractType, ab);
+      abcon = findAbCon(OIDOf(ab), OIDOf(con));
+      PUSH(AbCon, abcon);
+#else
+      assert(0);
+#endif
+    }
+
+    CHECKARGABCONB "u8" {
+#ifdef USEABCONS
+      AbstractType ab;
+      AbCon *abcon;
+      u8 t;
+      IFETCH1(t);
+      abcon = (AbCon *)(fp - (8 * t) + ARGOFF + 4);
+      POP(AbstractType, ab);
+      verifyAbCon(abcon, ab);
+#else
+      SYNCH(); obsolete("CHECKARGABCONB", state);
+#endif
+    }
+
+@ Calls finds the target object on the stack, and the operation number as an
+@ immediate operand.  Calls is used only with abcons.
+    CALLS "u16"	{
+#ifndef USEABCONS
+      assert(0);
+#else
+      assert(0);
+#endif /* USEABCONS */
+    }
+
+@ Callct finds the target object on the stack, and the operation index as an
+@ immediate operand.  This assumes we know the CT of the target.
+    CALLCTB "u8" {
+      int opindex;
+      ConcreteType a;
+      Object o;
+
+      IFETCH1(opindex);
+      POP(ConcreteType, a);
+      POP(Object, o);
+      SYNCH();
+      if (invoke(o, a, opindex, state)) {
+	return 1;
+      } else {
+	UNSYNCH();
+	INVOKECHECKSWITCH;
+      }
+    }	        
+
+    CONDSIGNALANDEXIT "u8" {
+		  Object o;
+		  u8 nargs;
+		  condition *c;
+		  void *new;
+		  ConcreteType xcp;
+
+		  IFETCH1(nargs);
+		  POP(Object, o);
+		  CHECKNILO(o, "Nil in condition signal");
+		  c = (condition *)((Object) o)->d;
+		  if (c->o != op) {
+		    DEBUG("condition signal on foreign condition");
+		    continue;
+		  }
+		  if ((new = SQueueRemove(c->waiting)) != NULL) {
+		    makeReady((State*)new);
+		    TRACE(process, 3,
+			  ("Unblocking process %x - condition signalandexit",
+			   new));
+		    if (SQueueSize(c->waiting) == 0) {
+		      SQueueDestroy(c->waiting);
+		      c->waiting = 0;
+		    }
+		    xcp = cp;
+		    sp = fp;
+		    POP(u32, pc);
+		    POP(u32, fp);
+		    POP(Object, op);
+		    POP(ConcreteType, cp);
+		    IFTRACE(call, 1) {
+		      doret(fp, sb, pc, xcp);
+		    }
+		    sp -= (nargs * 2 * sizeof(u32));
+		    PROFILERET();
+		  } else {
+		    TRACE(process, 3, ("Condition signal and exit, no waiters"));
+		  }
+		}
+    LSETBITS ""  { 
+		  u32 a, o, l, v, m = -1L;
+		  POP(u32, v);
+		  POP(u32, l);
+		  POP(u32, o);
+		  TOP(u32, a);
+		  m = m << (32 - l);
+		  m = m >> (o);
+		  a = (a & ~m) | (m & (v << (32 - o - l)));
+		  SETTOP(u32, a);
+		}
+    LGETBITS ""  {
+		  u32 a, o, l;
+		  POP(u32, l);
+		  POP(u32, o);
+		  TOP(u32, a);
+		  SETTOP(u32, ((a << o) >> (32 - l)));
+		}
+    VIEW "" {
+      AbstractType desired;
+      ConcreteType ct;
+      Object o;
+#ifdef USEABCONS
+      AbCon abcon;
+#endif
+      POP(AbstractType, desired);
+#ifdef USEABCONS
+      POP(AbCon, abcon);
+      TOP(Object, o);
+      if (!ISNIL(o)) {
+	ct = abcon->d.con;
+      }
+#else
+      POP(ConcreteType, ct);
+      TOP(Object, o);
+#endif
+      if (ISNIL(o) || conforms(ct->d.type, desired)) {
+	/* Everything is fine. */
+      } else {
+	DEBUG("View failure");
+      }
+#ifdef USEABCONS
+      PUSH(AbCon, ISNIL(o) ? (AbCon)JNIL : findAbCon(OIDOf(desired), OIDOf(ct)));
+#else
+      PUSH(ConcreteType, ct);
+#endif
+    }
+@ doesn't handle abcons -brian[0]
+    CALLER "" {
+      int *fpintp = (int*) fp;
+      Object o = (Object) fpintp[-3];
+      ConcreteType ct = (ConcreteType) fpintp[-4];
+      PUSH( Object, o );
+      PUSH( ConcreteType, ct );
+    }
+    INDIR "" {
+      u32 v;
+      POP(u32, v);
+      PF(v, 0);
+    }
+    INDIRV "" {
+      u32 v;
+      POP(u32, v); /* The first one is the concrete type, which we ignore */
+      POP(u32, v);
+      PF(v, 0);
+      PF(v, 4);
+    }
+    GETISTATE "" {
+      ConcreteType p = BuiltinInstCT(INTERPRETERSTATEI);
+      InterpreterState o;
+      F_SYNCH();
+      regRoot(p);
+      o = (InterpreterState) gc_malloc(sizeofObject + p->d.instanceSize);
+      F_UNSYNCH();
+      unregRoot();
+      *o = *state;
+      o->firstThing = RESDNTBIT;
+      SETCODEPTR(o->firstThing, p);
+      if (inDistGC()) SETDISTGC(o->firstThing);
+      PUSH( InterpreterState, o );
+    }
+    STRTOK "" {
+      String s, me;
+      int start, end;
+      POP(String, s);
+      POP(String, me);
+      CHECKNILS(s, "Nil string in String.token");
+      CHECKNILS(me, "Nil invoked in String.token");
+      stringTok(me, s, &start, &end);
+      if (start >= me->d.items) {
+	PUSH(String, (String)JNIL);
+	PUSH(String, (String)JNIL);
+      } else {
+	regRoot(me);
+	F_SYNCH();
+	s = (String)CreateVector(BuiltinInstCT(STRINGI), end - start);
+	F_UNSYNCH();
+	memmove(&s->d.data[0], &me->d.data[start], end - start);
+	PUSH(String, s);
+	if (me->d.items <= end) {
+	  s = (String)JNIL;
+	} else {
+	  F_SYNCH();
+	  s = (String)CreateVector(BuiltinInstCT(STRINGI), me->d.items - end);
+	  F_UNSYNCH();
+	  memmove(&s->d.data[0], &me->d.data[end], me->d.items - end);
+	}
+	PUSH(String, s);
+	unregRoot();
+      }
+    }
+    ADJSP "u16" {
+      u16 space;
+      IFETCH2(space);
+      sp = fp + space;
+    }
+    LSECS "u32" {
+      struct tm tm;
+      s32 res;
+      POP(u32, tm.tm_sec);
+      POP(u32, tm.tm_min);
+      POP(u32, tm.tm_hour);
+      POP(u32, tm.tm_mday);
+      POP(u32, tm.tm_mon);
+      POP(u32, tm.tm_year);
+      tm.tm_isdst = -1;
+      tm.tm_year -= 1900;
+      res = mktime(&tm);
+      if (res < 0) DEBUG("Invalid time");
+      PUSH(u32, res);
+    }
+      
+    CREATEGAGGLE "" {
+      Object manager;
+      ConcreteType xxx;
+
+      POP(ConcreteType, xxx);
+      POP(Object, manager);
+#ifdef DISTRIBUTED
+      {
+	OID oid = OIDOf(manager);
+	if (isNoOID(oid)) {
+	  NewOID(&oid);
+	  UpdateOIDTables(oid, manager);
+	}
+	createGaggle(oid);
+      }
+#endif
+    }
+    ADDTOGAGGLE "" {
+      Object manager, newobject;
+      ConcreteType xxx, oct;
+        
+      POP(ConcreteType, oct);
+      POP(Object, newobject);
+      POP(ConcreteType, xxx);
+      POP(Object, manager);
+      
+#ifdef DISTRIBUTED
+      {
+	OID moid, ooid;
+
+	moid = OIDOf(manager);
+	assert(!isNoOID(moid));
+	ooid = OIDOf(newobject);
+	if (isNoOID(ooid)) {
+	  NewOID(&ooid);
+	  UpdateOIDTables(ooid, newobject);
+	}
+	add_gmember(moid, ooid);
+	sendGaggleUpdate(moid, ooid, OIDOf(oct), 0);
+      }
+#endif
+    }
+    
+    GETGAGGLEMEMBER "" {
+      Object manager;
+      ConcreteType xxx;
+
+      POP(ConcreteType, xxx);
+      POP(Object, manager);
+#ifdef DISTRIBUTED
+      {
+	Object member;
+	OID moid, ooid, get_gmember(OID);
+
+	moid = OIDOf(manager);
+	assert(!isNoOID(moid));
+	ooid = get_gmember(moid);
+	if (isNoOID(ooid)){
+	  PUSH(Object, (Object)JNIL);
+	  PUSH(ConcreteType, (ConcreteType)JNIL);
+	} else{
+	  member = OIDFetch(ooid);
+	  PUSH(Object, member);
+	  PUSH(ConcreteType, CODEPTR(member->flags));
+	}
+      }
+#else
+      PUSH(Object, (Object)JNIL);
+      PUSH(ConcreteType, (ConcreteType)JNIL);
+#endif
+    }
+    GETGAGGLEELEMENT "" {
+      Object manager;
+      u32 index;
+      ConcreteType xxx;
+
+      POP(ConcreteType, xxx);
+      POP(u32, index);
+      POP(ConcreteType, xxx);
+      POP(Object, manager);
+#ifdef DISTRIBUTED
+      {
+	OID moid, ooid, get_gelement(OID, int);
+	Object member;
+	moid = OIDOf(manager);
+	assert(!isNoOID(moid));
+	ooid = get_gelement(moid, index);
+	if (isNoOID(ooid)){
+	  PUSH(Object, (Object)JNIL);
+	  PUSH(ConcreteType, (ConcreteType)JNIL);
+	}
+	else{
+	  member = OIDFetch(ooid);
+	  PUSH(Object, member);
+	  PUSH(ConcreteType, CODEPTR(member->flags));
+	}
+      }
+#else
+      PUSH(Object, (Object)JNIL);
+      PUSH(ConcreteType, (ConcreteType)JNIL);
+#endif
+    }
+    GETGAGGLESIZE "" {
+      Object manager;
+      ConcreteType xxx;
+
+      POP(ConcreteType, xxx);
+      POP(Object, manager);
+#ifdef DISTRIBUTED
+      {
+	OID moid;
+	u32 size, get_gsize(OID);
+
+	moid = OIDOf(manager);
+	if (isNoOID(moid)) {
+	  size = 0;
+	} else {
+	  size = get_gsize(moid);
+	}
+	PUSH(u32, size);
+	PUSH(ConcreteType, intct);
+      }
+#else
+      PUSH(u32, 0);
+      PUSH(ConcreteType, intct);
+#endif
+    }
+@ EOF
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/write.c ubc-1.05alpha-src/vm/src/write.c
--- sourceforge-1.06alpha/vm/src/write.c	2017-12-11 17:59:03.093714455 +0100
+++ ubc-1.05alpha-src/vm/src/write.c	2017-12-11 17:59:03.430711886 +0100
@@ -248,7 +226,7 @@
 {
   assert(ct);
 
-  if ((unsigned int) ct < NUMBUILTINS) {
+  if ((int) ct < NUMBUILTINS) {
     assert(0);
     return sizeofObject;
   } else if (ct->d.instanceSize >= 0) {
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/xdr_float.c ubc-1.05alpha-src/vm/src/xdr_float.c
--- sourceforge-1.06alpha/vm/src/xdr_float.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/xdr_float.c	2017-12-11 17:59:03.430711886 +0100
@@ -0,0 +1,283 @@
+/*
+ * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
+ * unrestricted use provided that this legend is included on all tape
+ * media and as a part of the software program in whole or part.  Users
+ * may copy or modify Sun RPC without charge, but are not authorized
+ * to license or distribute it to anyone else except as part of a product or
+ * program developed by the user.
+ *
+ * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
+ * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
+ *
+ * Sun RPC is provided with no support and without any obligation on the
+ * part of Sun Microsystems, Inc. to assist in its use, correction,
+ * modification or enhancement.
+ *
+ * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
+ * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
+ * OR ANY PART THEREOF.
+ *
+ * In no event will Sun Microsystems, Inc. be liable for any lost revenue
+ * or profits or other special, indirect and consequential damages, even if
+ * Sun has been advised of the possibility of such damages.
+ *
+ * Sun Microsystems, Inc.
+ * 2550 Garcia Avenue
+ * Mountain View, California  94043
+ */
+
+#if defined(LIBC_SCCS) && !defined(lint)
+/*static char *sccsid = "from: @(#)xdr_float.c 1.12 87/08/11 Copyr 1984 Sun Micro";*/
+/*static char *sccsid = "from: @(#)xdr_float.c	2.1 88/07/29 4.0 RPCSRC";*/
+static char *rcsid = "$Id: xdr_float.c,v 1.1 1997/01/21 23:59:53 norm Exp norm $";
+#endif
+
+/*
+ * xdr_float.c, Generic XDR routines impelmentation.
+ *
+ * Copyright (C) 1984, Sun Microsystems, Inc.
+ *
+ * These are the "floating point" xdr routines used to (de)serialize
+ * most common data items.  See xdr.h for more info on the interface to
+ * xdr.
+ */
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/param.h>
+#include <rpc/types.h>
+#include <rpc/xdr.h>
+
+/*
+ * NB: Not portable.
+ * This routine works on Suns (Sky / 68000's), i386's, MIPS, NS32k and Vaxen.
+ */
+
+#if defined(mc68000)||defined(sparc)||defined(i386)||defined(mips)||defined(ns32000)
+#define IEEEFP
+#endif
+
+#ifdef vax
+
+/* What IEEE single precision floating point looks like on a Vax */
+struct	ieee_single {
+	unsigned int	mantissa: 23;
+	unsigned int	exp     : 8;
+	unsigned int	sign    : 1;
+};
+
+/* Vax single precision floating point */
+struct	vax_single {
+	unsigned int	mantissa1 : 7;
+	unsigned int	exp       : 8;
+	unsigned int	sign      : 1;
+	unsigned int	mantissa2 : 16;
+};
+
+#define VAX_SNG_BIAS	0x81
+#define IEEE_SNG_BIAS	0x7f
+
+static struct sgl_limits {
+	struct vax_single s;
+	struct ieee_single ieee;
+} sgl_limits[2] = {
+	{{ 0x7f, 0xff, 0x0, 0xffff },	/* Max Vax */
+	{ 0x0, 0xff, 0x0 }},		/* Max IEEE */
+	{{ 0x0, 0x0, 0x0, 0x0 },	/* Min Vax */
+	{ 0x0, 0x0, 0x0 }}		/* Min IEEE */
+};
+#endif /* vax */
+
+bool_t
+xdr_float(xdrs, fp)
+	register XDR *xdrs;
+	register float *fp;
+{
+#ifndef IEEEFP
+	struct ieee_single is;
+	struct vax_single vs, *vsp;
+	struct sgl_limits *lim;
+	int i;
+#endif
+	switch (xdrs->x_op) {
+
+	case XDR_ENCODE:
+#ifdef IEEEFP
+		return (XDR_PUTLONG(xdrs, (long *)fp));
+#else
+		vs = *((struct vax_single *)fp);
+		for (i = 0, lim = sgl_limits;
+			i < sizeof(sgl_limits)/sizeof(struct sgl_limits);
+			i++, lim++) {
+			if ((vs.mantissa2 == lim->s.mantissa2) &&
+				(vs.exp == lim->s.exp) &&
+				(vs.mantissa1 == lim->s.mantissa1)) {
+				is = lim->ieee;
+				goto shipit;
+			}
+		}
+		is.exp = vs.exp - VAX_SNG_BIAS + IEEE_SNG_BIAS;
+		is.mantissa = (vs.mantissa1 << 16) | vs.mantissa2;
+	shipit:
+		is.sign = vs.sign;
+		return (XDR_PUTLONG(xdrs, (long *)&is));
+#endif
+
+	case XDR_DECODE:
+#ifdef IEEEFP
+		return (XDR_GETLONG(xdrs, (long *)fp));
+#else
+		vsp = (struct vax_single *)fp;
+		if (!XDR_GETLONG(xdrs, (long *)&is))
+			return (FALSE);
+		for (i = 0, lim = sgl_limits;
+			i < sizeof(sgl_limits)/sizeof(struct sgl_limits);
+			i++, lim++) {
+			if ((is.exp == lim->ieee.exp) &&
+				(is.mantissa == lim->ieee.mantissa)) {
+				*vsp = lim->s;
+				goto doneit;
+			}
+		}
+		vsp->exp = is.exp - IEEE_SNG_BIAS + VAX_SNG_BIAS;
+		vsp->mantissa2 = is.mantissa;
+		vsp->mantissa1 = (is.mantissa >> 16);
+	doneit:
+		vsp->sign = is.sign;
+		return (TRUE);
+#endif
+
+	case XDR_FREE:
+		return (TRUE);
+	}
+	return (FALSE);
+}
+
+/*
+ * This routine works on Suns (Sky / 68000's), i386's, MIPS and Vaxen.
+ */
+
+#ifdef vax
+/* What IEEE double precision floating point looks like on a Vax */
+struct	ieee_double {
+	unsigned int	mantissa1 : 20;
+	unsigned int	exp       : 11;
+	unsigned int	sign      : 1;
+	unsigned int	mantissa2 : 32;
+};
+
+/* Vax double precision floating point */
+struct  vax_double {
+	unsigned int	mantissa1 : 7;
+	unsigned int	exp       : 8;
+	unsigned int	sign      : 1;
+	unsigned int	mantissa2 : 16;
+	unsigned int	mantissa3 : 16;
+	unsigned int	mantissa4 : 16;
+};
+
+#define VAX_DBL_BIAS	0x81
+#define IEEE_DBL_BIAS	0x3ff
+#define MASK(nbits)	((1 << nbits) - 1)
+
+static struct dbl_limits {
+	struct	vax_double d;
+	struct	ieee_double ieee;
+} dbl_limits[2] = {
+	{{ 0x7f, 0xff, 0x0, 0xffff, 0xffff, 0xffff },	/* Max Vax */
+	{ 0x0, 0x7ff, 0x0, 0x0 }},			/* Max IEEE */
+	{{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},		/* Min Vax */
+	{ 0x0, 0x0, 0x0, 0x0 }}				/* Min IEEE */
+};
+
+#endif /* vax */
+
+
+bool_t
+xdr_double(xdrs, dp)
+	register XDR *xdrs;
+	double *dp;
+{
+	register long *lp;
+#ifndef IEEEFP
+	struct	ieee_double id;
+	struct	vax_double vd;
+	register struct dbl_limits *lim;
+	int i;
+#endif
+
+	switch (xdrs->x_op) {
+
+	case XDR_ENCODE:
+#ifdef IEEEFP
+		lp = (long *)dp;
+#if BYTE_ORDER == BIG_ENDIAN
+		return (XDR_PUTLONG(xdrs, lp++) && XDR_PUTLONG(xdrs, lp));
+#else
+		return (XDR_PUTLONG(xdrs, lp+1) && XDR_PUTLONG(xdrs, lp));
+#endif
+#else
+		vd = *((struct vax_double *)dp);
+		for (i = 0, lim = dbl_limits;
+			i < sizeof(dbl_limits)/sizeof(struct dbl_limits);
+			i++, lim++) {
+			if ((vd.mantissa4 == lim->d.mantissa4) &&
+				(vd.mantissa3 == lim->d.mantissa3) &&
+				(vd.mantissa2 == lim->d.mantissa2) &&
+				(vd.mantissa1 == lim->d.mantissa1) &&
+				(vd.exp == lim->d.exp)) {
+				id = lim->ieee;
+				goto shipit;
+			}
+		}
+		id.exp = vd.exp - VAX_DBL_BIAS + IEEE_DBL_BIAS;
+		id.mantissa1 = (vd.mantissa1 << 13) | (vd.mantissa2 >> 3);
+		id.mantissa2 = ((vd.mantissa2 & MASK(3)) << 29) |
+				(vd.mantissa3 << 13) |
+				((vd.mantissa4 >> 3) & MASK(13));
+	shipit:
+		id.sign = vd.sign;
+		lp = (long *)&id;
+		return (XDR_PUTLONG(xdrs, lp++) && XDR_PUTLONG(xdrs, lp));
+#endif
+
+	case XDR_DECODE:
+#ifdef IEEEFP
+		lp = (long *)dp;
+#if BYTE_ORDER == BIG_ENDIAN
+		return (XDR_GETLONG(xdrs, lp++) && XDR_GETLONG(xdrs, lp));
+#else
+		return (XDR_GETLONG(xdrs, lp+1) && XDR_GETLONG(xdrs, lp));
+#endif
+#else
+		lp = (long *)&id;
+		if (!XDR_GETLONG(xdrs, lp++) || !XDR_GETLONG(xdrs, lp))
+			return (FALSE);
+		for (i = 0, lim = dbl_limits;
+			i < sizeof(dbl_limits)/sizeof(struct dbl_limits);
+			i++, lim++) {
+			if ((id.mantissa2 == lim->ieee.mantissa2) &&
+				(id.mantissa1 == lim->ieee.mantissa1) &&
+				(id.exp == lim->ieee.exp)) {
+				vd = lim->d;
+				goto doneit;
+			}
+		}
+		vd.exp = id.exp - IEEE_DBL_BIAS + VAX_DBL_BIAS;
+		vd.mantissa1 = (id.mantissa1 >> 13);
+		vd.mantissa2 = ((id.mantissa1 & MASK(13)) << 3) |
+				(id.mantissa2 >> 29);
+		vd.mantissa3 = (id.mantissa2 >> 13);
+		vd.mantissa4 = (id.mantissa2 << 3);
+	doneit:
+		vd.sign = id.sign;
+		*dp = *((double *)&vd);
+		return (TRUE);
+#endif
+
+	case XDR_FREE:
+		return (TRUE);
+	}
+	return (FALSE);
+}
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/xsys.c ubc-1.05alpha-src/vm/src/xsys.c
--- sourceforge-1.06alpha/vm/src/xsys.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-1.05alpha-src/vm/src/xsys.c	2017-12-11 17:59:03.430711886 +0100
@@ -0,0 +1,533 @@
+/* comment me!
+ */
+
+#ifdef XWindows
+#include "vm_exp.h"
+#include "assert.h"
+#include "misc.h"
+#include "sisc.h"
+
+#include <sys/file.h>
+#include <sys/time.h>
+#include <errno.h>
+
+
+#undef True
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+
+static Display *display;
+
+XWMHints xwmh={
+    (InputHint|StateHint),
+    True,
+    NormalState,
+    0,
+    0,
+    0,0,
+    0,
+    0
+  };
+
+static  unsigned long black,white;
+
+/* Macro to convert a String to a char *. */
+#define JTOCString(js, cs) { \
+			       (cs) = malloc((js)->d.items + 1); \
+			       bcopy((js)->d.data, (cs), \
+				     (js)->d.items); \
+			       (cs)[(js)->d.items] = '\0'; \
+			   }
+
+static XEvent *waitingEvent;
+static State *waitingState;
+
+void *XCreateDisplay(es)
+String es;
+{
+
+  if (es == (String)JNIL) {
+    display = XOpenDisplay("");
+  } else {
+    char *s;
+    JTOCString(es, s);
+    display = XOpenDisplay(s);
+    free(s);
+  }
+  if (display == NULL) {
+    TRACE0(x, 0, "Cannot initialize display");
+    exit(1);
+  } 
+  black = BlackPixel(display,DefaultScreen(display));
+  white = WhitePixel(display,DefaultScreen(display));
+}
+
+static int tryRead(XEvent *ev)
+{
+  if (XPending(display) > 0) {
+    TRACE0(x, 5, "XEvent: calling NextEvent");
+    XNextEvent(display, ev);
+    TRACE0(x, 5, "XEvent: NextEvent returned");
+    TRACE5(x, 5, "event = (%d %d %d %d %d)", 
+      *(0 + (int *)ev),
+      *(1 + (int *)ev),
+      *(2 + (int *)ev),
+      *(3 + (int *)ev),
+      *(4 + (int *)ev));
+    return 1;
+  } else {
+/*     XSync(display, False); */
+    return 0;
+  }
+}
+
+/**********************************************************************/
+/*      EMXReadEvent                                                    */
+/**********************************************************************/
+/* Kernel Call */
+int EMXReadEvent(u32 sp)
+{
+  Bitchunk                      event;
+  XEvent			* ev;
+
+  TRACE0(x, 3, "EMXReadEvent");
+
+  event = *(Bitchunk *)sp;
+  if (ISNIL(event)) {
+    TRACE0(x, 0, "Event is NIL in EMXReadEvent.");
+    return 0;
+  }
+
+  /* Check the size of the Bitchunk */
+  if (event->d.items < sizeof(XEvent)) {
+    TRACE2(x, 2, "Read attempt with a too small Bitchunk: %d should be %d.",
+      event->d.items, sizeof(XEvent));
+    return 0;
+  }
+
+  /* Check for a display */
+  if (!display) {
+    TRACE0(x, 1, "Read attempt with no display (= nil).");
+    return 0;
+  }
+
+  ev = (XEvent *)&event->d.data[0];
+#ifdef RTTHREADS
+  RttBeginCritical();
+#endif
+  if (tryRead(ev)) {
+#ifdef RTTHREADS
+    RttEndCritical();
+#endif
+  } else {
+    do {
+#ifdef RTTHREADS
+      RttEndCritical();
+#endif
+      vmRead(ConnectionNumber(display), 0, 0);
+#ifdef RTTHREADS
+      RttBeginCritical();
+#endif
+    } while (tryRead(ev) == 0);
+  }
+  return 0;
+}
+
+int EMXCreateWindow(sp)
+long *sp;
+{
+  int x = sp[0], y = sp[1], w = sp[2], h = sp[3];
+  String name = (String) sp[4];
+  Window window;
+  XSizeHints xsh;
+  XEvent event;
+  char *cname;
+
+  sp[0] = (long) JNIL;
+
+  if (display == NULL) {
+    TRACE0(x, 1, "Create window called with no display");
+    return 1;
+  }
+
+  JTOCString(name, cname);
+  TRACE1(x, 3, "Create window named %s", cname);
+
+  xsh.x = x;
+  xsh.y = y;
+  xsh.width = w;
+  xsh.height = h;
+  xsh.flags = (USPosition|USSize); 
+
+  TRACE4(x, 3, "Create window at (%d, %d) size (%d, %d)",
+    xsh.x, xsh.y, xsh.width, xsh.height);
+  window = XCreateSimpleWindow(display, DefaultRootWindow(display), xsh.x,
+			       xsh.y, xsh.width, xsh.height, 1, black, white);
+  TRACE1(x, 3, "XCreateWindow returns %d", window);
+  XSetStandardProperties(display,window,cname,cname,None,NULL,0,&xsh);
+/*  XSetWMHints(display,window,&xwmh); */
+  XMapWindow(display,window);
+#if 0
+  XSelectInput(display, window, ExposureMask);
+  XWindowEvent(display, window, ExposureMask, &event);
+#endif
+  sp[0] = (long) window;
+  free(cname);
+  return 1;
+}
+
+/*-----------------------------------------------------------------------
+ * FUCTION : EMXSelectInput
+ *           To requests X server report the events associated with the event
+ *           Mask
+ * Jyhlin Chang Jul 15,1988
+ *-----------------------------------------------------------------------*/
+
+int EMXSelectInput(sp)
+long *sp;
+{
+  Window w = sp[0];
+  unsigned long event_mask = sp[1];
+  
+  XSelectInput(display, w, event_mask);
+  return 0;
+
+}
+
+typedef struct {
+  XFontStruct *f;
+  int rc;
+} FontInfo, *FontInfoPtr;
+
+IISc GCToFontInfo;
+SISc nameToFont;
+
+void setUpFont(GC gc, char *fontname)
+{
+  Font font;
+  FontInfoPtr fi;
+  XGCValues gcvalues;
+  int flags;
+
+  font = (Font) SIScLookup(nameToFont, fontname);
+  if (SIScIsNIL(font)) {
+    font = XLoadFont(display , fontname);
+    SIScInsert(nameToFont, fontname, (int)font);
+    fi = (FontInfoPtr) malloc(sizeof(FontInfo));
+    fi->f = XQueryFont(display, font);
+    fi->rc = 0;
+    TRACE(x, 3, ("Inserting %s %#x -> %#x in gctofontinfo", fontname, (int)font, (int)fi));
+    IIScInsert(GCToFontInfo, (int)font, (int)fi);
+  } else {
+    fi = (FontInfoPtr)IIScLookup(GCToFontInfo, (int)font);
+    assert(!IIScIsNIL(fi));
+  }
+  fi->rc++;
+  gcvalues.font = font;
+  XChangeGC(display, gc, GCFont, &gcvalues);
+  TRACE(x, 3, ("Inserting %#x -> %#x in gctofontinfo", (int)gc, (int)fi));
+  IIScInsert(GCToFontInfo, (int)gc, (int)fi);  
+}
+    
+int EMXInitGc(sp)
+long *sp;
+{
+  Window win = sp[0];
+  XGCValues gcvalues;
+  GC gc;
+  char *fontname;
+  int flags;
+
+  TRACE(x, 3, ("XInitGC"));
+  gcvalues.foreground = black; 
+  gcvalues.background = white; 
+  gcvalues.line_width =  0;
+  flags = GCLineWidth | GCForeground | GCBackground;
+
+  gc = XCreateGC(display,win,flags,&gcvalues);
+  setUpFont(gc, "9x15");
+  sp[0] = (long) gc;
+  TRACE(x, 3, ("XInitGC returns %x", gc));
+  return 1;
+}
+
+int EMXSetWidth(sp )
+long *sp;
+{
+  GC gc = (GC) sp[0];
+  Window  win = (Window) sp[1];
+  int width = sp[2];
+  XGCValues gcvalues;
+
+  gcvalues.line_width =  width;
+  XChangeGC(display,gc,GCLineWidth,&gcvalues);
+  return 0;
+} 
+
+EMXSetFont(sp)
+long *sp;
+{
+  GC gc = (GC) sp[0];
+  Window win = (Window)sp[1];
+  String  fontname = (String)sp[2];   
+  char *cfontname;
+
+  JTOCString(fontname, cfontname);
+  setUpFont(gc, cfontname);
+  free(cfontname);
+  return 0;
+}
+
+int EMXLine(sp)
+long *sp;
+{
+  Window win = (Window)sp[0];
+  int  x1 = sp[1], y1 = sp[2];
+  int  x2 = sp[3], y2 = sp[4];
+  GC gc = (GC)sp[5];
+
+  TRACE5(x, 3, "X Line on window %d from (%d, %d) to (%d, %d)",
+    win, x1, y1, x2, y2);
+  XDrawLine(display,win,gc,x1, y1, x2, y2);
+  TRACE0(x, 3, "XLine done");
+  return 0;
+}
+
+int EMXTextWidth(long *sp)
+{
+  Window win = (Window)sp[0];
+  String string = (String)sp[1]; 
+  GC gc = (GC)sp[2];
+  FontInfoPtr fi;
+  
+  TRACE2(x, 3, "XTextWidth begin %.*s", string->d.items, string->d.data);
+  fi = (FontInfoPtr)IIScLookup(GCToFontInfo, (int)gc);
+  assert(!IIScIsNIL(fi));
+  sp[0] = XTextWidth(fi->f, (char *)string->d.data, string->d.items);
+  TRACE0(x, 3, "XTextWidth done");
+  return 1;
+}
+  
+int EMXString(sp)
+long *sp;
+{
+  Window win = (Window)sp[0];
+  String string = (String)sp[1]; 
+  int x = sp[2], y = sp[3];
+  GC gc = (GC)sp[4];
+
+  TRACE2(x, 3, "XString begin %.*s", string->d.items, string->d.data);
+  XDrawString(display, win, gc, x, y, (char *)string->d.data, string->d.items);
+  TRACE0(x, 3, "XString done");
+  return 0;
+}
+
+int EMXConfigureWindow(sp)
+long *sp;
+{
+  Window win = (Window)sp[0];
+  int x = sp[1], y = sp[2], w = sp[3], h = sp[4];
+  XWindowChanges values;
+
+  TRACE5(x, 3, "X ConfigureWindow on window %d (%d, %d) (%d, %d)",
+    win, x, y, w, h);
+  values.x = x;
+  values.y = y;
+  values.width = w;
+  values.height = h;
+  XConfigureWindow(display, win, CWX|CWY|CWWidth|CWHeight, &values);
+  TRACE0(x, 3, "XConfigureWindow done");
+  return 0;
+}
+
+int EMXFlush()
+{
+  TRACE0(x, 3, "X Flush called");
+  XFlush(display);
+  TRACE0(x, 3, "X Flush done");
+  return 0;
+}
+
+int EMXWFlush(sp)
+long *sp;
+{
+  Window w = (Window) sp[0];
+  XFlush(display);
+  return 0;
+}
+
+EMXRaiseWindow(sp) 
+long *sp;
+{
+  Window w = (Window)sp[0];
+  XRaiseWindow(display, w);
+  return 0;
+}
+
+EMXLowerWindow(sp) 
+long *sp;
+{
+  Window w = (Window)sp[0];
+  XLowerWindow(display, w);
+  return 0;
+}
+
+EMXUnmapWindow(sp) 
+long *sp;
+{
+  Window w = (Window)sp[0];
+  XUnmapWindow(display, w);
+  return 0;
+}
+
+EMXResizeWindow(sp)
+long *sp;
+{
+  Window w =(Window)sp[0];
+  int x = sp[1],y = sp[2];
+  XResizeWindow(display,w,x,y);
+  return 0;
+}
+
+EMXMoveWindow(sp)
+long *sp;
+{
+  Window w =(Window)sp[0];
+  int x = sp[1],y = sp[2];
+  XMoveWindow(display,w,x,y);
+  return 0;
+}
+
+EMXClearWindow(sp)
+long *sp;
+{
+  Window w = (Window)sp[0];
+  XClearWindow(display, w);
+  return 0;
+}
+
+EMXClearArea(sp)
+long *sp;
+{
+  Window w = (Window)sp[0];
+  int tlx = sp[1], tly = sp[2], width = sp[3], height = sp[4];
+  XClearArea(display, w, tlx, tly, width, height, False);
+  return 0;
+}
+
+EMXCloseWindow(sp)
+long *sp;
+{
+  Window w = (Window)sp[0];
+  XDestroyWindow(display,w);
+  return 0;
+}
+
+EMXBatch(long *sp)
+{
+  int value = sp[0];
+  if (value) {
+  }
+  return 0;
+}
+
+EMXGet(long *sp)
+{
+  Window win = (Window)sp[0];
+  String string = (String)sp[1]; 
+  sp[0] = (long)string;
+  return 1;
+}
+
+EMXSet(long *sp)
+{
+  Window win = (Window)sp[0];
+  String string = (String)sp[1]; 
+
+  return 0;
+}
+
+/*----------------------------------------------------------------------
+ *
+ * Translate KeyBoard Event's input keycode to ASCII String 
+ *----------------------------------------------------------------------*/
+#define BUFFERSIZE 255
+static char CInputBuffer[BUFFERSIZE];
+
+int EMXGetCharacter(sp)
+long *sp;
+{
+  Bitchunk                      event = (Bitchunk)sp[0];
+  int                             length;
+  String                          s;
+  XEvent                          *ev;
+
+  sp[0] = (long)JNIL;
+
+  if (event == (Bitchunk) JNIL) {
+    TRACE0(x, 2, "Event is NIL in EMXGetCharacter.");
+    return 1;
+  }
+
+  ev = (XEvent *)event->d.data; 
+  TRACE5(x, 5, "event = (%d %d %d %d %d)", 
+    *(0 + (int *)ev),
+    *(1 + (int *)ev),
+    *(2 + (int *)ev),
+    *(3 + (int *)ev),
+    *(4 + (int *)ev));
+
+  TRACE0(x, 5, "Before XLookupString");
+  CInputBuffer[0] = '\0';
+  length = XLookupString((XKeyEvent *)ev, CInputBuffer, BUFFERSIZE,
+			 (KeySym *)NULL, (XComposeStatus *)NULL);
+  TRACE3(x, 5, "After XLookupString, len=%d, str=%s, end=%d", length,
+	 CInputBuffer, *(CInputBuffer+length));
+
+  s = (String)CreateString(CInputBuffer, length);
+  TRACE1(x, 5, "After BuildString, s = %x", s);
+  sp[0] = (long) s;
+  return 1;
+} 
+
+int EMXInit()
+{
+  TRACE0(x, 1, "XInit");
+  XCreateDisplay((String)JNIL);
+  GCToFontInfo = IIScCreate();
+  nameToFont = SIScCreate();
+  MTRegisterFD(ConnectionNumber(display));
+  return 0;
+}
+#endif
+
+int (*xfuncs[])() = {
+#ifdef XWindows
+  EMXInitGc,		/* 0 */
+  EMXSetFont,		/* 1 */
+  EMXSetWidth,		/* 2 */
+  EMXLine,		/* 3 */
+  EMXString,		/* 4 */
+  EMXCreateWindow,	/* 5 */
+  EMXUnmapWindow,	/* 6 */
+  EMXClearWindow,	/* 7 */
+  EMXCloseWindow,	/* 8 */
+  EMXMoveWindow,	/* 9 */
+  EMXResizeWindow,	/* 10 */
+  EMXConfigureWindow,	/* 11 */
+  EMXRaiseWindow,	/* 12 */
+  EMXLowerWindow,	/* 13 */
+  EMXFlush,		/* 14 */
+  EMXReadEvent,		/* 15 */
+  EMXGetCharacter,	/* 16 */
+  EMXSelectInput,	/* 17 */
+  EMXInit,		/* 18 */
+  EMXWFlush,		/* 19 */
+  EMXBatch,		/* 20 */
+  0,			/* 21 */
+  EMXGet,		/* 22 */
+  EMXSet,		/* 23 */
+  EMXTextWidth,		/* 24 */
+  EMXClearArea,		/* 25 */
+#endif
+};
