diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/Makefile.am ubc-latest-src/vm/Makefile.am
--- sourceforge-1.06alpha/vm/Makefile.am	2017-12-11 17:59:03.087714500 +0100
+++ ubc-latest-src/vm/Makefile.am	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-SUBDIRS = src
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/call.c ubc-latest-src/vm/src/call.c
--- sourceforge-1.06alpha/vm/src/call.c	2017-12-11 17:59:03.087714500 +0100
+++ ubc-latest-src/vm/src/call.c	2017-12-11 17:59:03.483711482 +0100
@@ -75,7 +54,8 @@
   PUSH(u32, state->pc);
 
   /* switch to the called environment */
-  state->pc = (u32)ct->d.opVector->d.data[opindex]->d.code->d.data;
+  state->opp = ct->d.opVector->d.data[opindex];
+  state->pc = (u32)state->opp->d.code->d.data;
   state->cp = ct;
   state->op = obj;
   state->fp = sp;
@@ -202,7 +182,6 @@
   extern IISc fixqueue;
   ISet fixq;
   int why = IIScLookup(allfrozen, (int)obj);
-  ConcreteType ct = CODEPTR(obj->flags);
 
   if ((Reason)why != RInitially) return;
   fixq = (ISet) IIScLookup(fixqueue, (int)obj);
@@ -211,7 +190,8 @@
   IIScInsert(fixqueue, (int)obj, (int)SQueueCreate());
   TRACE(initiallies, 1,
 	("actively invoking initially/recovery of %#x (%.*s)",
-	 obj, ct->d.name->d.items, ct->d.name->d.data));
+	 obj, CODEPTR(obj->flags)->d.name->d.items,
+	 CODEPTR(obj->flags)->d.name->d.data));
   run(obj, reasonToIndex(why), 0);
 }
 
@@ -498,8 +478,8 @@
 struct State *stateFetch(OID oid, Node loc)
 {
   State *state = (State *)OIDFetch(oid);
-  int isnew = 0;
 #ifdef DISTRIBUTED
+  int isnew = 0;
   if (ISNIL(state)) {
     ConcreteType stateCT = BuiltinInstCT(INTERPRETERSTATEI);
 
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/codeptrextra.c ubc-latest-src/vm/src/codeptrextra.c
--- sourceforge-1.06alpha/vm/src/codeptrextra.c	2017-12-11 17:59:03.087714500 +0100
+++ ubc-latest-src/vm/src/codeptrextra.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,13 +0,0 @@
-#include <stdlib.h>
-#include <stdio.h>
-
-typedef unsigned int word;
-
-int main( int argc, char **argv )
-{
-	int old_size = 2 * 1024 * 1024;
-	static word *old_start;
-	old_start = (word *) malloc (old_size);
-	printf("%#x",(int) old_start &  0xfc000000);
-	free(old_start);
-}
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/codeptrextra.h ubc-latest-src/vm/src/codeptrextra.h
--- sourceforge-1.06alpha/vm/src/codeptrextra.h	2017-12-11 17:59:03.087714500 +0100
+++ ubc-latest-src/vm/src/codeptrextra.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,2 +0,0 @@
-#undef CODEPTREXTRA
-#define CODEPTREXTRA 0xb4000000
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/context.S ubc-latest-src/vm/src/context.S
--- sourceforge-1.06alpha/vm/src/context.S	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/context.S	2017-12-11 17:59:03.483711482 +0100
@@ -0,0 +1,614 @@
+
+/*
+ * int
+ * saveProcContext(struct savearea *savearea)
+ *
+ * Save enough of the current state in SAVEAREA so that
+ * control can later be returned to the caller of the function calling
+ * saveProcContext().  SaveProcContext() behaves like setjmp(3) in that 0 is
+ * returned when the context is saved but a non-zero value is returned
+ * when returnto() resumes execution of the saved context.
+ *
+ * void
+ * returnToProc(struct savearea *savearea)
+ *
+ * Restore the state previously stored in SAVEAREA and continue execution
+ * based on that saved state.  This resumes a suspended thread, making
+ * it look like a call to savecontext() with F == 0 is now returning.
+ *
+ * bjb/mwg Dec/89 and Jul/90
+ */
+/********************************************
+
+
+note: unless the predecrement addressing mode is used, the register mask can
+be interpreted as follows:
+
+------------------------------------------------------------------------------
+Mask:  MostSigBit  15 14 13 12 11 10 9  8  7  6  5  4  3  2  1  0  LeastSigBit
+Register:          a7 a6 a5 a4 a3 a2 a1 a0 d7 d6 d5 d4 d3 d2 d1 d0
+------------------------------------------------------------------------------
+
+ if the predecrement addressing mode is used, the mask becomes:
+------------------------------------------------------------------------------
+Mask:  MostSigBit  15 14 13 12 11 10 9  8  7  6  5  4  3  2  1  0  LeastSigBit
+Register:          d0 d1 d2 d3 d4 d5 d6 d7 a0 a1 a2 a3 a4 a5 a6 a7
+
+*********************************************/
+
+#if defined(sun3) || defined(__NeXT__)
+.text
+.globl _saveProcContext
+
+_saveProcContext:
+	movl	sp@(0x4), a0		/* get save area (1st param) */
+        movl    sp@, a0@                /* save ret address, it gets trashed*/
+	moveml	#0xfefe, a0@(4)		/* save regs to save area    */
+					/* this includes a6 (frame pointer) */
+					/* and a7 (stack pointer)    */
+        moveq   #17, d0
+	rts
+
+
+.text
+.globl _startNewProc
+
+_startNewProc:
+        movl    sp@(0x4), a0            /* get function addr from stack   */
+        movl    sp@(0x8), sp            /* set stack pointer to new stack */
+        jmp     a0@
+
+
+.text
+.globl _returnToProc
+
+_returnToProc:
+	movl	sp@(0x4), a0		/* get save area (only param) */
+	moveml	a0@(4), #0xfefe    	/* this restores the regs     */
+        movl    a0@, sp@
+        moveq   #0, d0
+        rts
+
+#endif /* sun3 */
+
+
+
+
+#if defined(sun4) || defined(sun4sol)
+#ifdef sun4
+#include    <sun4/asm_linkage.h>
+#include    <sun4/trap.h>
+#endif
+
+#ifdef sun4sol
+#define _ASM
+#include <sys/trap.h>
+#include <sys/stack.h>
+
+#endif
+	
+topstack =  0
+globals  = 12
+
+.text
+#ifdef sun4
+.global _saveProcContext
+_saveProcContext:
+#else
+.global saveProcContext
+saveProcContext:
+#endif
+    st  %g1, [%o0 + globals +  0]        ! Save all globals just in case
+    st  %g2, [%o0 + globals +  4]
+    st  %g3, [%o0 + globals +  8]
+    st  %g4, [%o0 + globals + 12]
+    st  %g5, [%o0 + globals + 16]
+    st  %g6, [%o0 + globals + 20]
+    st  %g7, [%o0 + globals + 24]
+    mov %y, %g1
+    st  %g1, [%o0 + globals + 28]
+
+    st  %sp, [%o0 + topstack + 0]
+    st  %o7, [%o0 + topstack + 4]
+
+    jmp  %o7 + 0x8
+    add %g0, 17, %o0
+
+.text
+#ifdef sun4
+.global _startNewProc
+_startNewProc:
+#else
+.global startNewProc
+startNewProc:
+#endif
+    ta  ST_FLUSH_WINDOWS                ! Flush all other active windows
+
+    add  %o1, STACK_ALIGN - 1, %o1      ! SPARC requires stricter alignment
+    and  %o1, ~(STACK_ALIGN - 1), %o1   ! than malloc gives so force alignment
+    sub  %o1, SA(MINFRAME), %fp
+    sub  %fp, SA(MINFRAME), %sp
+
+    jmpl %o0, %g0
+    nop
+
+.text
+#ifdef sun4	
+.globl _returnToProc
+_returnToProc:
+#else
+.globl returnToProc
+returnToProc:
+#endif
+    ta  ST_FLUSH_WINDOWS                ! Flush all other active windows
+
+    ld  [%o0 + globals + 28], %g1       ! Restore global regs
+    mov %g1, %y
+    ld  [%o0 + globals +  0], %g1
+    ld  [%o0 + globals +  4], %g2
+    ld  [%o0 + globals +  8], %g3
+    ld  [%o0 + globals + 12], %g4
+    ld  [%o0 + globals + 16], %g5
+    ld  [%o0 + globals + 20], %g6
+    ld  [%o0 + globals + 24], %g7
+
+    ld  [%o0 + topstack + 0], %fp
+    sub %fp, SA(MINFRAME), %sp
+    ld  [%o0 + topstack + 4], %o7
+
+    clr  %o0
+    retl
+    restore %o0, 0x0, %o0
+
+#endif /* sun4 */
+
+#ifdef hp700
+
+	.SPACE $PRIVATE$
+	.SUBSPA $DATA$,QUAD=1,ALIGN=8,ACCESS=31
+	.SUBSPA $BSS$,QUAD=1,ALIGN=8,ACCESS=31,ZERO,SORT=82
+	.SPACE $TEXT$
+	.SUBSPA $LIT$,QUAD=0,ALIGN=8,ACCESS=44
+	.SUBSPA $CODE$,QUAD=0,ALIGN=8,ACCESS=44,CODE_ONLY
+	.IMPORT $global$,DATA
+	.IMPORT $$dyncall,MILLICODE
+	.file	"context.c"
+; gcc_compiled.:
+	.SPACE $TEXT$
+	.SUBSPA $CODE$
+	.EXPORT saveProcContext,ENTRY,PRIV_LEV=3,ARGW0=GR,RTNVAL=GR
+saveProcContext
+	.PROC
+	.CALLINFO FRAME=64,NO_CALLS,SAVE_SP,ENTRY_GR=3
+	.ENTRY
+	STWM    %rp, 4(%arg0)         /* store return address */
+	STWM    3, 4(%arg0)           /* store general purpose registers */
+	STWM    4, 4(%arg0)
+	STWM    5, 4(%arg0)
+	STWM    6, 4(%arg0)
+	STWM    7, 4(%arg0)
+	STWM    8, 4(%arg0)
+	STWM    9, 4(%arg0)
+	STWM    10, 4(%arg0)
+	STWM    11, 4(%arg0)
+	STWM    12, 4(%arg0)
+	STWM    13, 4(%arg0)
+	STWM    14, 4(%arg0)
+	STWM    15, 4(%arg0)
+	STWM    16, 4(%arg0)
+	STWM    17, 4(%arg0)
+	STWM    18, 4(%arg0)
+	STWM    19, 4(%arg0)
+	STWM    20, 4(%arg0)
+	STWM    21, 4(%arg0)
+	STWM    22, 4(%arg0)
+	STWM    30, 4(%arg0)       /* store static link (necessray?) */
+	STWM    %sp, 4(%arg0)       /* store stack pointer            */
+
+	LDIL	17,%ret0            /* return the perfect number      */
+ 	bv,n	0(%r2)
+	.EXIT
+	.PROCEND
+	.align 4
+
+
+	.EXPORT startNewProc,ENTRY,PRIV_LEV=3,ARGW0=GR,ARGW1=GR
+startNewProc  
+	.PROC
+	.CALLINFO FRAME=64,CALLS,SAVE_RP,SAVE_SP,ENTRY_GR=4
+	.ENTRY
+	copy %arg0, %r22	/* Set up argument to dyncall */
+	.CALL	ARGW0=GR
+	bl $$dyncall, %r31	/* Call through dyncall */
+	COPY	%arg1,%sp	/* set stack pointer to new stack */
+	.EXIT
+	.PROCEND
+	.align 4
+
+
+	.EXPORT returnToProc,ENTRY,PRIV_LEV=3,ARGW0=GR
+returnToProc
+	.PROC
+	.CALLINFO FRAME=64,NO_CALLS,SAVE_SP,ENTRY_GR=3
+	.ENTRY
+	LDWM    4(%arg0), %rp         /* load return address */
+	LDWM    4(%arg0), 3           /* load general purpose registers */
+	LDWM    4(%arg0), 4
+	LDWM    4(%arg0), 5
+	LDWM    4(%arg0), 6
+	LDWM    4(%arg0), 7
+	LDWM    4(%arg0), 8
+	LDWM    4(%arg0), 9
+	LDWM    4(%arg0), 10
+	LDWM    4(%arg0), 11
+	LDWM    4(%arg0), 12
+	LDWM    4(%arg0), 13
+	LDWM    4(%arg0), 14
+	LDWM    4(%arg0), 15
+	LDWM    4(%arg0), 16
+	LDWM    4(%arg0), 17
+	LDWM    4(%arg0), 18
+	LDWM    4(%arg0), 19
+	LDWM    4(%arg0), 20
+	LDWM    4(%arg0), 21
+	LDWM    4(%arg0), 22
+	LDWM    4(%arg0), 30       /* load static link (necessray?) */
+	LDWM    4(%arg0), %sp       /* load stack pointer            */
+	LDIL	0, %ret0            /* return zero */
+ 	bv,n	0(%r2)
+	.EXIT
+	.PROCEND
+	.align 4
+        .END
+#endif /* hp700 */
+
+
+#ifdef mips
+/* mips stuff has yet to be tested */
+
+.text
+.globl saveProcContext
+.ent saveProcContext
+
+saveProcContext:
+	.set	noreorder
+        sw      $16,  0($4)             /* save regs to save area */
+        sw      $17,  4($4)
+        sw      $18,  8($4)
+        sw      $19, 12($4)
+        sw      $20, 16($4)
+        sw      $21, 20($4)
+        sw      $22, 24($4)
+        sw      $23, 28($4)
+        sw      $fp, 32($4)
+        sw      $sp, 36($4)
+        sw      $31, 40($4)
+        /* Don't know if gp needs to be saved... */
+
+        li      $2, 17
+        j       $31
+	nop
+.end saveProcContext
+
+.text
+.globl startNewProc
+.ent startNewProc
+startNewProc:
+	.set	noreorder
+	.cpload	$25
+        addu    $sp, $0, $5             /* set stack pointer to new stack */
+	move	$25,$4
+        j       $25
+	nop
+.end startNewProc
+
+
+.text
+.globl returnToProc
+.ent returnToProc
+
+returnToProc:
+	.set	noreorder
+        lw      $16,  0($4)
+        lw      $17,  4($4)
+        lw      $18,  8($4)
+        lw      $19, 12($4)
+        lw      $20, 16($4)
+        lw      $21, 20($4)
+        lw      $22, 24($4)
+        lw      $23, 28($4)
+        lw      $fp, 32($4)
+        lw      $sp, 36($4)
+
+        lw      $31, 40($4)
+        li      $2, 0
+        j       $31
+	nop
+.end returnToProc
+
+#endif /* mips */
+
+
+#ifdef ibm
+
+/* RS6000 */
+.align 2
+.toc
+.csect .text[PR]
+gcc2_compiled.:
+__gnu_compiled_c:
+	.align 2
+	.globl startNewProc
+	.globl .startNewProc
+.csect startNewProc[DS]
+startNewProc:
+	.long .startNewProc, TOC[tc0], 0
+.csect .text[PR]
+.startNewProc:
+/*
+  We need to create a link area for this procedure.  This is because
+  the function we call is allowed to write into our link area to save
+  the CR and LR.  The link area also includes space reserved for the
+  compiler and for saving the TOC.  It's currently 6 words (24 bytes)
+  long; this code will need to be changed if the value changes.
+
+  The POWER architecture specifies that the stack pointer must be
+  quad-word aligned (16 bytes), so we take the next multiple up from
+  24 as the space we need to reserve.  This assumes that the sp passed
+  in is already quad-word aligned.
+*/
+
+	.set	linkarea, 32
+	ai	1, 4, -linkarea
+	l	0, 0(3)
+	mtlr	0
+	brl
+
+LT..startNewProc:
+	.long 0
+	.byte 0,0,32,64,0,0,0,0
+	.long LT..startNewProc-.startNewProc
+	.short 12
+	.byte "startNewProc"
+	.align 2
+	.globl returnToProc
+	.globl .returnToProc
+.csect returnToProc[DS]
+returnToProc:
+	.long .returnToProc, TOC[tc0], 0
+.csect .text[PR]
+.returnToProc:
+	lm	13, 8(3)
+	l	1, 4(3)
+	l	0, 0(3)
+	mtlr	0
+	lil	3, 0
+
+	br
+LT..returnToProc:
+	.long 0
+	.byte 0,0,32,64,0,0,0,0
+	.long LT..returnToProc-.returnToProc
+	.short 12
+	.byte "returnToProc"
+	.align 2
+	.globl saveProcContext
+	.globl .saveProcContext
+.csect saveProcContext[DS]
+saveProcContext:
+	.long .saveProcContext, TOC[tc0], 0
+.csect .text[PR]
+.saveProcContext:
+	mflr	0
+	st	0, 0(3)		/* save link */
+	st	1, 4(3)		/* save sp */
+	stm	13, 8(3)	/* save regs to save area */
+
+	lil	3, 17
+	br
+LT..saveProcContext:
+	.long 0
+	.byte 0,0,32,64,0,0,0,0
+	.long LT..saveProcContext-.saveProcContext
+	.short 15
+	.byte "saveProcContext"
+_section_.text:
+.csect .data[RW]
+	.long _section_.text
+
+#endif
+
+#if defined(i386) || defined(i486)
+#if defined(__FreeBSD__) || defined(__NetBSD__)
+#define L(X) _##X
+#endif
+#if defined(__linux__) || defined(i86pc)
+#define L(X) X
+#endif
+
+.globl L(saveProcContext)
+.align 4
+
+L(saveProcContext):
+	mov %ebx, %eax      /* first thing we do is save EBX into EAX       */
+	mov 4(%esp), %ebx   /* now we get the save area into EBX            */	
+	mov %eax, 32(%ebx)  /* get old value of EBX from EAX into save area */
+	mov (%esp), %eax    /* now we get the return address into save area */
+	mov %eax, (%ebx)
+	mov %edi, 4(%ebx)   /* save registers in save area */
+	mov %esi, 8(%ebx)
+	mov %edx, 16(%ebx)
+	mov %ecx, 20(%ebx)
+	mov %ebp, 24(%ebx)
+	mov %esp, 28(%ebx)
+	mov %eax, %ebx      /* restore EBX */
+	mov $11, %eax       /* return value of 17 (decimal) :) */
+	ret
+
+.globl L(startNewProc)
+.align 4
+
+L(startNewProc):
+	mov 4(%esp),%eax    /* we get the function pointer from the stack */
+	mov 8(%esp),%esp    /* restore the stack pointer for the new thread */
+	jmp %eax
+	
+.globl L(returnToProc)
+.align 4
+
+L(returnToProc):
+	mov 4(%esp), %ebx    /* get the save area pointer into EBX */
+	mov 4(%ebx), %edi   /* restore registers from save area */
+	mov 8(%ebx), %esi
+	mov 16(%ebx), %edx
+	mov 20(%ebx), %ecx
+	mov 24(%ebx), %ebp
+	mov 28(%ebx), %esp
+	mov (%ebx), %eax   /* restore the return address */
+	mov %eax,(%esp)
+	mov 32(%ebx), %eax  /* get old value of EBX from EAX into save area */
+	mov %eax, %ebx      /* restore EBX */
+	mov $0, %eax        /* return value of zero */
+        ret
+
+#endif /* i386 || i486 */
+
+#ifdef alpha
+	.ugen	
+	.verstamp	3 11
+	.text	
+	.align	4
+	.file	2 "fakecontext.c"
+	.globl	startNewProc
+	.ent	startNewProc 2
+startNewProc:
+	ldgp	$gp, 0($27)
+	lda	$sp, -32($sp)
+	stq	$26, 0($sp)
+	.mask	0x04000000, -32
+	.frame	$sp, 32, $26, 0
+	.prologue	1
+	and	$16, 4294967295, $16
+	and	$17, 4294967295, $17
+
+	addl	$17, 0, $sp
+ #    9	  f();
+	.livereg	0x00010002,0x00000000
+	bis	$16, $16, $27
+	jsr	$26, ($16), 0
+	ldgp	$gp, 0($26)
+ #   11	}
+	.livereg	0x007F0002,0x3FC00000
+	ldq	$26, 0($sp)
+	lda	$sp, 32($sp)
+	ret	$31, ($26), 1
+	.end	startNewProc
+	.text	
+	.align	4
+	.file	2 "fakecontext.c"
+	.globl	returnToProc
+	.loc	2 14
+ #   12	
+ #   13	void returnToProc(struct savearea *ts)
+ #   14	{
+	.ent	returnToProc 2
+returnToProc:
+	ldgp	$gp, 0($27)
+	lda	$sp, -32($sp)
+	stq	$26, 0($sp)
+	.mask	0x04000000, -32
+	.frame	$sp, 32, $26, 0
+	.prologue	1
+	and	$16, 4294967295, $1
+	ldq	$0, 0($1)
+	ldq	$2, 8($1)
+	ldq	$3, 16($1)
+	ldq	$4, 24($1)
+	ldq	$5, 32($1)
+	ldq	$6, 40($1)
+	ldq	$7, 48($1)
+	ldq	$8, 56($1)
+	ldq	$9, 640($1)
+	ldq	$10, 72($1)
+	ldq	$11, 80($1)
+	ldq	$12, 88($1)
+	ldq	$13, 96($1)
+	ldq	$14, 104($1)
+	ldq	$15, 112($1)
+	ldq	$16, 120($1)
+	ldq	$17, 128($1)
+	ldq	$18, 136($1)
+	ldq	$19, 144($1)
+	ldq	$20, 152($1)
+	ldq	$21, 160($1)
+	ldq	$22, 168($1)
+	ldq	$23, 176($1)
+	ldq	$24, 184($1)
+	ldq	$25, 192($1)
+	ldq	$26, 200($1)
+	ldq	$27, 208($1)
+ /*	ldq	$28, 216($1) */
+	ldq	$29, 224($1)
+	ldq	$30, 232($1)
+	ldq	$sp, 240($1)
+	ldq	$31, 248($1)
+	.livereg	0x0001FC02,0x00000000
+
+	lda	$sp, 32($sp)
+	ldil	$0, 0
+	ret	$31, ($26), 1
+	.end	returnToProc
+	.text	
+	.align	4
+	.file	2 "fakecontext.c"
+	.globl	saveProcContext
+	.loc	2 47
+ #   45	
+ #   46	int saveProcContext(struct savearea *ts)
+ #   47	{
+	.ent	saveProcContext 2
+saveProcContext:
+	ldgp	$gp, 0($27)
+	lda	$sp, -32($sp)
+	.frame	$sp, 32, $26, 0
+	.prologue	1
+	and	$16, 4294967295, $1
+	stq	$0, 0($1)
+	stq	$2, 8($1)
+	stq	$3, 16($1)
+	stq	$4, 24($1)
+	stq	$5, 32($1)
+	stq	$6, 40($1)
+	stq	$7, 48($1)
+	stq	$8, 56($1)
+	stq	$9, 640($1)
+	stq	$10, 72($1)
+	stq	$11, 80($1)
+	stq	$12, 88($1)
+	stq	$13, 96($1)
+	stq	$14, 104($1)
+	stq	$15, 112($1)
+	stq	$16, 120($1)
+	stq	$17, 128($1)
+	stq	$18, 136($1)
+	stq	$19, 144($1)
+	stq	$20, 152($1)
+	stq	$21, 160($1)
+	stq	$22, 168($1)
+	stq	$23, 176($1)
+	stq	$24, 184($1)
+	stq	$25, 192($1)
+	stq	$26, 200($1)
+	stq	$27, 208($1)
+ /*	stq	$28, 216($1) */
+	stq	$29, 224($1)
+	stq	$30, 232($1)
+	stq	$sp, 240($1)
+	stq	$31, 248($1)
+
+	.livereg	0xFC7F0002,0x3FC00000
+	lda	$sp, 32($sp)
+	ldil	$0, 17
+	ret	$31, ($26), 1
+	.end	saveProcContext
+#endif
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/creation.c ubc-latest-src/vm/src/creation.c
--- sourceforge-1.06alpha/vm/src/creation.c	2017-12-11 17:59:03.087714500 +0100
+++ ubc-latest-src/vm/src/creation.c	2017-12-11 17:59:03.483711482 +0100
@@ -165,6 +144,7 @@
   state->op = o;
   state->sb = (int)vmMalloc(stackSize);
   state->sp = state->sb;
+  state->opp = (OpVectorElement)JNIL;
   state->ep = (Object) JNIL;
   state->et = (ConcreteType) JNIL;
   state->nstoid = nooid;
@@ -210,6 +190,7 @@
   state->op = o;
   state->sb = (int)vmMalloc(stackSize);
   state->sp = state->sb;
+  state->opp = (OpVectorElement)JNIL;
   state->ep = (Object) JNIL;
   state->et = (ConcreteType) JNIL;
 }
@@ -235,6 +216,7 @@
   state = newState(o, ct);
 
   ope = ct->d.opVector->d.data[index];
+  state->opp = ope;
   state->ep = (Object) JNIL; state->et = (ConcreteType) JNIL;
   state->pc = (int)ope->d.code->d.data;
 
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/debug.c ubc-latest-src/vm/src/debug.c
--- sourceforge-1.06alpha/vm/src/debug.c	2017-12-11 17:59:03.088714493 +0100
+++ ubc-latest-src/vm/src/debug.c	2017-12-11 17:59:03.484711475 +0100
@@ -480,6 +458,8 @@
   if (vector) fprintf(stderr, " }");
 }
 
+extern int inHeap(unsigned int x);
+
 void displayX(int n, int *x, int vector)
 {
   if (vector) fprintf(stderr, "{ ");
@@ -488,9 +468,13 @@
       fprintf(stderr, "nil");
     } else if (*x == -1) {
       fprintf(stderr, "minus 1!");
+    } else if (!inHeap(*x)) {
+      fprintf(stderr, "non-heap pointer: %08x", *x);
     } else {
+      fprintf(stderr, "<%#x, ", *x);
       ConcreteType cp = CODEPTR(((Object)*x)->flags);
-      fprintf(stderr, "%#x %.*s", *x,
+      fprintf(stderr, "%#x>", (unsigned int)cp);
+      fprintf(stderr, " %.*s",
 	      cp->d.name->d.items, 
 	      (char *)cp->d.name->d.data);
       if (cp == BuiltinInstCT(STRINGI)) {
@@ -515,8 +499,13 @@
     fprintf(stderr, "nil");
   } else if (o == (Object)-1) {
     fprintf(stderr, "minus 1!");
+  } else if (!inHeap((unsigned int)o)) {
+    fprintf(stderr, "non-heap pointer: %08x", (unsigned int)o);
+  } else if (!inHeap((unsigned int)cp)) {
+    fprintf(stderr, "non-heap ct pointer: %08x", (unsigned int)cp);
   } else {
-    fprintf(stderr, "<%#x, %#x> %s%.*s", (int)o, (int)cp,
+    fprintf(stderr, "<%#x, %#x>", (int)o, (int)cp);
+    fprintf(stderr, " %s%.*s",
 	    HASODP(cp->d.instanceFlags) ? (RESDNT(o->flags) ? "" : "remote ") : "", 
 	    cp->d.name->d.items,
 	    (char *)cp->d.name->d.data);
@@ -794,6 +783,25 @@
 	  fprintf(stderr, "  locals:\n");
 	  dump(theTemplate, lstate.fp);
 	}
+	{
+	  unsigned int base = lstate.fp ? lstate.fp : lstate.sb;
+	  base += sizeFromTemplate(theTemplate);
+	  unsigned int ptr = base;
+	  if (ptr < lstate.sp) {
+	    /*
+	     * There is memory left over here that I don't have a template
+	     * for, let's at least document it.
+	     */
+	    while (ptr < lstate.sp) {
+	      char crap[32];
+	      sprintf(crap, "[extra +%3d]", ptr - base);
+	      printName(crap);
+	      displayX(1, (int *)ptr, 0);
+	      fprintf(stderr, "\n");
+	      ptr += 4;
+	    }
+	  }
+	}
       }
     }
   } while (unwind(&lstate) && --limit > 0);
@@ -1125,7 +1133,7 @@
   int stacklevel = 0;
   lstate = *state;
   do {
-    fprintf(stderr, "edb> ");
+    fprintf(stderr, "edb> "); fflush(stderr);
     {
       char *streamGetString( int *fail, int fd );
       int streamEos( int *fail, int fd );
@@ -1169,7 +1177,7 @@
 	tstate = temp;
 	lstate = *tstate;
 	stacklevel = 0;
-	summary(&lstate, S_PRINT);
+	summary(&lstate, S_PRINT + S_UPDATE);
       } else {
 	fprintf(stderr, "No such process (only %d exist)\n",
 		ISetSize(allProcesses));
@@ -1192,7 +1200,7 @@
     } else if (samestring(command, "up")) {
       if (unwind(&lstate)) {
 	stacklevel ++;
-	summary(&lstate, S_PRINT);
+	summary(&lstate, S_PRINT + S_UPDATE);
       } else {
 	fprintf(stderr, "Can't do up (at the top of the stack)\n");
       }
@@ -1208,7 +1216,7 @@
 	    fprintf(stderr, "Oops - couldn't unwind when I should have\n");
 	  }
 	}
-	summary(&lstate, S_PRINT);
+	summary(&lstate, S_PRINT + S_UPDATE);
       }
     } else if (samestring(command, "look") || samestring(command, "info")) {
       wherecommand(&lstate, 1, 1);
@@ -1292,6 +1300,11 @@
   return NULL;
 }
 
+void showProcess(State *state, int levelOfDetail)
+{
+  wherecommand(state, levelOfDetail, 9999999);
+}
+
 void showAllProcesses(State *state, int levelOfDetail)
 {
   State lstate, *statep, *nstate;
@@ -1318,12 +1331,13 @@
     if (statep != state) {
       fprintf(stderr, "Process %d %#x %s", current, (unsigned int)statep,
 	      isReady(statep) ? "ready" : "not ready");
-      if (!isNoOID(statep->nsoid)) 
+      if (!isNoOID(statep->nsoid)) {
 	if (ISNIL(nstate = (State *)OIDFetch(statep->nsoid))) {
 	  fprintf(stderr, " waiting some state");
 	} else {
 	  fprintf(stderr, " waiting on state %#x", (unsigned int)nstate);
 	}
+      }
       fprintf(stderr, "\n");
       lstate = *statep;
       if (levelOfDetail > 0) {
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/dist.c ubc-latest-src/vm/src/dist.c
--- sourceforge-1.06alpha/vm/src/dist.c	2017-12-11 17:59:03.088714493 +0100
+++ ubc-latest-src/vm/src/dist.c	2017-12-11 17:59:03.484711475 +0100
@@ -35,6 +15,7 @@
 #include "types.h"
 #include "mqueue.h"
 #include "storage.h"
+#include "misc.h"
 
 Node myid;
 
@@ -197,6 +178,42 @@
 #endif
 }
 
+static char *formatIPAddress(Bits32 addr, char *buffer)
+{
+	sprintf(buffer, "%d.%d.%d.%d",
+			(addr & 0xff000000) >> 24, (addr & 0x00ff0000) >> 16,
+			(addr & 0x0000ff00) >> 8, (addr & 0x000000ff));
+	return buffer;
+}
+
+static int isLocalAddress(Bits32 addr)
+{
+	return ((addr & 0xff000000) == 0x7f000000);
+}
+
+static void checkForStrangeness()
+{
+	int i, prev = -1;
+	TRACE(dist, 7, ("  Looking for strangeness"));
+	for (i = 0; i < nothers; i++) {
+		TRACE(dist, 8, ("  Looking at %#x.%4x %d %s", ntohl(others[i].id.ipaddress), others[i].id.port, others[i].s, isLocalAddress(ntohl(others[i].id.ipaddress)) ? "Local" : "Not local"));
+		if (!isLocalAddress(ntohl(others[i].id.ipaddress))) {
+			if (prev != -1 && others[prev].s == others[i].s && others[prev].id.ipaddress != others[i].id.ipaddress) {
+				char b1[32], b2[32];
+				/* Strangeness */
+				TRACE(dist, 9, ("Strange, others[%d] = %#x %d", prev, ntohl(others[prev].id.ipaddress), others[prev].s));
+				TRACE(dist, 9, ("Strange, others[%d] = %#x %d", i, ntohl(others[i].id.ipaddress), others[i].s));
+				printf("Found two different addresses for a node (%s and %s)\n",
+					   formatIPAddress(ntohl(others[prev].id.ipaddress), b1),
+					   formatIPAddress(ntohl(others[i].id.ipaddress), b2));
+				printf("This node probably has a non-working but enabled network interface\n");
+				printf("Emerald doesn't deal well with this\n");
+			}
+			prev = i;
+		}
+	}
+}
+
 int findsocket(Node *t, int create)
 {
   int i, addrlen, s, pos;
@@ -300,6 +317,7 @@
     TRACE(dist, 9, ("Inserting %#x.%d -> %d in others[%d]", ntohl(cache.id.ipaddress), cache.id.port, cache.s, nothers));
     others[nothers++] = cache;
   }
+  checkForStrangeness();
   return cache.s;
 }
 
@@ -400,6 +418,7 @@
     setupReader(ls->ri);
     if (notifyFunction) callNotifyFunction(ls->ri->id, 1);
   }
+  checkForStrangeness();
   vmFree((char *)ls);
 }
 
@@ -410,6 +429,7 @@
   int addrlen = sizeof(addr), on = 1;
   ListenerState *ls = (ListenerState *)vmMalloc(sizeof(*ls));
 
+  TRACE(dist, 1, ("ListenerCB on %d", sock));
   newsocket = accept(sock, (struct sockaddr *)&addr, &addrlen);
   if (newsocket < 0) return;
   if (setsockopt(newsocket, IPPROTO_TCP, TCP_NODELAY, (char *)&on, sizeof (on)) < 0) {
@@ -431,6 +451,7 @@
   ls->nbo.port = htons(myid.port);
   ls->nbo.epoch = htons(myid.epoch);
   ls->nbo.userid = htonl(getuid());
+  checkForStrangeness();
   if (send(ls->ri->s, (char *)&ls->nbo, sizeof(ls->nbo), 0) != sizeof(ls->nbo)) {
     nukeother(*ls->ri);
     closesocket(ls->ri->s);
@@ -483,9 +504,8 @@
     return -1;
   }
   if (setsockopt(mysocket, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof (on)) < 0) {
-    closesocket(mysocket);
-    perror("setsockopt");
-    return -1;
+	  /* This is not a big deal, ignore it */
+	  TRACE(dist, 1, ("Failed to set SO_REUSEADDR socket option"));
   }
   /*
    * Originally we did this all the time on not windows
@@ -580,14 +600,14 @@
 
 void establishHandler(int sig, void (*handler)(int))
 {
-#if defined(__svr4__) || defined(__SYSTYPE_SVR4__)
+#if defined(__svr4__) || defined(__SYSTYPE_SVR4__) || defined(CYGWIN)
   struct sigaction action;
 
   memset(&action, 0, sizeof(action));
   action.sa_handler = handler;
   sigaction(sig, &action, NULL);
 #else
-#ifdef WIN32
+#if defined(WIN32) || defined(DOS)
   signal(sig, handler);
 #else
   struct sigvec vec;
@@ -628,21 +648,32 @@
   return rval;
 }
 
+int getplane()
+{
+  int port = 0;
+  extern int offsetbyuserid;
+  char *plane = getenv("EMPLANE");
+  if (plane) {
+    port += mstrtol(plane, 0, 10);
+  } else if (offsetbyuserid) {
+    port += getuid() % EMERALDPORTSKIP;
+  }
+  return port;
+}
+
+
 int InitDist()
 {
   extern Node MyNode;
   extern OID MyBaseOID;
   int port;
-  char *plane;
   extern char *getenv(const char *);
 
   InitStorage();
 
   MyNode.epoch = random() & 0xffff;
   /* start up the network subsystem */
-  port = EMERALDFIRSTPORT;
-  plane = getenv("EMPLANE");
-  if (plane) port += mstrtol(plane, 0, 10);
+  port = EMERALDFIRSTPORT + getplane();
   
 #ifdef DISTRIBUTED
   while (DNetStart(0,  port, MyNode.epoch) != 0) {
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/distgc.c ubc-latest-src/vm/src/distgc.c
--- sourceforge-1.06alpha/vm/src/distgc.c	2017-12-11 17:59:03.088714493 +0100
+++ ubc-latest-src/vm/src/distgc.c	2017-12-11 17:59:03.484711475 +0100
@@ -265,6 +243,7 @@
   OID oid;
   Object o;
   int marked = 0, markedstates = 0, unmarkedstates = 0, removed = 0, notremoved = 0;
+  extern int nDGCremoved;
   if (whichgc == lastCompletedDistGCSeq) {
     TRACE(distgc, 3, ("Extraneous finish distgc"));
     return;
@@ -317,6 +296,7 @@
       marked++;
     }
   } OTableNext();
+  nDGCremoved += removed;
   TRACE(distgc, 2, ("Dist GC %d: finished cleaning object table", distGCSeq));
   TRACE(distgc, 2, ("%d marked states, %d unmarked states, %d marked, %d removed, %d notremoved",
 		    markedstates, unmarkedstates, marked, removed, notremoved));
@@ -360,6 +340,8 @@
 {
   if (inDistGC()) return;
   assert(!remotegreys);
+  extern int nDGCs;
+  nDGCs ++;
   remotegreys = ISetCreate();
   interestingblacks = ISetCreate();
   stage = dgcWorking;
@@ -759,7 +741,7 @@
 {
   Object o;
   OID oid;
-  TRACE(distgc, 4, ("DistGCInfo %s received from %s",
+  TRACE(distgc, 3, ("DistGCInfo %s received from %s",
 		    h->option1 ? "black" : "grey", NodeString(srv)));
   if (!inDistGC())
     startDistGC();
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/dist.h ubc-latest-src/vm/src/dist.h
--- sourceforge-1.06alpha/vm/src/dist.h	2017-12-11 17:59:03.088714493 +0100
+++ ubc-latest-src/vm/src/dist.h	2017-12-11 17:59:03.484711475 +0100
@@ -36,7 +14,7 @@
 #endif
 
 #define EMERALDFIRSTPORT 0x3ee3
-#define EMERALDPORTSKIP 0x100
+#define EMERALDPORTSKIP 0x400
 #define EMERALDPORTPROBE(n) ((n) + EMERALDPORTSKIP)
 
 char *NodeString(Node);
@@ -48,6 +26,7 @@
 extern void DInit(void);
 void DStart(void);
 
+extern int getplane(void);
 int DNetStart(unsigned int, unsigned short, unsigned short);
 int DSend(Node receiver, void *sbuf, int slen);
 int DProd(Node *receiver);
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/env.c ubc-latest-src/vm/src/env.c
--- sourceforge-1.06alpha/vm/src/env.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/env.c	2017-12-11 17:59:03.487711452 +0100
@@ -0,0 +1,16 @@
+int g;
+
+main()
+{
+  int l;
+  long *ll;
+  printf("Sizeof int = %d\n", sizeof(int));
+  printf("Sizeof long = %d\n", sizeof(long));
+  printf("Sizeof char * = %d\n", sizeof(char *));
+  printf("Address of global g = %lx\n", &g);
+  printf("Address of local l = %lx\n", &l);
+  ll = malloc(32);
+  *ll = 5;
+  ll = (long)ll + 4;
+  *ll = 6;
+}
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/error.c ubc-latest-src/vm/src/error.c
--- sourceforge-1.06alpha/vm/src/error.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/error.c	2017-12-11 17:59:03.487711452 +0100
@@ -0,0 +1,24 @@
+/****************************************************************************
+ File     : error.c 
+ Date     : 08-11-92
+ Author   : Mark Immel
+
+ Contents : Error handling package
+
+ Modifications
+ -------------
+
+*****************************************************************************/
+
+#pragma warning(disable: 4068)
+#pragma pointer_size long
+#include <stdio.h>
+#include <errno.h>
+#pragma pointer_size short
+#include "error.h"
+
+void FatalError(char *ErrorMessage)
+{
+  perror(ErrorMessage);
+  exit(1);
+}
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/error.h ubc-latest-src/vm/src/error.h
--- sourceforge-1.06alpha/vm/src/error.h	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/error.h	2017-12-11 17:59:03.487711452 +0100
@@ -0,0 +1,18 @@
+/****************************************************************************
+ File     : error.h 
+ Date     : 08-11-92
+ Author   : Mark Immel
+
+ Contents : Error handling package
+
+ Modifications
+ -------------
+
+*****************************************************************************/
+
+#ifndef _ERROR_H
+#define _ERROR_H
+
+extern void FatalError(char *ErrorMessage);
+
+#endif /* _ERROR_H */
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/fakecontext.c ubc-latest-src/vm/src/fakecontext.c
--- sourceforge-1.06alpha/vm/src/fakecontext.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/fakecontext.c	2017-12-11 17:59:03.487711452 +0100
@@ -0,0 +1,82 @@
+struct savearea {
+  int a, b, c, d, e, f, g, h, i, j, k, l, m;
+  int n, o, p, q, r, s, t, u, v, w, x, y, z;
+};
+
+void startNewProc(void (*f)(), void *sp)
+{
+  int x = (int)sp + 1;
+  f();
+  junk(x);
+}
+
+void returnToProc(struct savearea *ts)
+{
+  int a, b, c, d, e, f, g, h, i, j, k, l, m;
+  int n, o, p, q, r, s, t, u, v, w, x, y, z;
+  a = ts->a;
+  b = ts->b;
+  c = ts->c;
+  d = ts->d;
+  e = ts->e;
+  f = ts->f;
+  g = ts->g;
+  h = ts->h;
+  i = ts->i;
+  j = ts->j;
+  k = ts->k;
+  l = ts->l;
+  m = ts->m;
+  n = ts->n;
+  o = ts->o;
+  p = ts->p;
+  q = ts->q;
+  r = ts->r;
+  s = ts->s;
+  t = ts->t;
+  u = ts->u;
+  v = ts->v;
+  w = ts->w;
+  x = ts->x;
+  y = ts->y;
+  z = ts->z;
+  junk2(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z);
+}
+
+int saveProcContext(struct savearea *ts)
+{
+  int a, b, c, d, e, f, g, h, i, j, k, l, m;
+  int n, o, p, q, r, s, t, u, v, w, x, y, z;
+  
+  ts->a = a;
+  ts->b = b;
+  ts->c = c;
+  ts->d = d;
+  ts->e = e;
+  ts->f = f;
+  ts->g = g;
+  ts->h = h;
+  ts->i = i;
+  ts->j = j;
+  ts->k = k;
+  ts->l = l;
+  ts->m = m;
+  ts->n = n;
+  ts->o = o;
+  ts->p = p;
+  ts->q = q;
+  ts->r = r;
+  ts->s = s;
+  ts->t = t;
+  ts->u = u;
+  ts->v = v;
+  ts->w = w;
+  ts->x = x;
+  ts->y = y;
+  ts->z = z;
+}
+
+int foo()
+{
+  return 17;
+}
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/fakemain.c ubc-latest-src/vm/src/fakemain.c
--- sourceforge-1.06alpha/vm/src/fakemain.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/fakemain.c	2017-12-11 17:59:03.487711452 +0100
@@ -0,0 +1,12 @@
+#pragma warning(disable: 4068)
+#pragma pointer_size long
+#include <stdio.h>
+#pragma pointer_size short
+
+int main(ac,av)
+int ac;
+char **av;
+{
+  mainp(ac,av);
+  return 0;
+}
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/gaggle.c ubc-latest-src/vm/src/gaggle.c
--- sourceforge-1.06alpha/vm/src/gaggle.c	2017-12-11 17:59:03.088714493 +0100
+++ ubc-latest-src/vm/src/gaggle.c	2017-12-11 17:59:03.488711444 +0100
@@ -257,6 +235,12 @@
 
   value = (gtypeptr) OIScLookup(gaggleTable, goid);
   tonuke = 0;
+  if (!value) {
+    TRACE(gaggle, 0, ("Removing %s from unknown gaggle %s", OIDString(deadMember),
+		      OIDString(goid)));
+    return;
+  }
+
   if (sameOID(value->gmember, deadMember)) {
     tonuke = value;
     OIScInsert(gaggleTable, goid, (int)value->next);
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/gc.c ubc-latest-src/vm/src/gc.c
--- sourceforge-1.06alpha/vm/src/gc.c	2017-12-11 17:59:03.088714493 +0100
+++ ubc-latest-src/vm/src/gc.c	2017-12-11 17:59:03.488711444 +0100
@@ -131,6 +109,8 @@
 int move_stack_size = 0;
 static int total_gc_time, old_gc_time;
 static int nGCs, nOGCs;
+int nDGCs, nDGCremoved;
+
 
 static word *survivors_start, *survivors_end;
 
@@ -151,10 +131,20 @@
 
 static inline void forward(Object o, Object new)
 {
+  OID oid;
   TRACE(memory, 5, ("Forwarding %#x to %#x", o, new));
   new->flags = o->flags;
-  o->flags = (int)new | 1;
-  assert((HASOID(new->flags) && 1) == (!isNoOID(OIDOf(o))));
+  o->flags = (unsigned int)new | 1;
+  oid = OIDOf(o);
+  if ((HASOID(new->flags) && 1) != !isNoOID(oid)) {
+    TRACE(memory, 0, ("Object %#x has oid %s, HASOID == %s", o, OIDString(oid),
+		      HASOID(new->flags) ? "true" : "false"));
+    if (isNoOID(oid)) {
+      CLEARHASOID(new->flags);
+    } else {
+      SETHASOID(new->flags);
+    }
+  }
   if (HASOID(new->flags)) UpdateObjectLocation(o, new);
 }
 
@@ -218,12 +208,14 @@
   return (Object) new_addr;
 }
 
-void gc_stats (int *tg, int *og, int *n, int *no)
+void gc_stats (int *tg, int *og, int *n, int *no, int *nd, int *ndr)
 {
   *tg = total_gc_time;
   *og = old_gc_time;
   *n = nGCs;
   *no = nOGCs;
+  *nd = nDGCs;
+  *ndr = nDGCremoved;
 }
 
 #ifndef NDEBUG
@@ -824,6 +816,30 @@
 static int total_stores, total_interesting_stores;
 extern void gcollect_old(void);
 
+static int needDistGC(void)
+{
+  /*
+   * Think about starting a distGC if the fraction of free space is small
+   * (how small?) and the number of objects with OIDs is large (how
+   * large?).  The current settings of these two parameters is entirely a
+   * guess.
+   */
+#define DISTGCPERCENTTHRESHOLD 25
+#define DISTGCGLOBALOBJECTTHRESHOLD 10000
+  if (!inDistGC()) {
+    int freepercent = (old_end - nextGen) * 100 / (old_end - old_start);
+    if (freepercent < DISTGCPERCENTTHRESHOLD) {
+      TRACE(distgc, 2, ("Starting distgc, free memory = %d", freepercent));
+      return 1;
+    } else if (OTableSize(ObjectTable) > DISTGCGLOBALOBJECTTHRESHOLD) {
+      TRACE(distgc, 2, ("Starting distgc, objects with oids = %d",
+			OTableSize(ObjectTable)));
+      return 1;
+    }
+  }
+  return 0;
+}    
+
 void gcollect(void)
 {
   int start_time;
@@ -872,10 +888,10 @@
   total_gc_time += (done_time - start_time);
 
   TRACE(memory, 3, ("Old = %d words, new = %d words, promo = %d words", 
-		    ((int)nextGen - (int)old_start) / sizeof(int),
+		    ((unsigned int)nextGen - (unsigned int)old_start) / sizeof(int),
 		    (allocatingForward ? 
-		     (int)fromSpace - (int)new_start :
-		     (int)new_end - (int)fromSpace) / sizeof(int),
+		     (unsigned int)fromSpace - (unsigned int)new_start :
+		     (unsigned int)new_end - (unsigned int)fromSpace) / sizeof(int),
 		    wordsToBePromotedNextGC));
   TRACE(memory, 4, ("Total stores so far = %d, %d interesting", 
 		    total_stores, total_interesting_stores));
@@ -883,7 +899,7 @@
     TRACE(memory, 0, ("old_end = %#x, next_gen = %#x, diff = %d, promo = %d\n",
 		      old_end, nextGen, old_end - nextGen,
 		      wordsToBePromotedNextGC));
-    TRACE(memory, 0, ("Out of memory.  Try including the flag -O%dk on the command line!", old_size/1024 + 256));
+    fprintf(stderr, "Out of memory.  Try including the flag -O%dk on the command line!\n", old_size/1024 + 256);
     abort();
   }
 
@@ -915,6 +931,24 @@
   inhibit_gc++;
 }
 
+void ensureSpace(int bytes)
+{
+  assert(!inhibit_gc);
+  while (wordsLeftInThisGeneration * 4 < bytes) {
+    gcollect();
+  }
+
+  if (old_end - nextGen - wordsToBePromotedNextGC < BYTES_TO_WORDS(bytes))
+    gcollect();
+
+  /*
+   * Since the call to gcollect can sometimes call gcollect_old, then we
+   * only need to call it again if it is really necessary.
+   */
+  if (old_end - nextGen - wordsToBePromotedNextGC < BYTES_TO_WORDS(bytes))
+    gcollect_old();
+}
+
 /* allocate lb bytes of data in the old generation */
 void *gc_malloc_old (int lb, int remember)
 {
@@ -928,7 +962,7 @@
       TRACE(memory, 0, ("old_end = %#x, next_gen = %#x, diff = %d, promo = %d\n",
 			old_end, nextGen, old_end - nextGen,
 			wordsToBePromotedNextGC));
-      TRACE(memory, 0, ("Out of memory.  Try including the flag -O%dk on the command line!", old_size/1024 + 256));
+      fprintf(stderr, "Out of memory.  Try including the flag -O%dk on the command line!\n", old_size/1024 + 256);
       abort();
     } else {
       gcollect();
@@ -937,7 +971,7 @@
 	TRACE(memory, 0, ("old_end = %#x, next_gen = %#x, diff = %d, promo = %d\n",
 			  old_end, nextGen, old_end - nextGen,
 			  wordsToBePromotedNextGC));
-	TRACE(memory, 0, ("Out of memory.  Try including the flag -O%dk on the command line!", old_size/1024 + 256));
+	fprintf(stderr, "Out of memory.  Try including the flag -O%dk on the command line!\n", old_size/1024 + 256);
 	abort();
       }
     }
@@ -984,6 +1018,12 @@
   return op;
 }
 
+int inHeap(unsigned int x)
+{
+    return ((old_start <= (word *)x && (word *)x < old_end) ||
+	    (new_lb <= (word *)x && (word *)x < new_ub));
+}
+
 void gc_init (void (*b)(void), void (*d)(void), void (*a)(void), void (*e)(void))
 {
   _gc_b = b;
@@ -998,50 +1038,18 @@
     old_size = p_old_size;
     guaranteeInterGcInterval = p_guaranteeInterGcInterval;
     if (copyCount > 2) {
-      TRACE(memory, 0, ("Copy count of > 2 are not supported: %d", copyCount));
+      fprintf(stderr, "Copy counts of > 2 are not supported: %d\n", copyCount);
       copyCount = 2;
     }
     nbytes = copyCount * (copyCount == 1?1:2) * bytesPerGeneration;
 
     fromSpace = new_start = (word *) vmMalloc (nbytes);
     toSpace = new_end = &fromSpace[nbytes / sizeof(word)];
-    //vmMalloc er definet som malloc. Den fejler tydeligvis.
-    //Den fejler ogsaa naar vi fjerner checksene nedenfor
     nextGen = old_start = (word *) vmMalloc (old_size);
     old_end = old_start + (old_size / sizeof(word));
     new_lb = new_start;
     new_ub = new_end;
-    int tmp = (int)old_start & ~ALLBITS;
-    //MB_REMOVE
-    /*TRACE(memory, 0, ("ALLBITS = %#x", ALLBITS));
-    TRACE(memory, 0, ("~ALLBITS = %#x", ~ALLBITS));
-    TRACE(memory, 0, ("CODEPTREXTRA = %#x", CODEPTREXTRA));
-    TRACE(memory, 0, ("~ALLBITS | CODEPTREXTRA = %#x", ~ALLBITS | CODEPTREXTRA));
-    TRACE(memory, 0, ("old_start = %#x / %#d", (unsigned int)old_start, (int)old_start));
-	// Paa redhatten er old_start negativ!
-    TRACE(memory, 0, ("old_start & ~ALLBITS = %#x", (unsigned int)old_start & ~ALLBITS));
-    TRACE(memory, 0, ("old_start | CODEPTREXTRA = %#x", CODEPTREXTRA | (unsigned int)old_start));
-    TRACE(memory, 0, ("(old_start & ~ALLBITS) | CODEPTREXTRA = %#x", tmp | CODEPTREXTRA));
-    TRACE(memory, 0, ("result = %#x", ((int)old_start & ~ALLBITS) | CODEPTREXTRA)) 
-    TRACE(memory, 0, ("old_size = %#x", old_size)) 
-    */
-    if (((int)old_start & CODEPTREXTRA) != CODEPTREXTRA) {
-      TRACE(memory, 0, ("EXTRA: old_start = %#x", (unsigned int)old_start));
-      abort();
-    }
-    if (((int)new_start & CODEPTREXTRA) != CODEPTREXTRA) {
-      TRACE(memory, 0, ("EXTRA: new_start = %#x", (unsigned int)new_start));
-      abort();
-    }
-    //Ikke nogle af ALLBITS og skal have CODEPTREXTRA sat i old_start
-    if ((((int)old_start & ~ALLBITS) | CODEPTREXTRA) != (int)old_start) {
-      TRACE(memory, 0, ("BITS: old_start = %#x", (unsigned int)old_start));
-      abort();
-    }
-    if ((((int)new_start & ~ALLBITS) | CODEPTREXTRA) != (int)new_start) {
-      TRACE(memory, 0, ("BITS: new_start = %#x", (unsigned int)new_start));
-      abort();
-    }
+    codeptrextra = (unsigned int)old_start & ALLBITS;
       
     wordsPerGeneration = bytesPerGeneration / sizeof(word);
     wordsLeftInThisGeneration = 
@@ -1049,6 +1057,8 @@
 	bytesPerGeneration / sizeof(word) :
 	(new_end - new_start + wordsToBePromotedNextGC) / (copyCount==1?1:2)
 	  - liveWords();
+	TRACE(memory, 1, ("old = [%#x - %#x], new = [%#x - %#x]",
+					  old_start, old_end, new_start, new_end));
   }
 }
 
@@ -1486,7 +1496,7 @@
 {
   int count = 0;
 
-  while ((int)o > 0) {
+  while (!IIXScIsNIL(o)) {
     count ++;
     o = (Object)o->flags;
   }
@@ -1572,7 +1582,7 @@
     } else {
       int size = sizeOf(o);
       new = (Object)IIXScLookup(freeLists, size);
-      assert((int)new > 0);
+      assert(!IIXScIsNIL(new));
       IIXScInsert(freeLists, size, new->flags);
       forward(o, new);
     }
@@ -1625,7 +1635,9 @@
 void findBoundary(void)
 {
   Object o, hole = 0, guess, holes = 0, lasto;
+#if !defined(NDEBUG)
   Object to = (Object)nextGen;
+#endif
   int holeSize = 0, size, left;
 #define RECORDHOLESIZE(hole, size) IIScInsert(holeSizes, (int)hole, size)
 #define GETHOLESIZE(hole) IIScLookup(holeSizes, (int)hole)
@@ -1719,7 +1731,7 @@
       if (IIXScBumpBy(liveSizes, size, -1) < 0) {
 	Object freeChunk = (Object)IIXScLookup(freeLists, size);
 	int tSize = size;
-	assert((int)freeChunk > 0);
+	assert(!IIXScIsNIL(freeChunk));
 	TRACE(memory, 9, ("Re-allocating a free chunk of size %d at 0x%x",
 			  size, freeChunk));
 	IIXScInsert(freeLists, size, freeChunk->flags);
@@ -1772,7 +1784,7 @@
       size = sizeOf(o);
       if (marked(o)) {
 	new = (Object)IIXScLookup(freeLists, size);
-	assert((int)new > 0);
+	assert(!IIXScIsNIL(new));
 	TRACE(memory, 5, ("Finding a new location for 0x%x at 0x%x", o, new));
 	IIXScInsert(freeLists, size, new->flags);
 	checkAsOnFreeList(new, size);
@@ -1781,7 +1793,7 @@
 	(void)move_fields(o, new, checkAndFindNew_old);
 	clearMark(new);
       } else {
-	TRACE(memory, 5, ("Object at 0x%x is not reachable", o));
+	TRACE(memory, 9, ("Object at 0x%x is not reachable", o));
 	/* do nothing, the object isn't reachable */
       }
     }
@@ -1934,17 +1946,7 @@
   IIXScDestroy(freeLists);
   done_time = currentCpuTime();
   old_gc_time += (done_time - start_time);
-  /*
-   * Think about starting a distGC if the fraction of free space is small
-   * (how small?) and the number of objects with OIDs is large (how
-   * large?).  The current settings of these two parameters is entirely a
-   * guess.
-   */
-#define DISTGCPERCENTTHRESHOLD 25
-#define DISTGCGLOBALOBJECTTHRESHOLD 15000
-  if (!inDistGC() &&
-      ((old_end - nextGen) * 100 / (old_end - old_start) < DISTGCPERCENTTHRESHOLD ||
-       (OTableSize(ObjectTable) > DISTGCGLOBALOBJECTTHRESHOLD))) {
+  if (needDistGC()) {
     startDistGC();
   }
 }
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/gc.h ubc-latest-src/vm/src/gc.h
--- sourceforge-1.06alpha/vm/src/gc.h	2017-12-11 17:59:03.088714493 +0100
+++ ubc-latest-src/vm/src/gc.h	2017-12-11 17:59:03.488711444 +0100
@@ -80,6 +58,7 @@
 extern Object createStub(ConcreteType ct, void *stub, OID oid);
 
 extern int inhibit_gc;
+extern void ensureSpace(int howmanybytes);
 extern void anticipateGC(int howmanybytes);
 extern void new_rem_set(Object);
 extern void recordSize(Object, int);
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/gencodeptrextra.sh ubc-latest-src/vm/src/gencodeptrextra.sh
--- sourceforge-1.06alpha/vm/src/gencodeptrextra.sh	2017-12-11 17:59:03.088714493 +0100
+++ ubc-latest-src/vm/src/gencodeptrextra.sh	1970-01-01 01:00:00.000000000 +0100
@@ -1,5 +0,0 @@
-#!/bin/sh
-#errornumber=`./emx |egrep old_start\|new_start |sed s/"^.*old_start = "//|sed s/"^.*new_start = "//`
-
-echo \#undef CODEPTREXTRA > codeptrextra.h;
-echo \#define CODEPTREXTRA `./codeptrextra` >> codeptrextra.h;
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/globals.c ubc-latest-src/vm/src/globals.c
--- sourceforge-1.06alpha/vm/src/globals.c	2017-12-11 17:59:03.089714485 +0100
+++ ubc-latest-src/vm/src/globals.c	2017-12-11 17:59:03.488711444 +0100
@@ -37,6 +15,7 @@
   return 1;
 }
 
+int codeptrextra;
 Object BuiltinGlobalArray[NUMBUILTINS][NUMTAGS];
 int totalbytecodes;
 String TrueString, FalseString;
@@ -81,7 +60,9 @@
        junfix,
        jrefix,
        jlocate,
-       jisfixed
+       jisfixed,
+       jgetIncarnationTime,
+       jgetLoadAverage
      };
 
 void initGlobals()
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/globals.h ubc-latest-src/vm/src/globals.h
--- sourceforge-1.06alpha/vm/src/globals.h	2017-12-11 17:59:03.089714485 +0100
+++ ubc-latest-src/vm/src/globals.h	2017-12-11 17:59:03.488711444 +0100
@@ -73,7 +51,9 @@
 	jfix(struct State *),
 	junfix(struct State *),
 	jrefix(struct State *),
-	jlocate(struct State *);
+	jlocate(struct State *),
+	jgetIncarnationTime(struct State *),
+	jgetLoadAverage(struct State *);
 
 extern int (*(sysfuncs[]))(struct State *),
 	(*(xfuncs[]))(int *);
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/iiiiisc.c ubc-latest-src/vm/src/iiiiisc.c
--- sourceforge-1.06alpha/vm/src/iiiiisc.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/iiiiisc.c	2017-12-11 17:59:03.488711444 +0100
@@ -0,0 +1,324 @@
+/* comment me!
+ */
+
+#include "iiiiisc.h"
+
+/*
+ * Searchable Collections:
+ *
+ * Expanding hash tables with a key and data.
+ */
+
+#ifndef NULL
+#include <stdio.h>
+#endif
+
+#ifndef assert
+#include "assert.h"
+#endif
+
+static int sizes[] = {
+  5, 7, 17, 31,
+  67, 131, 257, 521,
+  1031, 2053, 4099, 8093,
+  16193, 32377, 65557, 131071,
+  262187, 524869, 1048829, 2097223,
+  4194371, 8388697, 16777291 };
+#define MAXFILL(x) (((x) * 17) / 20)
+
+/*
+ * Turning this on will cause the package to self-check on every (modifying)
+ * operation.  The package runs very slowly when this is enabled.
+ */
+#undef DEBUGSC
+
+#define Hash(a,b,c,d,sc) (IIIIIScHASH(a,b,c,d) % sc->size)
+
+#ifdef DEBUGSC
+static void CheckOutHashTable();
+#endif
+
+/* Return a new, empty IIIIISc */
+IIIIISc IIIIIScCreate()
+{
+  register int i;
+  register IIIIISc sc;
+
+  sc = (IIIIISc) vmMalloc(sizeof(IIIIIScRecord));
+  sc->size = sizes[0];
+  sc->maxCount = MAXFILL(sc->size);
+  sc->count = 0;
+  sc->table = (IIIIIScTEPtr) vmMalloc((unsigned) sc->size * sizeof(IIIIIScTE));
+  for (i = 0; i < sc->size; i++) {
+    sc->table[i].key.a = IIIIIScNIL;
+  }
+#ifdef DEBUGSC
+  CheckOutHashTable(sc);
+#endif DEBUGSC
+  return sc;
+}
+
+void IIIIIScDestroy(sc)
+register IIIIISc sc;
+{
+  vmFree((char *)sc->table);
+  vmFree((char *)sc);
+}
+
+/* Expand the hash table.  Each element in the table is re-hashed and entered 
+ * in the new table. */
+static void ExpandHashTable(sc)
+register IIIIISc sc;
+{
+  register IIIIIScTE *nh, *oe, *ne;
+  register int oldHashTableSize = sc->size, i;
+  int index;
+
+  for (i = 0; sizes[i] <= oldHashTableSize; i++) ;
+  sc->size = sizes[i];
+  sc->maxCount = MAXFILL(sc->size);
+  nh = (IIIIIScTEPtr) vmMalloc((unsigned)(sc->size * sizeof(IIIIIScTE)));
+  for (i = 0; i < sc->size; i++) nh[i].key.a = IIIIIScNIL;
+  for (i = 0; i < oldHashTableSize; i++) {
+    oe = &sc->table[i];
+    if (oe->key.a == IIIIIScNIL) continue;
+    index = Hash(oe->key.a, oe->key.b, oe->key.c, oe->key.d, sc);
+    while (1) {
+      ne = &nh[index];
+      if (ne->key.a == IIIIIScNIL) {
+	ne->key = oe->key;
+	ne->value = oe->value;
+	break;
+      } else {
+	index++;
+	if (index >= sc->size) index = 0;
+      }
+    }
+  }
+  vmFree((char *)sc->table);
+  sc->table = nh;
+#ifdef DEBUGSC
+  CheckOutHashTable(sc);
+#endif DEBUGSC
+}
+
+/* Return the value associated with key in collection sc, or IIIIIScNIL */
+IIIIIScRangeType IIIIIScLookup(sc, a, b, c, d)
+register IIIIISc sc;
+register int  a, b, c, d;
+{
+  register int index = Hash(a,b,c,d, sc);
+  register IIIIIScTEPtr e;
+
+#ifdef DEBUGSC
+  CheckOutHashTable(sc);
+#endif DEBUGSC
+  while (1) {
+    e = &sc->table[index];
+    if (e->key.a == IIIIIScNIL) {               /* we did not find it */
+      return IIIIIScNIL;
+    } else if (IIIIIScCOMPARE(e->key, a,b,c,d)) {
+      return e->value;
+    }
+    if (++index >= sc->size) index = 0;
+  }
+}
+
+/* Bump the value associated with key in collection sc, or insert 1 */
+IIIIIScRangeType IIIIIScBump(sc, a,b,c,d)
+register IIIIISc sc;
+register int  a,b,c,d;
+{
+  register int index = Hash(a,b,c,d, sc);
+  register IIIIIScTEPtr e;
+
+#ifdef DEBUGSC
+  CheckOutHashTable(sc);
+#endif DEBUGSC
+  while (1) {
+    e = &sc->table[index];
+    if (e->key.a == IIIIIScNIL) {               /* we did not find it */
+      IIIIIScInsert(sc,a,b,c,d,1);
+      return 1;
+    } else if (IIIIIScCOMPARE(e->key, a,b,c,d)) {
+      return ++e->value;
+    }
+    if (++index >= sc->size) index = 0;
+  }
+}
+
+/* Bump the value associated with key in collection sc by value */
+IIIIIScRangeType IIIIIScBumpBy(sc, a,b,c,d, value)
+register IIIIISc sc;
+register int a,b,c,d;
+int value;
+{
+  register int index = Hash(a,b,c,d, sc);
+  register IIIIIScTEPtr e;
+
+#ifdef DEBUGSC
+  CheckOutHashTable(sc);
+#endif DEBUGSC
+  while (1) {
+    e = &sc->table[index];
+    if (e->key.a == IIIIIScNIL) {               /* we did not find it */
+      IIIIIScInsert(sc, a,b,c,d, value);
+      return 1;
+    } else if (IIIIIScCOMPARE(e->key, a,b,c,d)) {
+      e->value += value;
+      return e->value;
+    }
+    if (++index >= sc->size) index = 0;
+  }
+}
+
+/* Insert the key, value pair in sc.  If the key already exists, change its 
+ * value. */
+void IIIIIScInsert(sc, a,b,c,d, value)
+register IIIIISc sc;
+register int a,b,c,d;
+IIIIIScRangeType value;
+{
+  register int index;
+  register IIIIIScTEPtr e;
+
+  if (sc->count >= sc->maxCount) ExpandHashTable(sc);
+  index = Hash(a,b,c,d, sc);
+  while (1) {
+    e = &sc->table[index];
+    if (e->key.a == IIIIIScNIL) {               /* put it here */
+      e->key.a = a;
+      e->key.b = b;
+      e->key.c = c;
+      e->key.d = d;
+      e->value = value;
+      sc->count++;
+#ifdef DEBUGSC
+      CheckOutHashTable(sc);
+#endif DEBUGSC
+      return;
+    } else if (IIIIIScCOMPARE(e->key, a,b,c,d)) {
+      e->value = value;
+#ifdef DEBUGSC
+      CheckOutHashTable(sc);
+#endif DEBUGSC
+      return;
+    }
+    if (++index >= sc->size) index = 0;
+  }
+}
+
+/* Remove the entry, if it is there */
+void IIIIIScDelete(sc, a,b,c,d)
+register IIIIISc sc;
+register int a,b,c,d;
+{
+  register int index = Hash(a,b,c,d, sc);
+  IIIIIScDomainType key;
+  register IIIIIScRangeType value;
+  register IIIIIScTEPtr e;
+
+  while (1) {
+    e = &sc->table[index];
+    if (e->key.a == IIIIIScNIL) {               /* we did not find it */
+#ifdef DEBUGSC
+      CheckOutHashTable(sc);
+#endif DEBUGSC
+      return;
+    }
+    if (IIIIIScCOMPARE(e->key, a,b,c,d)) {
+      /* Found it, now remove it */
+      sc->count--;
+      e->key.a = IIIIIScNIL;
+      e->value = IIIIIScNIL;
+      while (1) {
+	/* rehash until we reach nil again */
+	if (++index >= sc->size) index = 0;
+	e = & sc->table[index];
+	key = e->key;
+	if (key.a == IIIIIScNIL) {
+#ifdef DEBUGSC
+	  CheckOutHashTable(sc);
+#endif DEBUGSC
+	  return;
+	}
+	/* rehashing is done by removing then reinserting */
+	value = e->value;
+	e->key.a = IIIIIScNIL;
+	e->value = IIIIIScNIL;
+	sc->count--;
+	IIIIIScInsert(sc, key.a, key.b, key.c, key.d, value);
+      }
+    }
+    if (++index >= sc->size) index = 0;
+  }
+}
+
+/* DEBUGGING: Print the sc */
+void IIIIIScPrint(sc)
+register IIIIISc sc;
+{
+  int index;
+  register IIIIIScTEPtr e;
+
+  printf(
+    "\nDump of sc @ 0x%05x, %d entr%s, current max %d\nIndex\tKey                                            \tValue\n",
+    sc, sc->count, sc->count == 1 ? "y" : "ies",  sc->maxCount);
+  for (index = 0; index < sc->size; index++) {
+    e = &sc->table[index];
+    printf("%3d\t0x%08.8x 0x%08.8x 0x%08.8x 0x%08.8x\t%08.8x\n", index, e->key.a, e->key.b, e->key.c, e->key.d, e->value);
+  }
+}
+
+#ifdef DEBUGSC
+/* Make sure that the hash table is internally consistent:
+ *      every key is findable, 
+ *      count reflects the number of elements
+ */
+static void CheckOutHashTable(sc)
+register IIIIISc sc;
+{
+  register int i;
+  register IIIIIScTEPtr realElement, e;
+  register int index, firstIndex, count;
+  count = 0;
+
+  for (i = 0; i < sc->size; i++) {
+    realElement = &sc->table[i];
+    if (realElement->key.a != IIIIIScNIL) {
+      count++;
+      index = Hash(realElement->key.a, realElement->key.b, realElement->key.c, realElement->key.d, sc);
+      firstIndex = index;
+      while (1) {
+	e = &sc->table[index];
+	if (e->key.a == IIIIIScNIL) {           /* we did not find it */
+	  break;
+	} else if (IIIIIScCOMPARE(e->key, realElement->key.a, realElement->key.b, realElement->key.c, realElement->key.d)) {
+	  break;
+	} else {
+	  index++;
+	  if (index >= sc->size) index = 0;
+	  if (index == firstIndex) {
+	    index = -1;
+	    break;
+	  }
+	}
+      }
+      
+      if (index == -1 || !IIIIIScCOMPARE(e->key, realElement->key)) {
+FIX THIS
+	fprintf(stderr,
+	  "Sc problem: Key 0x%x, rightIndex %d, realIndex %d value 0x%x\n",
+	  realElement->key, firstIndex, index, realElement->value);
+	IIIIIScPrint(sc);
+      }
+    }
+  }  
+  if (count != sc->count) {
+    fprintf(stderr,
+      "Sc problem: Should have %d entries, but found %d.\n", sc->count,
+      count);
+    IIIIIScPrint(sc);
+  }
+}
+#endif
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/iiiiisc.h ubc-latest-src/vm/src/iiiiisc.h
--- sourceforge-1.06alpha/vm/src/iiiiisc.h	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/iiiiisc.h	2017-12-11 17:59:03.488711444 +0100
@@ -0,0 +1,98 @@
+/*
+ * IIIIIScs (searchable collections) are things that map 
+ * elements of some domain onto some range.  Operations:
+ *	create, destroy, insert, lookup, size, and print
+ */
+
+#ifndef _EMERALD_IIIIISC_H
+#define _EMERALD_IIIIISC_H
+
+#include "memory.h"
+
+/*
+ * This one is crafted differently from all others in that it takes its key
+ as separate integers, and so needed a fair amount of hand editing.
+ */
+typedef struct {
+  int a, b, c, d;
+} IIIIIScDomainType;
+#define IIIIIScRangeType  int
+#define IIIIIScHASH(W,X,Y,Z) ((unsigned)((W) ^ ((X)<<4) ^ (Y) ^ ((Z) >> 4)))
+#define IIIIIScCOMPARE(K,W,X,Y,Z) ((K).a==(W)&&(K).b==(X)&&(K).c==(Y)&&(K).d==(Z))
+#define IIIIIScNIL (-1)
+
+/*
+ * Hidden, private type declarations.  The only thing
+ * that applications of this package are to see is IIIIISc,
+ * and they are to treat it as opaque:  that is, they may
+ * assign it, and pass it as arguments, but not manipulate
+ * what it points to directly.
+ */
+
+typedef struct IIIIIScTE {
+    IIIIIScDomainType	 key;		/* the key for this entry */
+    IIIIIScRangeType	 value;		/* what we want */
+} IIIIIScTE, *IIIIIScTEPtr;
+
+typedef struct IIIIIScRecord {
+    IIIIIScTEPtr table;
+    int size, maxCount, count;
+} IIIIIScRecord, *IIIIISc;
+
+/* OPERATIONS */
+
+/* Return a new, empty Searchable Collection */
+IIIIISc IIIIIScCreate(void);
+
+/* Destroy a collection */
+void IIIIIScDestroy(IIIIISc sc);
+
+/* Insert the pair <key, value> into collection IIIIISc */
+void IIIIIScInsert(/* IIIIISc sc, int a, int b, int c, int d, IIIIIScRangeType value */);
+
+/* bump the value associated with some given key in the IIIIISc */
+int IIIIIScBump(/* IIIIISc sc, int a, int b, int c, int d*/);
+
+/* bump the value associated with some given key in the IIIIISc by value */
+int IIIIIScBumpBy(/* IIIIISc sc, int a, int b, int c, int d, int value*/);
+
+/* Delete the pair with key key from the collection IIIIISc */
+void IIIIIScDelete(/* IIIIISc sc, int a, int b, int c, int d */);
+
+/* Return the value associated with key in collection 
+ * IIIIISc, or 0 if no such pair exists */
+int IIIIIScLookup(/* IIIIISc sc, int a, int b, int c, int d */);
+
+/* DEBUGGING: Print the collection IIIIISc */
+void IIIIIScPrint(/* IIIIISc sc */);
+
+/* Iterate over the elements of the collection IIIIISc.  
+ * At each iteration, IIIIISckey and IIIIIScvalue are set to the next
+ * <key, value> pair in the collection.  
+ * Usage:
+ *	IIIIIScForEach(someSc, key, value) {
+ *	  / * whatever you want to do with key, value * /
+ *	} IIIIIScNext();
+ */
+#define IIIIIScForEach(IIIIISc, IIIIISckeya, IIIIISckeyb, IIIIISckeyc, IIIIIISckeyd, IIIIIScvalue) \
+  { \
+    int IIIIIScxx_index; \
+    for (IIIIIScxx_index = 0; IIIIIScxx_index < (IIIIISc)->size; IIIIIScxx_index++) { \
+      if ((IIIIISc)->table[IIIIIScxx_index].key != IIIIIScNIL) { \
+	*(int*)(&(IIIIISckeya)) = (IIIIISc)->table[IIIIIScxx_index].key.a; \
+	*(int*)(&(IIIIISckeyb)) = (IIIIISc)->table[IIIIIScxx_index].key.b; \
+	*(int*)(&(IIIIISckeyc)) = (IIIIISc)->table[IIIIIScxx_index].key.c; \
+	*(int*)(&(IIIIISckeyd)) = (IIIIISc)->table[IIIIIScxx_index].key.d; \
+	*(IIIIIScRangeType *)(&(IIIIIScvalue)) = (IIIIISc)->table[IIIIIScxx_index].value; \
+	{ 
+
+#define IIIIIScNext() \
+	} \
+      } \
+    } \
+  }
+
+/* Return the number of elements in IIIIISc */
+#define IIIIIScSize(IIIIISc) ((IIIIISc)->count)
+
+#endif /* _EMERALD_IIIIISC_H */
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/iixsc.h ubc-latest-src/vm/src/iixsc.h
--- sourceforge-1.06alpha/vm/src/iixsc.h	2017-12-11 17:59:03.089714485 +0100
+++ ubc-latest-src/vm/src/iixsc.h	2017-12-11 17:59:03.488711444 +0100
@@ -27,6 +5,8 @@
 #define _EMERALD_IIXSC_H
 
 #include "iisc.h"
+#define IIXScNIL IIScNIL
+#define IIXScIsNIL(x) IIScIsNIL(x)
 
 #define SMALLONES (2 * 1024 + 3)
 
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/ilist.c ubc-latest-src/vm/src/ilist.c
--- sourceforge-1.06alpha/vm/src/ilist.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/ilist.c	2017-12-11 17:59:03.488711444 +0100
@@ -0,0 +1,126 @@
+/*
+ * Sequences:  Expanding arrays of keys
+ *  Adopted by Kim Gillies from Dr. Norm Hutchinson's iset.c
+ *  In sequence structure, count is the current number of items in the 
+ *  array, size is the physical length of the array
+ */
+
+#include "system.h"
+
+#include "assert.h"
+#include "ilist.h"
+
+static int sizes[] = {
+  5, 7, 17, 31,
+  67, 131, 257, 521,
+  1031, 2053, 4099, 8093,
+  16193, 32377, 65557, 131071,
+  262187, 524869, 1048829, 2097223,
+  4194371, 8388697, 16777291 };
+
+/* Return a new, empty ISet */
+IList IListCreate()
+{
+  register int i;
+  register IList sq;
+
+  sq = (IList) vmMalloc(sizeof(IListRecord));
+  if (sq == NULL) return NULL;
+  sq->size = sizes[0];
+  sq->count = 0;
+  sq->table = (IListTEPtr) vmMalloc((unsigned) sq->size * sizeof(IListTE));
+  if (sq->table == NULL) return NULL;
+  for (i = 0; i < sq->size; i++) {
+    sq->table[i].key = (int)NULL;
+  }
+  return sq;
+}
+
+void IListDestroy(sq)
+register IList sq;
+{
+  vmFree((char *)sq->table);
+  vmFree((char *)sq);
+}
+
+/* Expand the array.  Each element in the table is copied 
+ * in the new table.  The new space is initialized to NULL
+ */
+static void ExpandTable(IList sq)
+{
+  register int oldTableSize = sq->size, i;
+
+  for (i = 0; sizes[i] <= oldTableSize; i++) ;
+  sq->size = sizes[i];			/* the new size  */
+  sq->table = (IListTEPtr)vmRealloc(sq->table, (sq->size *sizeof(IListTE)));
+  for (i = oldTableSize; i < sq->size; i++) {
+    sq->table[i].key = (int)NULL;
+  }
+}
+
+/* Is key in the sequence sq, if so--return it (probably stupid) */
+IListDomainType IListMember(sq, key)
+register IList sq;
+register IListDomainType  key;
+{
+  register IListTEPtr e;
+  register int index, count;
+
+  count = sq->count;
+  for (index = 0; index < count; index++) {
+    e = &sq->table[index];
+    if (IListCOMPARE(e->key, key)) {
+      return e->key;
+    }
+  }
+  /* nothing found */
+  return (int)NULL;
+}
+
+/* Add the key to the end of sq */
+void IListInsert(sq, key)
+register IList sq;
+register IListDomainType key;
+{
+  register int count;
+
+  count = sq->count;
+  if (count >= sq->size) ExpandTable(sq);
+  sq->table[count].key = key;
+  sq->count++;
+}
+
+/* Remove the entry, if it is there */
+void IListDelete(sq, key)
+register IList sq;
+register IListDomainType key;
+{
+  register int index, count, j;
+
+  count = sq->count;
+  for (index = 0; index < count; index++) {
+    if (IListCOMPARE(sq->table[index].key, key)) {
+      for (j = index+1; j < count; j++) {
+	sq->table[j-1].key = sq->table[j].key;
+      }
+      sq->count--;
+      return;
+    }
+  }
+}
+
+/* DEBUGGING: Print the sq */
+void IListPrint(sq)
+register IList sq;
+{
+  IListDomainType key;
+  int index;
+
+  printf(
+    "\nDump of sq @ 0x%05x, %d entr%s, current max %d\n    Index\tKey\n",
+    (int)sq, sq->count, sq->count == 1 ? "y" : "ies",  sq->size);
+  for (index = 0; index < sq->size; index++) {
+    key = sq->table[index].key;
+    printf("%3d\t%-16.16d\n", index, key);
+  }
+}
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/ilist.h ubc-latest-src/vm/src/ilist.h
--- sourceforge-1.06alpha/vm/src/ilist.h	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/ilist.h	2017-12-11 17:59:03.488711444 +0100
@@ -0,0 +1,127 @@
+/*
+ * Seqs are an array sequence of some domain.
+ * Operations:
+ *	create, destroy, insert, member, size, and print
+ */
+
+#ifndef _EMERALD_ILIST_H
+#define _EMERALD_ILIST_H
+/*
+ * Before using this, one must define the following:
+ *	IListDomainType	- a typedef for the domain
+ *	IListCOMPARE	- a macro that compares two elements of 
+ *				  the domain, evaluating to 1 if they are 
+ *				  the same
+ */
+#define IListDomainType int
+#define IListCOMPARE(X,Y) ((X)==(Y))
+
+/*
+ * Hidden, private type declarations.  The only thing
+ * that applications of this package are to see is IList,
+ * and they are to treat it as opaque:  that is, they may
+ * assign it, and pass it as arguments, but not manipulate
+ * what it points to directly.
+ */
+
+typedef struct IListTE {
+    IListDomainType key;		/* the key for this entry */
+} IListTE, *IListTEPtr;
+
+typedef struct IListRecord {
+    IListTEPtr table;
+    int size, count;
+} IListRecord, *IList;
+
+/* OPERATIONS */
+
+/* Return a new, empty Searchable Collection */
+IList IListCreate(void);
+
+/* Destroy a collection */
+void IListDestroy(IList);
+
+/* Insert the key into the set IList */
+void IListInsert(IList sq, IListDomainType key);
+
+/* Delete the key key from the set IList */
+void IListDelete(IList sq, IListDomainType key);
+
+/* Return the key if it is in the set otherwise NULL */
+IListDomainType IListMember(IList sc, IListDomainType key);
+
+/* DEBUGGING: Print the collection IList */
+void IListPrint(IList sc);
+
+/* Iterate over the elements of the collection IList.  
+ * At each iteration, IListkey is set to the next key in the set.  
+ * Usage:
+ *	IListForEach(someSq, key) {
+ *	  / * whatever you want to do with key * /
+ *	} IListNext();
+ */
+#define IListForEach(IList, IListkey) \
+  { \
+    int IListxx_index; \
+    for (IListxx_index = 0; IListxx_index < (IList)->count; IListxx_index++) { \
+      *(IListDomainType*)(&(IListkey)) = IList->table[IListxx_index].key; \
+      { 
+
+/* Iterate over the elements of the collection IList.  
+ * At each iteration, IListkey is set to the next key in the set.  
+ * Usage:
+ *	IListForEachReverse(someSq, key) {
+ *	  / * whatever you want to do with key * /
+ *	} IListNext();
+ */
+#define IListForEachReverse(IList, IListkey) \
+  { \
+    int IListxx_index; \
+    for (IListxx_index = (IList->count-1); IListxx_index >= 0; IListxx_index--) { \
+      *(IListDomainType*)(&(IListkey)) = IList->table[IListxx_index].key; \
+      { 
+
+/* Iterate over the elements of the collection IList, two at a time.
+ * At each iteration, IListkey1 and IListkey2 are set to the next keys
+ * in the list.
+ * Usage:
+ *	IListForEachByTwo(someSq, key1, key2) {
+ *	  / * whatever you want to do with key1 and key2 * /
+ *	} IListNext();
+ */
+#define IListForEachByTwo(IList, IListkey1, IListkey2) \
+  { \
+    int IListxx_index; \
+    for (IListxx_index = 0; IListxx_index < (IList)->count; IListxx_index += 2) { \
+      *(IListDomainType*)(&(IListkey1)) = IList->table[IListxx_index].key; \
+      *(IListDomainType*)(&(IListkey2)) = IList->table[IListxx_index+1].key; \
+      {
+
+/* Iterate over the elements of the collection IList, three at a time.
+ * At each iteration, IListkey1, IListkey2, IListkey3 are set to the next
+ * keys in the set.
+ * Usage:
+ *	IListForEachByThree(someSq, key1, key2, key3) {
+ *	  / * whatever you want to do with key1, key2, key3 * /
+ *	} IListNext();
+ */
+#define IListForEachByThree(IList, IListkey1, IListkey2, IListkey3) \
+  { \
+    int IListxx_index; \
+    for (IListxx_index = 0; IListxx_index < (IList)->count; IListxx_index += 3) { \
+      *(IListDomainType*)(&(IListkey1)) = IList->table[IListxx_index].key; \
+      *(IListDomainType*)(&(IListkey2)) = IList->table[IListxx_index+1].key; \
+      *(IListDomainType*)(&(IListkey3)) = IList->table[IListxx_index+2].key; \
+      {
+
+#define IListNext() \
+      } \
+    } \
+  }
+
+/* Return the number of elements in IList */
+#define IListSize(IList) ((IList)->count)
+
+#include "storage.h"
+
+#endif /* _EMERALD_ILIST_H */
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/io.c ubc-latest-src/vm/src/io.c
--- sourceforge-1.06alpha/vm/src/io.c	2017-12-11 17:59:03.089714485 +0100
+++ ubc-latest-src/vm/src/io.c	2017-12-11 17:59:03.488711444 +0100
@@ -33,11 +11,13 @@
 #include "timer.h"
 #include "trace.h"
 
+#if !defined(NTRACE)
 static char *EIONames[] = {
   "EIO_Read",
   "EIO_Write",
   "EIO_Except"
 };
+#endif
 
 static fd_set io_sets[3];
 static fd_set data_available;
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/jsys.c ubc-latest-src/vm/src/jsys.c
--- sourceforge-1.06alpha/vm/src/jsys.c	2017-12-11 17:59:03.089714485 +0100
+++ ubc-latest-src/vm/src/jsys.c	2017-12-11 17:59:03.489711436 +0100
@@ -51,6 +29,12 @@
  * Here is our lnn, whatever inet_lnaof returns
  */
 static int syslnn = -1;
+
+/*
+ * Our incarnation time is created in remote.c:init_nodeinfo.
+ */
+extern Object inctm;
+
 /*
  * Here are pointers to our standard input and output streams
  */
@@ -96,10 +80,32 @@
 
 int getname(State *state)
 {
+  TRACE(sys, 1, ("getname returns %.*s", SysName->d.items, SysName->d.data));
   PUSH(String, SysName);
   return 0;
 }
 
+int jgetIncarnationTime(State *state)
+{
+  PUSH(Object, inctm);
+  return 0;
+}
+
+int jgetLoadAverage(State *state)
+{
+  double avg = 1.0;
+  int ret;
+#if defined(i386freebsd)
+  ret = getloadavg(&avg, 1);
+  if (ret < 1) {
+    TRACE(sys, 0, ("getloadavg failed, ret %d", ret));
+    avg = 1.0;
+  }
+#endif
+  PUSH(float, (float) avg);
+  return 0;
+}
+
 int jisfixed(State *state)
 {
   ConcreteType ct;
@@ -184,7 +190,7 @@
 int jfix(State *state)
 {
   ConcreteType ct, d_ct;
-  Object obj, d, dn;
+  Object obj, d;
   int retc = 0;
 
   obj = *(Object *)sp;
@@ -197,7 +203,7 @@
   if (ISNIL(obj) || !HASODP(ct->d.instanceFlags) || ISIMUT(ct->d.instanceFlags)) {
     /* do nothing */
   } else {
-    dn = whereIs(d, d_ct);
+    Object dn = whereIs(d, d_ct);
     if (ISNIL(dn)) {
       return unavailable(state, d);
     } else if (RESDNT(dn->flags) && RESDNT(obj->flags)) {
@@ -214,7 +220,7 @@
 int jrefix(State *state)
 {
   ConcreteType ct, d_ct;
-  Object obj, d, dn;
+  Object obj, d;
   int retc = 0;
 
   obj = *(Object *)sp;
@@ -227,7 +233,7 @@
   if (ISNIL(obj) || !HASODP(ct->d.instanceFlags) || ISIMUT(ct->d.instanceFlags)) {
     /* do nothing */
   } else {
-    dn = whereIs(d, d_ct);
+    Object dn = whereIs(d, d_ct);
     if (ISNIL(dn)) {
       return unavailable(state, d);
     } else if (RESDNT(dn->flags) && RESDNT(obj->flags)) {
@@ -263,7 +269,7 @@
 int jmove(State *state)
 {
   ConcreteType ct, d_ct;
-  Object obj, d, dn;
+  Object obj, d;
   int retc = 0;
 
   obj = *(Object *)sp;
@@ -275,7 +281,7 @@
   if (ISNIL(obj) || !HASODP(ct->d.instanceFlags) || ISIMUT(ct->d.instanceFlags)) {
     /* do nothing */
   } else {
-    dn = whereIs(d, d_ct);
+    Object dn = whereIs(d, d_ct);
     if (ISNIL(dn)) {
       return unavailable(state, d);
     } else if (RESDNT(dn->flags) && RESDNT(obj->flags)) {
@@ -348,7 +354,7 @@
 
 #if !defined(WIN32)
   if (gethostname(name, sizeof name) < 0) {
-    TRACE(dist, 0, ("Can't get my own host name, making one up"));
+    fprintf(stderr, "Can't get my own host name, making one up\n");
     strcpy(name, "imaginary");
   }
 
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/jsys.h ubc-latest-src/vm/src/jsys.h
--- sourceforge-1.06alpha/vm/src/jsys.h	2017-12-11 17:59:03.089714485 +0100
+++ ubc-latest-src/vm/src/jsys.h	2017-12-11 17:59:03.489711436 +0100
@@ -59,4 +37,6 @@
 #define JREFIX 36
 #define JLOCATE 37
 #define ISFIXED 38
-#define JSYS_OPS 39
+#define JGETINCARNATIONTIME 39
+#define JGETLOADAVERAGE 40
+#define JSYS_OPS 41
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/locate.c ubc-latest-src/vm/src/locate.c
--- sourceforge-1.06alpha/vm/src/locate.c	2017-12-11 17:59:03.090714477 +0100
+++ ubc-latest-src/vm/src/locate.c	2017-12-11 17:59:03.489711436 +0100
@@ -134,7 +112,9 @@
     } else if (SameNode(srv, limbo)) {
       sendUnavailableReply(str);
     } else {
-      sendMsg(srv, str);
+	if (sendMsg(srv, str) < 0) {
+	    TRACE(locate, 1, ("locationResolved:  can't send reply"));
+	};
     }
   } ISetNext();
   ISetDestroy(l->waitingMsgs);
@@ -323,7 +303,9 @@
     replyh.kind = LocateReply;
     replyh.status = 0;		/* Found it here */
     reply = StartMsg(&replyh);
-    sendMsg(h->sslocation, reply);
+    if (sendMsg(h->sslocation, reply) < 0) {
+	TRACE(locate, 1, ("handleLocationRequest: can't send found it here reply"));
+    }
   } else if (h->option1 == 0) {
     /* Forwarding is allowed */
     if (ISNIL(obj) || SameNode(loc, limbo) || SameNode(loc, srv) || forwardMsg(loc, h, str) < 0) {
@@ -332,11 +314,13 @@
       replyh.kind = LocateReply;
       replyh.status = 1;	/* Not found */
       reply = StartMsg(&replyh);
-      sendMsg(h->sslocation, reply);
+      if (sendMsg(h->sslocation, reply) < 0) {
+	  TRACE(locate, 1, ("handleLocationRequest: can't send not found reply"));
+      }
       TRACE(locate, 4, ("Can't find %s reply to %s",
 			 OIDString(h->target), NodeString(srv)));
     } else {
-      TRACE(locate, 4, ("Forwarding request to %s", NodeString(loc)));
+      TRACE(locate, 4, ("FIXME: Not really forwarding request to %s", NodeString(loc)));
     }
   } else {
     TRACE(locate, 4, ("Got a demand-reply location request for a non resident object"));
@@ -344,7 +328,9 @@
     replyh.kind = LocateReply;
     replyh.status = 1;		/* Not here */
     reply = StartMsg(&replyh);
-    sendMsg(srv, reply);
+    if (sendMsg(srv, reply) < 0) {
+	TRACE(locate, 1, ("handleLocationRequest: can't send not found reply"));
+    }
   }
 }
 
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/main.c ubc-latest-src/vm/src/main.c
--- sourceforge-1.06alpha/vm/src/main.c	2017-12-11 17:59:03.090714477 +0100
+++ ubc-latest-src/vm/src/main.c	2017-12-11 17:59:03.489711436 +0100
@@ -61,6 +39,8 @@
 int debugInteractively = 0;
 int gotsigint = 0;
 int checkSameUser = 1;
+int offsetbyuserid = 1;
+int fakeUnavailable = 0;
 int debugFirst = 0;
 extern int checkpointBuiltins;
 extern void statistics(void);
@@ -104,7 +84,7 @@
            p_guaranteeInterGcInterval;
 extern int bytesPerGeneration, copyCount, old_size;
 extern void gc_init(void (*)(void), void (*)(void), void (*)(void), void (*)(void));
-extern void gc_stats (int *tg, int *og, int *n, int *no);
+extern void gc_stats (int *tg, int *og, int *n, int *no, int *nd, int *ndr);
 extern void init_nodeinfo(void), sysinit(void);
 extern int parseTraceFlag(char *), init_upcall(void), interpret(struct State *);
 
@@ -239,6 +219,13 @@
       case '1':
 	activelyInitialize = value;
 	break;
+      case 'f':
+	++x;
+	value = mstrtol(&av[0][x], 0, 0);
+	fakeUnavailable = value;
+	if (fakeUnavailable < 1) fakeUnavailable = 1;
+	if (fakeUnavailable > 100) fakeUnavailable = 100;
+	break;
       case 'F':
 	SetTraceFile(&av[0][x+1]);
 	break;
@@ -329,6 +316,9 @@
 	debugFirst = value;
 	if (value) debugInteractively = 1;
 	break;
+      case 'u':
+	offsetbyuserid = value;
+	break;
       case 'U':
 	checkSameUser = 0;
 	break;
@@ -473,14 +463,14 @@
 {
   if (beVerbose) {
     int tg, og, time;
-    int n, no;
-    extern int totalbytecodes;
+    int n, no, nd, ndremoved;
+    extern long long totalbytecodes;
 
     time = currentCpuTime();
     
-    printf("Executed %d bytecodes in %d.%02d seconds\n", 
+    printf("Executed %lld bytecodes in %d.%02d seconds\n", 
 	   totalbytecodes, time/100, time%100);
-    gc_stats(&tg, &og, &n, &no);
+    gc_stats(&tg, &og, &n, &no, &nd, &ndremoved);
     if (n > 0) {
       if (bytesPerGeneration % 1024 == 0) {
 	printf("%d gcs in %d*%d*%dk = %d Kbytes, time %d.%02d\n", n,
@@ -504,6 +494,9 @@
       }
     }
 #ifdef DISTRIBUTED
+    if (nd > 0) {
+		printf("%d distributed gcs freed %d objects\n", nd, ndremoved);
+	}
     printf("Received %d messages (%d bytes), sent %d messages (%d bytes)\n",
 	   nMessagesReceived, nBytesReceived, nMessagesSent, nBytesSent);
 #endif
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/Makefile ubc-latest-src/vm/src/Makefile
--- sourceforge-1.06alpha/vm/src/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/Makefile	2017-12-11 17:59:03.483711482 +0100
@@ -0,0 +1,332 @@
+#
+# emx Makefile
+#
+
+#
+# These are set in the macroMf file for the particular architecture
+#
+COPT   = $(OPTCOPT)
+VMOPT  = $(OPTVMOPT)
+
+CPFLAGS = -I. -DSINGLESTEP -DCOUNTBYTECODES -DSTDARG_WORKS \
+	$(XCPFLAGS) $(X11FLA) $(LWPFLA)
+
+# no dependencies, these must be kept up to date manually
+LIB = $(XLIB) $(X11LIB) $(LWPLIB) $(EXTRALIB)
+
+.c.o:
+	rm -f $*.o ; $(CC) -c $(CFLAGS) $*.c
+
+.c.s:
+	rm -f $*.o ; $(CC) -S $(CFLAGS) $*.c
+
+CFLAGS   = $(CPFLAGS) $(COPT)
+VMFLAGS  = $(CPFLAGS) $(VMOPT)
+
+INC = \
+	array.h \
+	assert.h \
+	bufstr.h \
+	builtins.h \
+	call.h \
+	concurr.h \
+	config.h \
+	creation.h \
+	dist.h \
+	extract.h \
+	filestr.h \
+	gaggle.h \
+	gc.h \
+	globals.h \
+	iisc.h \
+	iixsc.h \
+	init.h \
+	insert.h \
+	io.h \
+	iosc.h \
+	iset.h \
+	joveisc.h \
+	jsys.h \
+	jvisc.h \
+	locate.h \
+	misc.h \
+	move.h \
+	mqueue.h \
+	oidtoobj.h \
+	oisc.h \
+	ooisc.h \
+	otable.h \
+	read.h \
+	remote.h \
+	rinvoke.h \
+	squeue.h \
+	storage.h \
+	streams.h \
+	system.h \
+	timer.h \
+	trace.h \
+	types.h \
+	vm.h \
+	vm_i.h \
+	vm_exp.h \
+	write.h \
+	$(X11INC) \
+	$(LWPINC)
+
+REALSRC = \
+	array.c \
+	bufstr.c \
+	call.c \
+	conform.c \
+	creation.c \
+	debug.c \
+	dist.c \
+	distgc.c \
+	filestr.c \
+	gaggle.c \
+	gc.c \
+	globals.c \
+	iisc.c \
+	iixsc.c \
+	io.c \
+	iosc.c \
+	iset.c \
+	joveisc.c \
+	jsys.c \
+	jvisc.c \
+	locate.c \
+	main.c \
+	misc.c \
+	move.c \
+	mqueue.c \
+	oidtoobj.c \
+	oisc.c \
+	ooisc.c \
+	otable.c \
+	read.c \
+	remote.c \
+	rinvoke.c \
+	squeue.c \
+	storage.c \
+	streams.c \
+	timer.c \
+	trace.c \
+	upcall.c \
+	vm.c \
+	write.c \
+	$(X11SRC) \
+	$(LWPSRC)
+
+CCALLSOBJ = cctab.o $(CCALLS_OBJ)
+
+CCALLSSRC = cctab.c $(CCALLS_SRC) 
+
+SRC =	$(REALSRC) $(CCALLSSRC) vm.d
+
+OBJ = \
+	vm.o \
+	array.o \
+	bufstr.o \
+	call.o \
+	conform.o \
+	creation.o \
+	debug.o \
+	dist.o \
+	distgc.o \
+	filestr.o \
+	gaggle.o \
+	gc.o \
+	globals.o \
+	iisc.o \
+	iixsc.o \
+	io.o \
+	iosc.o \
+	iset.o \
+	joveisc.o \
+	jsys.o \
+	jvisc.o \
+	locate.o \
+	main.o \
+	misc.o \
+	move.o \
+	mqueue.o \
+	oidtoobj.o \
+	oisc.o \
+	ooisc.o \
+	otable.o \
+	read.o \
+	remote.o \
+	rinvoke.o \
+	squeue.o \
+	storage.o \
+	streams.o \
+	timer.o \
+	trace.o \
+	upcall.o \
+	write.o \
+	$(GCOBJ) \
+	$(CCALLSOBJ) \
+	$(X11OBJ) \
+	$(LWPOBJ)
+
+ASSRC = \
+	vm.s \
+	array.s \
+	bufstr.s \
+	call.s \
+	conform.s \
+	creation.s \
+	debug.s \
+	dist.s \
+	distgc.s \
+	filestr.s \
+	gaggle.s \
+	gc.s \
+	globals.s \
+	iisc.s \
+	iixsc.s \
+	io.s \
+	iosc.s \
+	iset.s \
+	joveisc.s \
+	jsys.s \
+	jvisc.s \
+	locate.s \
+	main.s \
+	misc.s \
+	move.s \
+	mqueue.s \
+	oidtoobj.s \
+	oisc.s \
+	ooisc.s \
+	otable.s \
+	read.s \
+	remote.s \
+	rinvoke.s \
+	squeue.s \
+	storage.s \
+	streams.s \
+	timer.s \
+	trace.s \
+	upcall.s \
+	write.s \
+	$(GCASSRC) \
+	$(CCALLSASSRC) \
+	$(X11ASSRC) \
+	$(LWPASSRC)
+
+LIBDIR = lib/$(ARCH)
+
+LOAD = $(LIBDIR)/userrt0.o $(OBJ) $(LIBDIR)/libxsim.a
+
+all:	emx
+
+install: emx $(EMLIBDIR)/bcdef $(EMLIBDIR)/jsdef
+
+$(EMLIBDIR)/jsdef : jsys.h
+	cp jsys.h $@
+	chmod 664 $@
+
+$(EMLIBDIR)/bcdef : vm.h
+	cp vm.h $@
+	chmod 664 $@
+
+cctab.h cctab.c:	$(EMERALDROOT)/ccalls/*.h $(EMERALDROOT)/lib/$(EMERALDARCH)/macroMf
+	gencctab $(CCALLS_OBJ)
+
+tags:	$(SRC) $(INC)
+	/usr/bin/ctags -tw $(SRC) $(INC)
+
+cxref:	$(SRC) $(INC)
+	cxref `make csrc inc` -xref -html $(CPFLAGS)
+	cxref -index-all -html
+
+vm.c:	vm.d
+	if issymlink vm.c ; then \
+	  mv -f ../src/vm.h ../src/vm.h.orig ; \
+	  mv -f ../src/vm_i.h ../src/vm_i.h.orig ; \
+	  rm -f ../src/vm.c ../src/vm.h ../src/vm_i.h ; \
+	else \
+	  mv -f vm.h vm.h.orig ; \
+	  mv -f vm_i.h vm_i.h.orig ; \
+	  rm -f vm.c vm.h vm_i.h ; \
+	fi
+	vmc vm.d
+	if issymlink vm.c ; then \
+	  if [ -r ../src/vm.h.orig ] && cmp -s ../src/vm.h ../src/vm.h.orig ; then mv ../src/vm.h.orig ../src/vm.h ; fi ; \
+	  if [ -r ../src/vm_i.h.orig ] && cmp -s ../src/vm_i.h ../src/vm_i.h.orig ; then mv ../src/vm_i.h.orig ../src/vm_i.h ; fi ; \
+	else \
+	  if [ -r vm.h.orig ] && cmp -s vm.h vm.h.orig ; then mv vm.h.orig vm.h ; fi ; \
+	  if [ -r vm_i.h.orig ] && cmp -s vm_i.h vm_i.h.orig ; then mv vm_i.h.orig vm_i.h ; fi ; \
+	fi
+	chmod -w vm.c vm.h vm_i.h
+
+vm.o: vm.c types.h
+	rm -f vm.o ; $(CC) $(VMFLAGS) -c vm.c
+
+emx:	$(OBJ)
+	@echo linking...
+	@-rm -f emx.dead
+	@-mv -f emx emx.dead
+	$(CC) $(CFLAGS) $(OBJ) -o emx $(LIB) -lm
+	@-rm -f emx.dead
+
+emx.s:	$(ASSRC)
+
+#
+# Because test -h doesn't work on all machines, we use a
+# machine dependent issymlink script
+#
+links:
+	for x in $(REALSRC) vm.d $(INC) ; do \
+	  if issymlink $$x ; then rm $$x ; fi ; \
+	  ln -s ../src/$$x . ; \
+	done
+
+checkout:
+	for x in $(REALSRC) vm.d $(INC) ; do \
+	  if issymlink $$x ; then \
+	    true; \
+	  else if cmp -s ../src/$$x $$x ; then \
+	    echo "$$x is a copy of the real thing." ; \
+	  else \
+	    echo "Something funny with $$x" ; \
+	    ls -l $$x ; \
+	  fi ; fi ; \
+	done
+
+mothball:	clean
+	for x in $(REALSRC) vm.d $(INC) ; do \
+	  if issymlink $$x ; then \
+	    rm -f $$x ; \
+	  else \
+	    echo "Something funny with $$x" ; \
+	    ls -l $$x ; \
+	  fi ; \
+	done
+	rm Makefile
+
+clean:
+	rm -f emx $(OBJ) $(LWPOBJ)
+
+sources src:
+	@echo $(SRC) | sed -e 's/vm.c//'
+
+csources csrc:
+	@echo $(SRC) | sed -e 's/vm.d//'
+
+objects obj:
+	@echo $(OBJ)
+
+includes inc:
+	@echo $(INC)
+
+# WARNING!  Hackish behaviour below.
+# We require $SRC == $(REALSRC) $(CCALLSSRC) vm.d
+# There appear to be dragons ^H^H^H line length limits on a Unix
+# command, so we have to build dependencies with more than one
+# command line.  Also, we can't do a make depend on vm.d,
+# as it's not legal C, so need to exclude it specifically.
+depend:	$(SRC)
+	$(DEPEND) $(CFLAGS) $(REALSRC) >  Makefile.depend
+	$(DEPEND) $(CFLAGS) $(CCALLSSRC)  >> Makefile.depend
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/Makefile.am ubc-latest-src/vm/src/Makefile.am
--- sourceforge-1.06alpha/vm/src/Makefile.am	2017-12-11 17:59:03.087714500 +0100
+++ ubc-latest-src/vm/src/Makefile.am	1970-01-01 01:00:00.000000000 +0100
@@ -1,123 +0,0 @@
-bin_PROGRAMS = emx
-
-noinst_PROGRAMS = codeptrextra 
-
-noinst_SCRIPTS = gencodeptrextra.sh
-
-EXTRA_DIST =  gencodeptrextra.sh
-
-codeptrextra_SOURCES = codeptrextra.c
-
-emx_SOURCES = array.c \
-	bufstr.c \
-	call.c \
-	conform.c \
-	creation.c \
-	debug.c \
-	dist.c \
-	distgc.c \
-	filestr.c \
-	gaggle.c \
-	gc.c \
-	globals.c \
-	iisc.c \
-	iixsc.c \
-	io.c \
-	iosc.c \
-	iset.c \
-	joveisc.c \
-	jsys.c \
-	jvisc.c \
-	locate.c \
-	main.c \
-	misc.c \
-	move.c \
-	mqueue.c \
-	oidtoobj.c \
-	oisc.c \
-	ooisc.c \
-	otable.c \
-	read.c \
-	remote.c \
-	rinvoke.c \
-	squeue.c \
-	storage.c \
-	streams.c \
-	timer.c \
-	trace.c \
-	upcall.c \
-	vm.c \
-	write.c \
-	cctab.c 
-#\
-#	$(X11SRC) \
-#	$(LWPSRC)
-include_HEADERS = \
-	array.h \
-	assert.h \
-	bufstr.h \
-	builtins.h \
-	call.h \
-	concurr.h \
-	config.h \
-	creation.h \
-	dist.h \
-	extract.h \
-	filestr.h \
-	gaggle.h \
-	gc.h \
-	globals.h \
-	iisc.h \
-	iixsc.h \
-	init.h \
-	insert.h \
-	io.h \
-	iosc.h \
-	iset.h \
-	joveisc.h \
-	jsys.h \
-	jvisc.h \
-	locate.h \
-	misc.h \
-	move.h \
-	mqueue.h \
-	oidtoobj.h \
-	oisc.h \
-	ooisc.h \
-	otable.h \
-	read.h \
-	remote.h \
-	rinvoke.h \
-	squeue.h \
-	storage.h \
-	streams.h \
-	system.h \
-	timer.h \
-	trace.h \
-	types.h \
-	vm.h \
-	vm_i.h \
-	vm_exp.h \
-	write.h \
-	cctab.h \
-	codeptrextra.h 
-#\
-#	$(X11INC) \
-#	$(LWPINC)
-
-emx_LDADD = ../../ccalls/libccalls.a
-
-EMERALDROOT=$(top_srcdir)
-
-BUILT_SOURCES = cctab.c codeptrextra.h
-
-CLEANFILES = cctab.c cctab.h codeptrextra.h
-
-codeptrextra.h:	codeptrextra
-	./gencodeptrextra.sh
-
-cctab.h: cctab.c
-
-cctab.c: Makefile
-	EMERALDROOT=$(top_srcdir) $(top_srcdir)/bin/gencctab.sh `cd $(top_srcdir)/ccalls;ls *.o`
-
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/Makefile.DOS ubc-latest-src/vm/src/Makefile.DOS
--- sourceforge-1.06alpha/vm/src/Makefile.DOS	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/Makefile.DOS	2017-12-11 17:59:03.483711482 +0100
@@ -0,0 +1,460 @@
+#
+# definitions of Emerald
+# global macros
+#
+
+# global definitions
+
+# instead of $(MAKE), use $(EMMAKE) within Makefiles
+
+# some versions of make (notably sgi's and m88k's) use the user's
+# current shell rather than sh to execute commands by default.
+# Twits.
+
+# source for the ccalls lives here
+CCALLSDIR = /emerald/ccalls
+
+# lib material; includes live here, and libraries live in architecture
+# specific subdirectories of here
+EMLIBDIR = /emerald/lib
+EMBINDIR = /emerald/bin
+
+# Installation paths for DOS
+EMLIBXDIR = \emerald\lib
+EMBINXDIR = \emerald\bin
+
+# defaults.  May be overridden in architecture specific macroMakefiles
+
+# ranlib
+RANLIB = ranlib
+
+# awk
+AWK = awk
+
+# sed
+SED = sed
+
+CP = copy
+CHMOD = rem
+#
+# i386mach specific definitions
+# of commonly-used macros
+#
+
+# architecture definition
+
+# (ANSI) C compiler
+CC = gcc
+
+# definitions to enable common extensions in headers and libraries
+XGCCPFLAGS =
+
+XCPFLAGS = -DDOS -DEMERALDROOT=\"/emerald\"
+
+XLIB =
+
+# C preprocessor
+CPP = gcc -E
+
+# dependency generator
+DEPEND = gcc -MM
+
+# debugging information, no warnings
+CFLAGSDBG = -g -O2
+DBGCOPT   = $(CFLAGSDBG)
+DBGCPROPT = $(CFLAGSDBG)
+DBGVMOPT  = $(CFLAGSDBG)
+
+# maximum optimization, no warnings
+CFLAGSOPT = -O2
+OPTCOPT   = $(CFLAGSOPT)
+OPTCPROPT = $(CFLAGSOPT) -fno-force-mem
+OPTVMOPT  = $(CFLAGSOPT)
+
+#
+# emx Makefile
+#
+
+#
+# For debugging
+#
+# COPT   = $(DBGCOPT)
+# CPROPT = $(DBGCPROPT)
+# VMOPT  = $(DBGVMOPT)
+
+#
+# For optimizing
+#
+COPT   = $(OPTCOPT)
+CPROPT = $(OPTCPROPT)
+VMOPT  = $(OPTVMOPT)
+
+#
+# For xkernel
+#
+# LWPFLA = -DCONCURRENT -DXKERNEL -Ishare -Iprotocols -Isimul -DUNIX
+# LWPLIB =
+
+#
+# For suns sunlwp
+#
+# LWPFLA = -DCONCURRENT -DSUNLWP '-DLWPINDIR='
+# LWPLIB = -lnbio -llwp
+
+
+CCALLSCPFLAGS = -I$(EMLIBDIR) -I$(CCALLSDIR)/misc \
+        -I$(CCALLSDIR)/regexp -I$(CCALLSDIR)/streams
+
+CPFLAGS = $(XCPFLAGS) \
+	-I. -I$(EMLIBDIR) \
+	-DIMPLEMENTCONCURRENCY -UTIMESLICE \
+	-DSINGLESTEP -DCOUNTBYTECODES \
+	$(X11FLA) $(LWPFLA)
+
+# no dependencies, these must be kept up to date manually
+LIB = -L$(EMLIBDIR) $(XLIB) $(X11LIB) $(LWPLIB)
+
+.c.o:
+	$(CC) -c $(CFLAGS) $*.c
+
+CFLAGS   = $(COPT)   $(CPFLAGS)
+CPRFLAGS = $(CPROPT) $(CPFLAGS)
+VMFLAGS  = $(VMOPT)  $(CPFLAGS)
+
+INC = \
+	array.h \
+	assert.h \
+	builtins.h \
+	codemsg.h \
+	concurr.h \
+	creation.h \
+	decmsg.h \
+	encmsg.h \
+	error.h \
+	filestr.h \
+	gc.h \
+	globals.h \
+	hash.h \
+	iisc.h \
+	iixsc.h \
+	ilist.h \
+	init.h \
+	iosc.h \
+	iset.h \
+	joveisc.h \
+	jsys.h \
+	jvisc.h \
+	memory.h \
+	message.h \
+	misc.h \
+	oidtoobj.h \
+	oisc.h \
+	ooisc.h \
+	read.h \
+	sisc.h \
+	sockstr.h \
+	squeue.h \
+	streams.h \
+	trace.h \
+	types.h \
+	unalign.h \
+	vm.h \
+	vm_i.h \
+	vm_exp.h \
+	write.h \
+	$(X11INC)
+
+REALSRC = \
+	array.c \
+	codemsg.c \
+	conform.c \
+	creation.c \
+	debug.c \
+	decmsg.c \
+	encmsg.c \
+	error.c \
+	filestr.c \
+	gc.c \
+	globals.c \
+	hash.c \
+	iisc.c \
+	iixsc.c \
+	ilist.c \
+	iosc.c \
+	iset.c \
+	joveisc.c \
+	jsys.c \
+	jvisc.c \
+	main.c \
+	message.c \
+	misc.c \
+	oidtoobj.c \
+	oisc.c \
+	ooisc.c \
+	read.c \
+	sisc.c \
+	sockstr.c \
+	squeue.c \
+	streams.c \
+	trace.c \
+	vm.c \
+	write.c \
+	$(X11SRC)
+
+CCALLSOBJ = cctab.o emstream.o hello.o regexp.o regsub.o regerror.o string.o
+
+CCALLSSRC = $(EMLIBDIR)/cctab.c $(CCALLSDIR)/streams/emstream.c \
+        $(EMLIBDIR)/misc/hello.c $(EMLIBDIR)/regexp/regexp.c \
+        $(EMLIBDIR)/regexp/regsub.c $(EMLIBDIR)/regexp/regerror.c \
+	$(EMLIBDIR)/string/string.c
+
+SRC =   $(REALSRC) $(CCALLSSRC) vm.d
+
+OBJ = \
+	array.o \
+	codemsg.o \
+	conform.o \
+	creation.o \
+	debug.o \
+	decmsg.o \
+	encmsg.o \
+	error.o \
+	filestr.o \
+	gc.o \
+	globals.o \
+	hash.o \
+	iisc.o \
+	iixsc.o \
+	ilist.o \
+	iosc.o \
+	iset.o \
+	joveisc.o \
+	jsys.o \
+	jvisc.o \
+	main.o \
+	message.o \
+	misc.o \
+	oidtoobj.o \
+	oisc.o \
+	ooisc.o \
+	read.o \
+	sisc.o \
+	sockstr.o \
+	squeue.o \
+	streams.o \
+	trace.o \
+	vm.o \
+	write.o \
+	$(GCOBJ) \
+	$(CCALLSOBJ) \
+	$(X11OBJ)
+
+LIBDIR = lib/$(ARCH)
+
+LOAD = $(LIBDIR)/userrt0.o $(OBJ) $(LIBDIR)/libxsim.a
+
+all:    emx.exe
+
+install: $(EMBINDIR)/emx.exe $(EMLIBDIR)/bcdefs
+
+$(EMLIBDIR)/bcdefs : vm.h
+	$(CP) vm.h $(EMLIBXDIR)\bcdefs
+	$(CHMOD) 664 $(EMLIBXDIR)\bcdefs
+
+$(EMBINDIR)/emx.exe : emx.exe
+	$(CP) emx.exe $(EMBINXDIR)\emx.exe
+
+cctab.o:
+	$(CC) -c $(CCALLSCPFLAGS) $(CFLAGS) $(EMLIBDIR)/cctab.c
+
+emstream.o:
+	$(CC) -c $(CCALLSCPFLAGS) $(CFLAGS) $(CCALLSDIR)/streams/emstream.c
+
+hello.o:
+	$(CC) -c $(CCALLSCPFLAGS) $(CFLAGS) $(CCALLSDIR)/misc/hello.c
+
+regexp.o:
+	$(CC) -c $(CCALLSCPFLAGS) $(CFLAGS) $(CCALLSDIR)/regexp/regexp.c
+
+regsub.o:
+	$(CC) -c $(CCALLSCPFLAGS) $(CFLAGS) $(CCALLSDIR)/regexp/regsub.c
+
+regerror.o:
+	$(CC) -c $(CCALLSCPFLAGS) $(CFLAGS) $(CCALLSDIR)/regexp/regerror.c
+
+string.o:
+	$(CC) -c $(CCALLSCPFLAGS) $(CFLAGS) $(CCALLSDIR)/string/string.c
+
+tags:   $(SRC) $(INC)
+	ctags -tw $(SRC) $(INC)
+
+unalign.h:
+	sed -n -e '1,/define IFETCH1/p' < vm.c > unalign.h
+
+vm.h vm_i.h vm.c:       vm.d
+	if issymlink vm.c ; then \
+	  rm -f ../src/vm.c ../src/vm.h ../src/vm_i.h ; \
+	else \
+	  rm -f vm.c vm.h vm_i.h ; \
+	fi
+	vmc vm.d
+	chmod -w vm.c vm.h vm_i.h
+
+vm.o: vm.c types.h
+	$(CC) $(VMFLAGS) -c vm.c
+
+vm.s: vm.c types.h
+	$(CC) -S $(VMFLAGS) vm.c
+
+vm.x: vm.c types.h
+	$(CPP) $(VMFLAGS) vm.c > vm.x
+
+#ncpr.o: ncpr.c types.h
+#       $(CC) $(CPRFLAGS) -c ncpr.c
+
+xvm.o: vm.c types.h
+	$(CC) $(VMFLAGS) -o xvm.o -c vm.c
+
+xcreation.o: creation.c types.h
+	$(CC) $(CFLAGS) -o xcreation.o -c creation.c
+
+user:   $(LOAD)
+	ld -r -o user $(LOAD)
+
+emx.exe: emx
+	coff2exe emx
+
+emx:    $(OBJ)
+	@echo linking ...
+	$(CC) $(CFLAGS) $(OBJ) -o emx $(LIB)
+
+#
+# Because test -h doesn't work on all machines, we use a
+# machine dependent issymlink script
+#
+links:
+	for x in $(REALSRC) vm.d $(INC) ; do \
+	  if issymlink $$x ; then rm $$x ; fi ; \
+	  ln -s ../src/$$x . ; \
+	done
+
+checkout:
+	for x in $(REALSRC) vm.d $(INC) ; do \
+	  if issymlink $$x ; then \
+	    true; \
+	  else if cmp -s ../src/$$x $$x ; then \
+	    echo "$$x is a copy of the real thing." ; \
+	  else \
+	    echo "Something funny with $$x" ; \
+	    ls -l $$x ; \
+	  fi ; fi ; \
+	done
+
+mothball:       clean
+	for x in $(REALSRC) vm.d $(INC) ; do \
+	  if issymlink $$x ; then \
+	    rm -f $$x ; \
+	  else \
+	    echo "Something funny with $$x" ; \
+	    ls -l $$x ; \
+	  fi ; \
+	done
+	rm Makefile
+
+clean:
+	rm -f xvm emx user $(OBJ)
+
+sources src:
+	@echo $(SRC)
+
+objects obj:
+	@echo $(OBJ)
+
+includes inc:
+	@echo $(INC)
+
+# WARNING!  Hackish behaviour below.
+# We require $SRC == $(REALSRC) $(CCALLSSRC) vm.d
+# There appear to be dragons ^H^H^H line length limits on a Unix
+# command, so we have to build dependencies with more than one
+# command line.  Also, we can't do a make depend on vm.d,
+# as it's not legal C, so need to exclude it specifically.
+depend: $(SRC)
+	$(DEPEND) $(CFLAGS) $(REALSRC)    >  makedep
+	$(DEPEND) $(CFLAGS) $(CCALLSSRC)  >> makedep
+	@echo '$$r makedep' > eddep
+	@echo '/^# DO NOT DELETE THIS LINE/+1,$$d' >>eddep
+	@echo '$$r makedep' >>eddep
+	@echo 'w' >>eddep
+	@cp Makefile Makefile.bak
+	@ex - Makefile < eddep
+	@rm eddep makedep
+
+# DO NOT DELETE THIS LINE -- make depend uses it
+array.o : array.c misc.h types.h streams.h memory.h array.h 
+codemsg.o : codemsg.c codemsg.h types.h streams.h vm_exp.h vm_i.h \
+  vm.h assert.h globals.h builtins.h iisc.h memory.h misc.h jsys.h creation.h \
+  oidtoobj.h oisc.h iosc.h squeue.h concurr.h iset.h trace.h hash.h 
+conform.o : conform.c types.h streams.h assert.h ooisc.h memory.h trace.h globals.h \
+  builtins.h iisc.h oidtoobj.h oisc.h iosc.h 
+creation.o : creation.c memory.h types.h streams.h vm_exp.h vm_i.h vm.h assert.h \
+  globals.h builtins.h iisc.h misc.h jsys.h creation.h oidtoobj.h oisc.h \
+  iosc.h squeue.h concurr.h iset.h trace.h 
+debug.o : debug.c assert.h vm_exp.h vm_i.h vm.h types.h globals.h builtins.h \
+  iisc.h memory.h misc.h jsys.h creation.h oidtoobj.h oisc.h iosc.h squeue.h \
+  concurr.h iset.h trace.h read.h array.h streams.h 
+decmsg.o : decmsg.c assert.h builtins.h globals.h iisc.h memory.h \
+  types.h streams.h decmsg.h codemsg.h vm_exp.h vm_i.h vm.h misc.h \
+  jsys.h creation.h oidtoobj.h oisc.h iosc.h squeue.h concurr.h iset.h trace.h \
+  hash.h message.h sockstr.h 
+encmsg.o : encmsg.c encmsg.h codemsg.h types.h streams.h \
+  vm_exp.h vm_i.h vm.h assert.h globals.h builtins.h iisc.h memory.h misc.h \
+  jsys.h creation.h oidtoobj.h oisc.h iosc.h squeue.h concurr.h iset.h trace.h \
+  hash.h 
+error.o : error.c error.h 
+filestr.o : filestr.c filestr.h streams.h assert.h error.h memory.h 
+gc.o : gc.c gc.h types.h streams.h assert.h 
+globals.o : globals.c types.h streams.h globals.h builtins.h iisc.h memory.h \
+  jsys.h 
+hash.o : hash.c assert.h hash.h memory.h 
+iisc.o : iisc.c iisc.h memory.h assert.h 
+ilist.o : ilist.c assert.h ilist.h memory.h 
+iosc.o : iosc.c iosc.h memory.h types.h streams.h assert.h 
+iset.o : iset.c assert.h iset.h memory.h 
+joveisc.o : joveisc.c assert.h joveisc.h types.h streams.h array.h memory.h \
+  iisc.h 
+jsys.o : jsys.c init.h trace.h types.h streams.h globals.h builtins.h iisc.h \
+  memory.h oidtoobj.h oisc.h iosc.h assert.h 
+jvisc.o : jvisc.c jvisc.h memory.h types.h streams.h assert.h 
+main.o : main.c types.h streams.h iisc.h memory.h trace.h assert.h vm_exp.h \
+  vm_i.h vm.h globals.h builtins.h misc.h jsys.h creation.h oidtoobj.h oisc.h \
+  iosc.h squeue.h concurr.h iset.h 
+message.o : message.c error.h message.h types.h streams.h vm_exp.h vm_i.h vm.h \
+  assert.h globals.h builtins.h iisc.h memory.h misc.h jsys.h creation.h oidtoobj.h \
+  oisc.h iosc.h squeue.h concurr.h iset.h trace.h \
+  decmsg.h codemsg.h hash.h encmsg.h sockstr.h 
+misc.o : misc.c iset.h memory.h iisc.h hash.h trace.h types.h streams.h misc.h \
+  error.h assert.h vm_exp.h vm_i.h vm.h globals.h builtins.h jsys.h creation.h \
+  oidtoobj.h oisc.h iosc.h squeue.h concurr.h \emerald\lib\cctab.h 
+oidtoobj.o : oidtoobj.c iset.h memory.h oidtoobj.h types.h streams.h \
+  oisc.h iosc.h ooisc.h globals.h builtins.h iisc.h trace.h read.h array.h 
+oisc.o : oisc.c oisc.h memory.h types.h streams.h assert.h 
+ooisc.o : ooisc.c ooisc.h memory.h types.h streams.h assert.h 
+read.o : read.c memory.h array.h assert.h write.h types.h streams.h read.h iisc.h \
+  oisc.h codemsg.h vm_exp.h vm_i.h vm.h globals.h builtins.h misc.h jsys.h \
+  creation.h oidtoobj.h iosc.h squeue.h concurr.h iset.h trace.h hash.h \
+  joveisc.h jvisc.h message.h filestr.h 
+sisc.o : sisc.c assert.h sisc.h memory.h 
+sockstr.o : sockstr.c sockstr.h streams.h types.h error.h \
+  memory.h misc.h assert.h 
+squeue.o : squeue.c squeue.h memory.h assert.h 
+streams.o : streams.c error.h streams.h memory.h assert.h 
+trace.o : trace.c assert.h trace.h 
+vm.o : vm.c vm_i.h vm.h assert.h types.h streams.h globals.h builtins.h iisc.h \
+  memory.h misc.h jsys.h creation.h oidtoobj.h oisc.h iosc.h squeue.h concurr.h \
+  iset.h trace.h sisc.h ilist.h 
+write.o : write.c array.h builtins.h codemsg.h types.h streams.h vm_exp.h \
+  vm_i.h vm.h assert.h globals.h iisc.h memory.h misc.h jsys.h creation.h oidtoobj.h \
+  oisc.h iosc.h squeue.h concurr.h iset.h trace.h hash.h error.h filestr.h \
+  read.h write.h 
+cctab.o : ..\..\lib\cctab.c ..\..\lib\cctab.h 
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/memory.h ubc-latest-src/vm/src/memory.h
--- sourceforge-1.06alpha/vm/src/memory.h	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/memory.h	2017-12-11 17:59:03.489711436 +0100
@@ -0,0 +1,26 @@
+/****************************************************************************
+ File     : memory.h
+ Date     : 06-22-92
+ Author   : Mark Immel
+
+ Contents : Memory allocation functions
+
+ Modifications
+ -------------
+
+*****************************************************************************/
+
+#ifndef _EMERALD_MEMORY_H
+#define _EMERALD_MEMORY_H
+
+#include "threads.h"
+
+extern int strncmp(const char *, const char *, size_t);
+extern void *gc_malloc(int);
+extern void *gc_malloc_nogc(int), *gc_malloc_old(int nb, int remember);
+extern void *extraRoots[];
+extern int     extraRootsSP;
+#define regRoot(x) (extraRoots[extraRootsSP++] = (void *)&(x))
+#define unregRoot() ( extraRoots[--extraRootsSP] = 0)
+#endif /* _EMERALD_MEMORY_H */
+
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/misc.c ubc-latest-src/vm/src/misc.c
--- sourceforge-1.06alpha/vm/src/misc.c	2017-12-11 17:59:03.090714477 +0100
+++ ubc-latest-src/vm/src/misc.c	2017-12-11 17:59:03.489711436 +0100
@@ -122,13 +100,14 @@
 			c = *++str;
 		}
 	}
-	if (base == 0)
+	if (base == 0) {
 		if (c != '0')
 			base = 10;
 		else if (str[1] == 'x' || str[1] == 'X')
 			base = 16;
 		else
 			base = 8;
+	}
 	/*
 	 * for any base > 10, the digits incrementally following
 	 *	9 are assumed to be "abc...z" or "ABC...Z"
@@ -1107,6 +1086,16 @@
   }
 }
 
+static int isAllNil(unsigned int *x, int size)
+{
+  int i;
+  size /= 4;
+  for (i = 0; i < size; ++i) {
+    if (!ISNIL(x[i])) return 0;
+  }
+  return 1;
+}
+
 static void findRootsInStack(State *state, void (*pointers_f)(int, Object *),
 			     void (*variable_f)(Object *, ConcreteType *), void (*variables_f)(int, u32 *))
 {
@@ -1120,6 +1109,7 @@
   lstate = *state;
 
   if (state->ep && state->et && ISNOTNIL(state->ep)) variable_f(&state->ep, &state->et);
+  pointers_f(1, (Object *)&state->opp);
   do {
     if (lstate.pc) {
       if (HASODP((*cpp)->d.instanceFlags)) pointers_f(1, opp);
@@ -1139,7 +1129,27 @@
 			    theTemplate->d.items, theTemplate->d.data));
 	}
 	if (lstate.sp > lstate.fp) {
-	  findLocals(theTemplate, lstate.fp ? lstate.fp : lstate.sb, lstate.sp, pointers_f, variables_f);
+	  unsigned int base = lstate.fp ? lstate.fp : lstate.sb;
+	  IFTRACE(memory, 1) {
+	    if (base + sizeFromTemplate(theTemplate) < lstate.sp) {
+	      /*
+	       * There is memory left over here that I don't have a template
+	       * for, let's at least document it.
+	       */
+	      TRACE(memory, 1,
+		    ("%d bytes of undescribed stack at line %d in %.*s.%.*s",
+		     lstate.sp - base - sizeFromTemplate(theTemplate),
+		     findLineNumber(lstate.pc, theOp->d.code, theTemplate),
+		     lstate.cp->d.name->d.items, lstate.cp->d.name->d.data, 
+		     theOp->d.name->d.items, theOp->d.name->d.data));
+	      if (!isAllNil(base + sizeFromTemplate(theTemplate),
+			    lstate.sp - base - sizeFromTemplate(theTemplate))) {
+		TRACE(memory, 1, ("Backtrace of process"));
+		showProcess(state, 1);
+	      }
+	    }
+	  }
+	  findLocals(theTemplate, base, lstate.sp, pointers_f, variables_f);
 	} else {
 	  /* We must have suspended this guy before executing any
 	     instructions, or there aren't any data items. */
@@ -1362,6 +1372,23 @@
       }
     } OIScNext();
   }    
+  {
+    noderecord **nd;
+    for (nd = &allnodes->p; *nd; nd = &(*nd)->p) {
+      Object node = OIDFetch((*nd)->node);
+      Object inctm = OIDFetch((*nd)->inctm);
+      if (ISNIL(node)) {
+	TRACE(memory, 4, ("Mark roots: can't fetch the node for %s", OIDString((*nd)->node)));
+      } else {
+	pointers_f(1, &node);
+      }
+      if (ISNIL(inctm)) {
+	TRACE(memory, 4, ("Mark roots: can't fetch the inctm for %s", OIDString((*nd)->inctm)));
+      } else {
+	pointers_f(1, &inctm);
+      }
+    }
+  }
 #endif    
   {
     extern Object StdInStream, StdOutStream;
@@ -1430,6 +1457,62 @@
   return sizeOfX(o, o, CODEPTR(o->flags));
 }
 
+int VecLength(Vector o)
+{
+  if (ISNIL(o)) return 0;
+  return o->d.items;
+}
+
+/*
+ * Search the queue of waiting states for one that is attempting an
+ * invocation of an operation in the given type.   Remove the first one
+ * found and return it, or return NULL.
+ */
+State *findAcceptable(SQueue waiting, AbstractType acceptable)
+{
+  State *s;
+  OpVectorElement ove;
+  ATOpVectorElement ave;
+  int i;
+  TRACE(process, 3, ("Trying to find an acceptable operation"));
+  SQueueForEach(waiting, s) {
+    TRACE(process, 4, ("Looking at state #%x", s));
+    ove = s->opp;
+    assert(ove && !ISNIL(ove));
+    TRACE(process, 5, ("State #%x is operation %.*s[%d] %d",
+		       s, ove->d.name->d.items, ove->d.name->d.data,
+		       ove->d.nargs, ove->d.id));
+    if (acceptable->d.ops->d.items == 0) {
+      /*
+       * This is Any. accept the op.
+       */
+      int res = SQueueYank(waiting, s);
+      if (!res) assert(0);
+      TRACE(process, 4, ("Found an acceptable operation"));
+      return s;
+    } else {
+      for (i = 0; i < acceptable->d.ops->d.items; i++) {
+	ave = acceptable->d.ops->d.data[i];
+	TRACE(process, 6, ("AT Operation %d is %.*s[%d] %d",
+			   i, ave->d.name->d.items, ave->d.name->d.data,
+			   VecLength((Vector)ave->d.arguments),
+			   ave->d.id));
+	if (ave->d.id == ove->d.id) {
+	  /*
+	   * Found this op in the AT, accept the op.
+	   */
+	  int res = SQueueYank(waiting, s);
+	  if (!res) assert(0);
+	  TRACE(process, 4, ("Found an acceptable operation"));
+	  return s;
+	}
+      }
+    }
+  } SQueueNext();
+  TRACE(process, 4, ("Failed to find an acceptable operation"));
+  return NULL;
+}
+
 #if defined(WIN32)
 static struct _timeb xx_start;
 
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/misc.h ubc-latest-src/vm/src/misc.h
--- sourceforge-1.06alpha/vm/src/misc.h	2017-12-11 17:59:03.090714477 +0100
+++ ubc-latest-src/vm/src/misc.h	2017-12-11 17:59:03.489711436 +0100
@@ -33,6 +11,10 @@
 #include "dist.h"
 #endif
 
+#ifndef _EMERALD_SQUEUE_H
+#include "squeue.h"
+#endif
+
 #define MAX_FILE_DESCRIPTORS 32
 #define STACKSIZE (16 * 1024)
 extern int stackSize;
@@ -48,57 +30,6 @@
 extern unsigned int *currentOPECount;
 #endif
 
-#define FINDCODEBODY(pc, result, ct, theId) {\
-  OpVector ov = (ct)->d.opVector;\
-  OpVectorElement ope;\
-  int i;\
-  (result) = 0;\
-  for (i = 3; i < ov->d.items; i++) {\
-    ope = ov->d.data[i];\
-    if (ope->d.id == (theId)) {\
-      PROFILEBUMP(pc, ope,ct);\
-      (result) = (unsigned int)(ope->d.code->d.data);\
-      break;\
-    }\
-  }\
-  if ((result) == 0){\
-    fprintf(stderr,"FindCode: op %s id %d undefined for ct %.*s (0x%08x)\n",\
-            OperationName(theId),(theId),\
-	    (ct)->d.name->d.items,\
-	    (ct)->d.name->d.data,\
-	    (ct));\
-    DEBUG("");\
-  }\
-}
-
-#define FINDCODE(pc, result, x, y) FINDCODEBODY(pc, result, x, y)
-
-#define FINDOVE(result, ct, theId) {\
-  if (ISNIL(ct)) { \
-    (result) = 0; \
-  } else { \
-    OpVector ov = (ct)->d.opVector;\
-    OpVectorElement ope;\
-    int i;\
-    (result) = 0;\
-    for (i = 3; i < ov->d.items; i++) {\
-      ope = ov->d.data[i];\
-      if (ope->d.id == (theId)) {\
-	(result) = i; \
-	break;\
-      }\
-    }\
-    if ((result) == 0){\
-      fprintf(stderr,"FindCode: op %s id %d undefined for ct %.*s (0x%08x)\n",\
-	      OperationName(theId),(theId),\
-	      (ct)->d.name->d.items,\
-	      (ct)->d.name->d.data,\
-	      (u32)(ct));\
-      DEBUG("");\
-    }\
-  } \
-}
-
 struct State;
 extern Object rootdir, rootdirg, node, inctm, upcallStub, locsrv, debugger;
 extern int unwind(struct State *state);
@@ -109,6 +40,10 @@
 void tryToInit(Object obj);
 void becomeStub(Object o, ConcreteType ct, void *stub);
 extern int sizeOf(Object o);
+extern int sizeFromTemplate(Template t);
+extern int findLineNumber(unsigned pc, Code code, Template template);
+extern void showProcess(struct State *state, int levelOfDetail);
+extern struct State *findAcceptable(SQueue, AbstractType);
 int upcall( Object o, int fn, int *fail, int argc, int retc, int *args );
 void WriteOID(struct OID *oid, Stream theStream);
 void ReadOID(struct OID *oid, Stream theStream);
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/move.c ubc-latest-src/vm/src/move.c
--- sourceforge-1.06alpha/vm/src/move.c	2017-12-11 17:59:03.090714477 +0100
+++ ubc-latest-src/vm/src/move.c	2017-12-11 17:59:03.489711436 +0100
@@ -46,6 +24,72 @@
 
 IISc fixedMap;
 
+static int misdigit(int c)
+{
+  return ('0' <= c && c <= '9');
+}
+
+int sizeFromTemplate(Template t)
+{
+  int count, size = 0, totalsize = 0;
+  char c, *brands;
+
+  if (ISNIL(t)) return 0;
+
+  brands = (char *)t->d.data;
+  while(*brands != '\0') {
+    switch (*brands++) {
+    case '%':
+      count = 0;
+      while (misdigit(c = *brands++)) {
+	count = count * 10 + c-'0';
+      }
+      if (!count) count = 1;
+      assert(c != '*');
+      switch(c) {
+      case 'm':
+	assert(count == 1);
+	size = 8;
+	break;
+      case 'X':
+      case 'x':
+      case 'D':
+      case 'd':
+      case 'F':
+      case 'f':
+	size = 4;
+	break;
+      case 'C':
+      case 'c':
+      case 'B':
+      case 'b':
+	size = 4;
+	break;
+      case 'V':
+      case 'v':
+	size = 8;
+	break;
+      case 'l':
+      case 'L':
+      case 'q':
+	TRACE(rinvoke, 0, ("Brand %c can't appear in an activation record", c));
+	assert(0);
+	break;
+      default:
+	TRACE(rinvoke, 0, ("can't figure brand %c", c));
+	assert(0);
+      }
+      totalsize += count * size;
+      break;
+    default:
+      TRACE(rinvoke, 0, ("What is '%c' doing in a template?", brands[-1]));
+      assert(0);
+      break;
+    }
+  }
+  return totalsize;
+}
+
 #ifdef DISTRIBUTED
 
 extern int receivingObjects;
@@ -285,71 +329,6 @@
   }
 }
 
-static int misdigit(int c)
-{
-  return ('0' <= c && c <= '9');
-}
-u32 sizeFromTemplate(Template t)
-{
-  int count, size, totalsize = 0;
-  char c, *brands;
-
-  if (ISNIL(t)) return 0;
-
-  brands = (char *)t->d.data;
-  while(*brands != '\0') {
-    switch (*brands++) {
-    case '%':
-      count = 0;
-      while (misdigit(c = *brands++)) {
-	count = count * 10 + c-'0';
-      }
-      if (!count) count = 1;
-      assert(c != '*');
-      switch(c) {
-      case 'm':
-	assert(count == 1);
-	size = 8;
-	break;
-      case 'X':
-      case 'x':
-      case 'D':
-      case 'd':
-      case 'F':
-      case 'f':
-	size = 4;
-	break;
-      case 'C':
-      case 'c':
-      case 'B':
-      case 'b':
-	size = 4;
-	break;
-      case 'V':
-      case 'v':
-	size = 8;
-	break;
-      case 'l':
-      case 'L':
-      case 'q':
-	TRACE(rinvoke, 0, ("Brand %c can't appear in an activation record", c));
-	assert(0);
-	break;
-      default:
-	TRACE(rinvoke, 0, ("can't figure brand %c", c));
-	assert(0);
-      }
-      totalsize += count * size;
-      break;
-    default:
-      TRACE(rinvoke, 0, ("What is '%c' doing in a template?", brands[-1]));
-      assert(0);
-      break;
-    }
-  }
-  return totalsize;
-}
-
 ConcreteType buildSpoofCT(Template t, int size)
 {
   ConcreteType ct;
@@ -486,12 +465,12 @@
  */
 int addActivations(State *state, Stream str, int ready)
 {
-  ConcreteType spoofCT;
+  ConcreteType spoofCT = 0;
   int opindex = findOpVectorIndex(state->cp, state->pc);
   OpVectorElement ove = state->cp->d.opVector->d.data[opindex];
   int templateSize = sizeFromTemplate(ove->d.template);
   int nargsandress;
-  Object spoof;
+  Object spoof = 0;
   OID oido, oidct, prevstateoid, newstateoid;
   Node prevstatesrv;
   int result, howmany, pcoffset;
@@ -581,8 +560,8 @@
   ConcreteType spoofCT;
   u32 opindex, pcoffset;
   OpVectorElement ove;
-  int templateSize, nargsandress, i, howmany, sp;
-  Object spoof;
+  int templateSize = 0, nargsandress, i, howmany, sp;
+  Object spoof = 0;
   OID oido, oidct, prevstateoid, newstateoid, nsoid, nstoid;
   Node prevstatesrv;
   State *state, *prevstate;
@@ -654,6 +633,7 @@
   }
 
   /* set up the interpreter state */
+  state->opp = ove;
   state->pc = (u32)ove->d.code->d.data + pcoffset;
   if (pcoffset && howmany) {
     for (i = 0; i < howmany * 2; i++) {
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/mthreads.c ubc-latest-src/vm/src/mthreads.c
--- sourceforge-1.06alpha/vm/src/mthreads.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/mthreads.c	2017-12-11 17:59:03.490711429 +0100
@@ -0,0 +1,642 @@
+/*
+ * Copyright (C) Norman C. Hutchinson and the University of British Columbia
+ */
+#pragma warning(disable: 4068)
+#pragma pointer_size long
+#include <sys/types.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+
+#ifdef WIN32
+#  ifdef MSVC40
+#    include <winsock.h>
+#  else
+#    include <winsock2.h>
+#  endif
+#  include <io.h>
+#  include <errno.h>
+#  include <assert.h>
+#  include <errno.h>
+#else /* not WIN32 */
+#  include <unistd.h>
+#  include <sys/socket.h>
+#  if !defined(linux) && !defined(hpux) && !defined(sun4) && !defined(__NeXT__)
+#    include <sys/select.h>
+#  endif
+#  include <sys/uio.h>
+#  include <sys/errno.h>
+   extern int errno;
+#  include <signal.h>
+#  include <netinet/in.h>
+#  include <netinet/tcp.h>
+#  include <netdb.h>
+#endif /* not WIN32 */
+
+#pragma pointer_size short
+#include "assert.h"
+
+#include "mthreads.h"
+#include "io.h"
+#include "mqueue.h"
+
+#ifdef WIN32
+extern int gettimeofday(struct timeval *, void *);
+#else /* not WIN32 */
+#ifndef SELECTSIZE_T
+#define SELECTSIZE_T size_t
+#endif
+#ifndef SELECTFD_T
+#define SELECTFD_T fd_set
+#endif
+#ifndef SELECTCONST
+#define SELECTCONST const
+#endif
+
+#ifndef FAKEREAD
+#define reax(fd, buf, nbytes) read(fd, buf, nbytes)
+#else
+extern int reax(int fd, void *buf, int nbytes);
+#endif
+#ifndef FAKEWRITE
+#define writx(fd, buf, nbytes) write(fd, buf, nbytes)
+#else
+extern int writx(int fd, const void *buf, int nbytes);
+#endif
+#ifndef FAKESELECT
+#define selecx(fd, r, w, x, t) select(fd, r, w, x, t)
+#else
+extern int selecx(SELECTSIZE_T fd, SELECTFD_T *r, SELECTFD_T *w, SELECTFD_T *x, SELECTCONST struct timeval *t);
+#endif
+
+
+#define MAXOTHERS 128
+static int nothers;
+struct other {
+  NodeAddr id;
+  int s;
+} others[MAXOTHERS], cache;
+
+MQueue incoming, deferred;
+
+/*
+ * Forward declarations.
+ */
+static void setupReader(struct other *ri);
+
+#ifdef MTDEBUG
+#define TRACE(level, stuff) if (level <= MTdebuglevel) printf stuff
+int MTdebuglevel = 99;
+#else
+#define TRACE(level, stuff)
+#endif
+
+extern int checkSameUser;
+
+void MTPoll(void);
+
+static void (*mter)(void);
+
+void MTRegisterExitRoutine(void (*r)(void))
+{
+  assert(!mter);
+  mter = r;
+}
+
+static void callExitRoutines(void)
+{
+  if (mter) mter();
+}
+
+static void pipeHandler(int signalnumber)
+{
+}
+
+static void intrHandler(int signalnumber)
+{
+  callExitRoutines();
+  exit(1);
+}
+
+#endif /* WIN32 */
+
+ssize_t MTwrite2(int fd, void *buf1, size_t n1, void *buf2, size_t n2)
+{
+  int res;
+  struct iovec v[2];
+  int howmany = 2;
+  v[0].iov_base = buf1;
+  v[0].iov_len = n1;
+  v[1].iov_base = buf2;
+  v[1].iov_len = n2;
+  TRACE(4, ("write2 on %d for %d+%d bytes\n", fd, n1, n2));
+  if (fd < 0) return -1;
+  while (1) {
+#ifdef WIN32
+    res = send(fd, v[0].iov_base, v[0].iov_len, 0);
+#else
+    res = writev(fd, v, howmany);
+#endif /* WIN32 */
+    TRACE(4, ("write2 wrote %d\n", res));
+    if ((unsigned)res == v[0].iov_len + v[1].iov_len) {
+      res = n1 + n2;
+      break;
+    } else if (res > 0) {
+      /* Only wrote a part, fix up things */
+      if ((unsigned)res < v[0].iov_len) {
+	v[0].iov_len -= res;
+	v[0].iov_base += res;
+      } else {
+	res -= v[0].iov_len;
+	v[0].iov_len = v[1].iov_len - res;
+	v[0].iov_base = v[1].iov_base + res;
+	v[1].iov_base = 0;
+	v[1].iov_len = 0;
+	howmany = 1;
+      }
+    } else {
+      printf("write2 error %d\n", res);
+      perror("write2");
+      break;
+    }
+  }
+  TRACE(4, ("write2 returning %d\n", res));
+  return res;
+}
+
+#if 0
+static int doem(fd_set *fds, MTWhy why)
+{
+  int index, offset, found = 0, which;
+  for (offset = 0, index = 0; offset <= realnfds; offset += 32, index++) {
+    while ((which = ffs(fds->fds_bits[index])) > 0) {
+      found ++;
+      assert(FD_ISSET(offset + which - 1, fds));
+      FD_CLR(offset + which - 1, fds);
+      TRACE(7, ("Found %d ready for %d\n", offset + which - 1, why));
+      if (fdsems[offset + which - 1][why].count < 0) {
+	MTSemV(&fdsems[offset + which - 1][why]);
+      } else {
+	/* This had better be the multi waiter from select */
+	MTSemV(&waitonmulti);
+      }
+    }
+  }
+  return found;
+}
+#endif
+
+#ifdef __linux
+# define sigvec		sigaction
+# define sv_mask	sa_mask
+# define sv_flags	sa_flags
+# define sv_handler	sa_handler
+# define sv_onstack	sa_mask /* ouch, this one really hurts */
+#endif /* __linux */
+
+#ifdef hp700
+#define SIGVEC sigvector
+#else
+#define SIGVEC sigvec
+#endif /* hp700 */
+
+struct header {
+  int length;
+};
+
+NodeAddr myid;
+static int mysocket;
+
+struct nbo {
+  unsigned int ipaddress;
+  unsigned short port, incarnation;
+  int userid;
+};
+
+static NotifyFunction notifyFunction;
+
+void MTRegisterNotify(NotifyFunction f)
+{
+  assert(notifyFunction == 0);
+  notifyFunction = f;
+}
+
+static void nukeother(struct other o)
+{
+  int from, to;
+  TRACE(8, ("Nuking %x.%x (%d)\n", o.id.ipaddress, o.id.port, o.s));
+  for (from = 0, to = 0; from < nothers; from++) {
+    if (others[from].s == o.s) {
+      TRACE(8, ("  Nuking %x.%x (%d)\n", others[from].id.ipaddress, others[from].id.port, others[from].s));
+      /* don't do this one */
+    } else {
+      if (from != to) {
+	others[to++] = others[from];
+      } else {
+	to++;
+      }
+    }
+  }
+  TRACE(7, ("Nothers went from %d to %d\n", nothers, to));
+  nothers = to;
+  cache.id.ipaddress = cache.id.port = cache.s = 0;
+}
+
+int findsocket(NodeAddr *t)
+{
+  int i, addrlen, s;
+  struct sockaddr_in addr;
+  struct other *o, localcopy;
+  struct nbo nbo;
+
+  TRACE(7, ("in find socket for %#x.%4x\n", t->ipaddress, t->port));
+  if (cache.id.ipaddress == t->ipaddress && cache.id.port == t->port && cache.s) {
+    TRACE(8, ("find socket returning %d from cache\n", cache.s));
+    return cache.s;
+  }
+  for (i = 0; i < nothers; i++) {
+    TRACE(9, ("  Looking at %#x.%4x\n", others[i].id.ipaddress, others[i].id.port));
+    if (others[i].id.ipaddress == t->ipaddress && others[i].id.port == t->port) {
+      cache = others[i];
+      TRACE(8, ("find socket returning %d\n", cache.s));
+      return cache.s;
+    }
+  }
+#if defined(WIN32) && defined(SO_SYNCHRONOUS_NONALERT)
+  {
+    int optionValue = SO_SYNCHRONOUS_NONALERT;
+    int err;
+    err = setsockopt(INVALID_SOCKET,
+		     SOL_SOCKET,
+		     SO_OPENTYPE,
+		     (char *)&optionValue,
+		     sizeof(optionValue));
+    if (err != NO_ERROR) {
+      printf("setsockopt: OPENTYPE failed with %d\n", err);
+      abort();
+    }
+  }
+#endif
+  if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) return -1;
+  memset(&addr, 0, sizeof(addr));
+  addr.sin_family = AF_INET;
+  addr.sin_port = htons(0);
+  addr.sin_addr.s_addr = 0;
+  if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+    perror("findsocket.bind");
+    close(s);
+    return -1;
+  }
+  memset(&addr, 0, sizeof(addr));
+  addr.sin_family = AF_INET;
+  addr.sin_port = htons(t->port);
+  addr.sin_addr.s_addr = t->ipaddress;
+  addrlen = sizeof(addr);
+  TRACE(3, ("Trying to connect to %08lx.%04x\n", addr.sin_addr.s_addr, ntohs(addr.sin_port)));
+  if (connect(s, (struct sockaddr *)&addr, addrlen) < 0) {
+#ifdef MTDEBUG
+    if (MTdebuglevel >= 3) perror("findsocket.connect");
+#endif
+    close(s);
+    return -1;
+  }
+  {
+    int on = 1;
+    if (setsockopt(s, IPPROTO_TCP, TCP_NODELAY, (char *)&on, sizeof (on)) < 0) {
+      close(s);
+      perror("setsockopt");
+      return -1;
+    }
+  }
+
+  localcopy.id = *t;
+  localcopy.s = s;
+  TRACE(9, ("Inserting %#x.%d -> %d in others\n", t->ipaddress, t->port, localcopy.s));
+  others[nothers++] = localcopy;
+  {
+    nbo.ipaddress = myid.ipaddress;
+    nbo.port = htons(myid.port);
+    nbo.incarnation = htons(myid.incarnation);
+    nbo.userid = htonl(getuid());
+    if (writeToSocketN(localcopy.s, &nbo, sizeof(nbo)) != sizeof(nbo) ||
+	readFromSocketN(localcopy.s, &nbo, sizeof(nbo)) != sizeof(nbo)) {
+      TRACE(0, ("Couldn't exchange incarnation info\n"));
+      close(localcopy.s);
+      nothers--;
+      return -1;
+    } else if(checkSameUser && getuid() != ntohl(nbo.userid)) {
+      fprintf(stderr, "Permission denied - user mismatch local %d != remote %d\n", (int)getuid(), ntohl(nbo.userid));
+      close(localcopy.s);
+      nothers--;
+      return -1;
+    }
+    localcopy.id.ipaddress = nbo.ipaddress;
+    localcopy.id.incarnation = ntohs(nbo.incarnation);
+    assert(localcopy.id.port == ntohs(nbo.port));
+    *t = localcopy.id;
+  }
+  o = (struct other *)malloc(sizeof *o);
+  *o = localcopy;
+  setupReader(o);
+  TRACE(8, ("find socket returning new %d\n", localcopy.s));
+  cache = localcopy;
+  return cache.s;
+}
+
+static void callNotifyFunction(NodeAddr id, int comingup)
+{
+  notifyFunction(id, comingup);
+}
+
+typedef struct ReaderState {
+  struct other *ri;
+  readBuffer rb;
+  int readingLength, length;
+} ReaderState;
+
+static void ReaderCB(int sock, EDirection d, void *state)
+{
+  ReaderState *rs = state;
+  int res;
+  void *buffer = 0;
+
+  if (!(res = tryReading(&rs->rb, sock))) return;
+  if (res < 0 || res != rs->rb.goal) {
+    /*
+     * Give up on this socket.
+     */
+    resetHandler(sock, EIO_Read);
+    resetHandler(sock, EIO_Except);
+    close(sock);
+    if (notifyFunction) notifyFunction(rs->ri->id, 0);
+    nukeother(*rs->ri);
+    free(rs->ri);
+    free(rs);
+  } else if (rs->readingLength) {
+    rs->length = ntohl(rs->length);
+    rs->readingLength = 0;
+    if (rs->length > 0) {
+      buffer = malloc(rs->length);
+      setupReadBuffer(&rs->rb, buffer, rs->length, 0, readFromSocket);
+    } else {
+      TRACE(0, ("Negative length %d\n", rs->length));
+    }
+  } else {
+    assert(ntohl(*(int *)rs->rb.buffer) == 0xdeafdeaf);
+    MQueueInsert(incoming, rs->ri->id, rs->length, rs->rb.buffer);
+    setupReadBuffer(&rs->rb, &rs->length, sizeof(rs->length), 0, readFromSocket);
+    rs->readingLength = 1;
+  }
+}
+
+static void setupReader(struct other *ri)
+{
+  ReaderState *rs = (ReaderState *)malloc(sizeof(*rs));
+  rs->ri = ri;
+  rs->readingLength = 1;
+  setupReadBuffer(&rs->rb, &rs->length, sizeof(rs->length), 0, readFromSocket);
+  setHandler(rs->ri->s, ReaderCB, EIO_Read, rs);
+  setHandler(rs->ri->s, ReaderCB, EIO_Except, rs);
+}
+
+void showIncoming(void)
+{
+  MQueuePrint(incoming);
+}
+
+typedef struct {
+  struct other *ri;
+  struct nbo nbo;
+  readBuffer rb;
+} ListenerState;
+  
+static int checkUserOK(int local, int remote)
+{
+  if (checkSameUser && local != remote) {
+      fprintf(stderr, "Permission denied - user mismatch local %d != remote %d\n",
+	      local, remote);
+      return 0;
+  } else {
+    return 1;
+  }
+}
+
+static void ListenerStage2(int sock, EDirection d, void *arg)
+{
+  int res;
+  ListenerState *ls = arg;
+  if (!(res = tryReading(&ls->rb, ls->ri->s))) return;
+  resetHandler(sock, EIO_Read);
+  resetHandler(sock, EIO_Except);
+  if (res != sizeof(ls->nbo) || !checkUserOK(getuid(), ntohl(ls->nbo.userid))) {
+    nukeother(*ls->ri);
+    close(ls->ri->s);
+    free(ls->ri);
+  } else {
+    ls->ri->id.port = ntohs(ls->nbo.port);
+    ls->ri->id.ipaddress = ls->nbo.ipaddress;
+    ls->ri->id.incarnation = ntohs(ls->nbo.incarnation);
+    TRACE(8, ("Inserting %#x.%4x.%4x -> %d in others\n", ls->ri->id.ipaddress, ls->ri->id.port, ls->ri->id.incarnation, ls->ri->s));
+    others[nothers++] = *ls->ri;
+    setupReader(ls->ri);
+    if (notifyFunction) callNotifyFunction(ls->ri->id, 1);
+  }
+  vmFree((char *)ls);
+}
+
+static void ListenerCB(int sock, EDirection d, void *s)
+{
+  int newsocket;
+  struct sockaddr_in addr;
+  int addrlen = sizeof(addr), on = 1;
+  ListenerState *ls = (ListenerState *)malloc(sizeof(*ls));
+
+  newsocket = accept(sock, (struct sockaddr *)&addr, &addrlen);
+  if (newsocket < 0) return;
+  if (setsockopt(newsocket, IPPROTO_TCP, TCP_NODELAY, (char *)&on, sizeof (on)) < 0) {
+    close(newsocket);
+    perror("setsockopt");
+    return;
+  }
+  ls->ri = (struct other *)malloc(sizeof *ls->ri);
+  ls->ri->s = newsocket;
+  ls->ri->id.ipaddress = addr.sin_addr.s_addr;
+  ls->ri->id.port = ntohs(addr.sin_port);
+
+  TRACE(8, ("Inserting %#x.%x -> %d in others\n", ls->ri->id.ipaddress, ls->ri->id.port, ls->ri->s));
+  others[nothers++] = *ls->ri;
+  ls->nbo.ipaddress = myid.ipaddress;
+  ls->nbo.port = htons(myid.port);
+  ls->nbo.incarnation = htons(myid.incarnation);
+  ls->nbo.userid = htonl(getuid());
+  if (send(ls->ri->s, (char *)&ls->nbo, sizeof(ls->nbo), 0) != sizeof(ls->nbo)) {
+    nukeother(*ls->ri);
+    close(ls->ri->s);
+    free(ls->ri);
+    return;
+  }
+  setupReadBuffer(&ls->rb, &ls->nbo, sizeof(ls->nbo), 0, readFromSocket);
+  setHandler(ls->ri->s, ListenerStage2, EIO_Read, ls);
+  setHandler(ls->ri->s, ListenerStage2, EIO_Except, ls);
+}
+
+static void setupListener(int sock)
+{
+  setHandler(sock, ListenerCB, EIO_Read, NULL);
+}
+
+int MTNetStart(unsigned int ipaddress, unsigned short port, unsigned short incarnation)
+{
+  struct sockaddr_in addr;
+  int addrlen, on = 1;
+  char hostname[128];
+#ifdef alpha
+#pragma pointer_size long
+#endif
+  struct hostent *h;
+#ifdef alpha
+#pragma pointer_size short
+#endif
+
+  assert(myid.ipaddress == 0 && myid.port == 0 && myid.incarnation == 0);
+  if ((mysocket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+    return -1;
+  }
+  memset(&addr, 0, sizeof(addr));
+  addr.sin_family = AF_INET;
+  addr.sin_port = htons(port);
+  addr.sin_addr.s_addr = ipaddress;
+  if (bind(mysocket, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+    close(mysocket);
+    return -1;
+  }
+  addrlen = sizeof(addr);
+  if (getsockname(mysocket, (struct sockaddr *)&addr, &addrlen) < 0) {
+    close(mysocket);
+    return -1;
+  }
+  TRACE(3, ("NetStart on %#lx.%d\n", addr.sin_addr.s_addr, ntohs(addr.sin_port)));
+  if (listen(mysocket, 5) < 0) {
+    close(mysocket);
+    return -1;
+  }
+  if (setsockopt(mysocket, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof (on)) < 0) {
+    close(mysocket);
+    perror("setsockopt");
+    return -1;
+  }
+  /*
+   * Originally we did this all the time on not windows
+   */
+  if (addr.sin_addr.s_addr == 0) {
+    if (gethostname(hostname, sizeof hostname) < 0) {
+      TRACE(1, ("Can't get my own host name\n"));
+      close(mysocket);
+      return -1;
+    }
+    /* A Hack */
+    if ((h = gethostbyname(hostname)) == 0) {
+      printf("Can't look up my own host name\n");
+      strcpy(hostname, "hutchinson2.home.cs.ubc.ca");
+      if ((h = gethostbyname(hostname)) == 0) {
+		printf("Still can't look up my own host name\n");
+	
+	close(mysocket);
+	return -1;
+      }
+    }
+    memcpy(&addr.sin_addr.s_addr, h->h_addr, sizeof(unsigned int));
+  }
+  myid.ipaddress = addr.sin_addr.s_addr;
+  myid.port = ntohs(addr.sin_port);
+  myid.incarnation = incarnation;
+  TRACE(2, ("Net start on %04x.%04x.%04x\n", myid.ipaddress, myid.port, myid.incarnation));
+  setupListener(mysocket);
+  return 0;
+}
+
+int MTReceive(NodeAddr *senderid, void **rbuf, int *rlen)
+{
+  TRACE(1, ("MTReceive called\n"));
+  MQueueRemove(incoming, senderid, rlen, rbuf);
+  TRACE(2, ("MTReceive returning %d\n", *rlen));
+  return 1;
+}
+
+int MTProd(NodeAddr *receiver)
+{
+  int s = findsocket(receiver);
+  return s;
+}
+
+int MTSend(NodeAddr receiver, void *sbuf, int slen)
+{
+  unsigned int length;
+  int s = findsocket(&receiver), res;
+  extern char *NodeAddrString(NodeAddr);
+  extern int nMessagesSent, nBytesSent;
+
+  nMessagesSent++;
+  nBytesSent += slen;
+
+  TRACE(3, ("Send\n"));
+
+  length = htonl(slen);
+  res = MTwrite2(s, &length, sizeof(length), sbuf, slen);
+  if (res != sizeof(length) + slen) {
+    perror("  mtsend");
+    printf("MTSend to %s, socket %d, for %d bytes returned %d\n",
+	   NodeAddrString(receiver), s, slen + sizeof(length), res);
+    return -1;
+  }
+  TRACE(3, ("Send returning\n"));
+  return 1;
+}
+
+void MTSetDebugLevel(int x)
+{
+#if defined(MTDEBUG)
+  MTdebuglevel = x;
+#endif
+}
+void MTInit()
+{
+#if defined(__svr4__) || defined(__SYSTYPE_SVR4__)
+  struct sigaction action;
+
+  memset(&action, 0, sizeof(action));
+  action.sa_handler = intrHandler;
+  sigaction(SIGINT, &action, NULL);
+  action.sa_handler = pipeHandler;
+  sigaction(SIGPIPE, &action, NULL);
+#else
+  struct sigvec vec;
+  memset(&vec, 0, sizeof(vec));
+
+  vec.sv_handler = intrHandler;
+  SIGVEC(SIGINT, &vec, NULL);
+  vec.sv_handler = pipeHandler;
+  SIGVEC(SIGPIPE, &vec, NULL);
+#endif
+  incoming = MQueueCreate();
+  deferred = MQueueCreate();
+}
+
+#ifdef WIN32
+void perror(const char *msg)
+{
+  printf("%s: %d\n", msg, errno);
+  fflush(stdout);
+}
+#endif /* WIN32 */
+
+void processBoringMessages(void)
+{
+  while (MQueueSize(incoming) == 0) {
+    checkForIO(1);
+  }
+  serveRequest();
+}
+
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/mthreads.h ubc-latest-src/vm/src/mthreads.h
--- sourceforge-1.06alpha/vm/src/mthreads.h	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/mthreads.h	2017-12-11 17:59:03.490711429 +0100
@@ -0,0 +1,40 @@
+#ifndef _EMERALD_MTHREADS_H
+#define _EMERALD_MTHREADS_H
+#pragma warning(disable: 4068)
+#pragma pointer_size save
+#pragma pointer_size long
+#include <sys/types.h>
+
+#ifndef WIN32
+#include <sys/time.h>
+#include <stdarg.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#endif
+#pragma pointer_size restore
+
+#ifdef WIN32
+#ifdef MSVC40
+#include <winsock.h>
+#else
+#include <winsock2.h>
+#endif
+#endif
+
+typedef struct NodeAddr {
+  unsigned int ipaddress;
+  unsigned short port;
+  unsigned short incarnation;
+} NodeAddr;
+
+extern void MTInit(void);
+void MTStart(void);
+
+void MTRegisterExitRoutine(void (*)(void));
+
+int MTNetStart(unsigned int, unsigned short, unsigned short);
+int MTSend(NodeAddr receiver, void *sbuf, int slen);
+int MTProd(NodeAddr *receiver);
+typedef void (*NotifyFunction)(NodeAddr id, int isup);
+void MTRegisterNotify(NotifyFunction);
+#endif /* _EMERALD_MTHREADS_H */
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/newdist.c ubc-latest-src/vm/src/newdist.c
--- sourceforge-1.06alpha/vm/src/newdist.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/newdist.c	2017-12-11 17:59:03.490711429 +0100
@@ -0,0 +1,659 @@
+/*
+ * Copyright (C)
+ * Norman C. Hutchinson and the University of British Columbia, 1998
+ */
+#define E_NEEDS_STRING
+#define E_NEEDS_SOCKET
+#define E_NEEDS_SIGNAL
+#define E_NEEDS_IOV
+#define E_NEEDS_TCP
+#define E_NEEDS_NETDB
+#define E_NEEDS_ERRNO
+#include "system.h"
+
+#include "assert.h"
+#include "types.h"
+#include "mqueue.h"
+#include "storage.h"
+#include "misc.h"
+
+Node myid;
+
+MQueue incoming;
+
+#ifdef DISTRIBUTED
+#include "dist.h"
+#include "remote.h"
+#include "io.h"
+
+#ifdef WIN32
+extern int gettimeofday(struct timeval *, void *);
+#endif /* not WIN32 */
+
+#ifndef SELECTSIZE_T
+#define SELECTSIZE_T size_t
+#endif
+#ifndef SELECTFD_T
+#define SELECTFD_T fd_set
+#endif
+#ifndef SELECTCONST
+#define SELECTCONST const
+#endif
+
+#define MAXOTHERS 128
+static int nothers;
+struct other {
+  Node id;
+  int s;
+} others[MAXOTHERS], cache;
+
+/*
+ * Forward declarations.
+ */
+static void setupReader(struct other *ri);
+
+extern int checkSameUser;
+
+static void pipeHandler(int signalnumber)
+{
+  TRACE(dist, 1, ("Got SIGPIPE"));
+}
+
+ssize_t Dwrite2(int fd, void *buf1, size_t n1, void *buf2, size_t n2)
+{
+  int res;
+  struct iovec v[2];
+  int howmany = 2;
+  v[0].iov_base = buf1;
+  v[0].iov_len = n1;
+  v[1].iov_base = buf2;
+  v[1].iov_len = n2;
+  TRACE(dist, 4, ("write2 on %d for %d+%d bytes", fd, n1, n2));
+  if (fd < 0) return -1;
+  while (1) {
+#ifdef WIN32
+    res = send(fd, v[0].iov_base, v[0].iov_len, 0);
+#else
+    res = writev(fd, v, howmany);
+#endif /* WIN32 */
+    TRACE(dist, 4, ("write2 wrote %d", res));
+    if ((unsigned)res == v[0].iov_len + v[1].iov_len) {
+      res = n1 + n2;
+      break;
+    } else if (res > 0) {
+      /* Only wrote a part, fix up things */
+      if ((unsigned)res < v[0].iov_len) {
+	v[0].iov_len -= res;
+	v[0].iov_base += res;
+      } else {
+	res -= v[0].iov_len;
+	v[0].iov_len = v[1].iov_len - res;
+	v[0].iov_base = v[1].iov_base + res;
+	v[1].iov_base = 0;
+	v[1].iov_len = 0;
+	howmany = 1;
+      }
+    } else if (res <= 0 && errno == EINTR) {
+      /*
+       * Go around the loop.
+       */
+    } else {
+      TRACE(dist, 1, ("write2 on %d for %d+%d bytes returned %d, errno = %d",
+		      fd, n1, n2, res, errno));
+      break;
+    }
+  }
+  TRACE(dist, 4, ("write2 returning %d", res));
+  return res;
+}
+
+struct header {
+  int length;
+};
+
+static int mysocket;
+
+struct nbo {
+  unsigned int ipaddress;
+  unsigned short port, epoch;
+  int userid;
+};
+
+static NotifyFunction notifyFunction;
+
+void DRegisterNotify(NotifyFunction f)
+{
+  assert(notifyFunction == 0);
+  notifyFunction = f;
+}
+
+static void nukeother(struct other o)
+{
+  int from, to;
+  TRACE(dist, 8, ("Nuking %x.%x (%d)", ntohl(o.id.ipaddress), o.id.port, o.s));
+  for (from = 0, to = 0; from < nothers; from++) {
+    if (others[from].s == o.s) {
+      TRACE(dist, 8, ("  Nuking %x.%x (%d)", ntohl(others[from].id.ipaddress), others[from].id.port, others[from].s));
+      /* don't do this one */
+    } else {
+      if (from != to) {
+	others[to++] = others[from];
+      } else {
+	to++;
+      }
+    }
+  }
+  TRACE(dist, 7, ("Nothers went from %d to %d", nothers, to));
+  nothers = to;
+  cache.id.ipaddress = cache.id.port = cache.s = 0;
+}
+
+static void maximizeSocketBuffers(int s)
+{
+#if defined(SO_SNDBUF) && defined(SO_RCVBUF)
+  int size = 0, mid, low, high, len;
+  int which = SO_SNDBUF;
+  do {
+    len = sizeof(low);
+    if (getsockopt(s, SOL_SOCKET, which, (char *)&low, &len) >= 0) {
+      low = low / 1024;
+      high = 128;
+      while (low < high) {
+	mid = size = ((low + high) / 2) * 1024;
+	if (size == low * 1024 || size == high * 1024) break;
+	TRACE(dist, 14, ("Range [%d-%d], trying size %d", low * 1024, high * 1024, size));
+	if (setsockopt(s, SOL_SOCKET, which, (char *)&size, sizeof(size)) < 0) {
+		TRACE(dist, 13, ("Resetting high to %d", mid / 1024));
+	  high = mid / 1024;
+	} else {
+	TRACE(dist, 13, ("Resetting low to %d", mid / 1024));
+
+	  low = mid / 1024;
+	}
+      }
+    }
+    TRACE(dist, 3, ("Set socket buffer size to %d", size));
+    which = (which == SO_SNDBUF ? SO_RCVBUF : -1);
+  } while (which != -1);
+#endif
+}
+
+int findsocket(Node *t, int create)
+{
+  int i, addrlen, s, pos;
+  struct sockaddr_in addr;
+  struct other *o, localcopy;
+  struct nbo nbo;
+
+  TRACE(dist, 7, ("in find socket for %#x.%4x", ntohl(t->ipaddress), t->port));
+  if (cache.id.ipaddress == t->ipaddress && cache.id.port == t->port && cache.s) {
+    TRACE(dist, 8, ("find socket returning %d from cache", cache.s));
+    return cache.s;
+  }
+  for (i = 0; i < nothers; i++) {
+    TRACE(dist, 9, ("  Looking at %#x.%4x", ntohl(others[i].id.ipaddress), others[i].id.port));
+    if (others[i].id.ipaddress == t->ipaddress && others[i].id.port == t->port) {
+      cache = others[i];
+      TRACE(dist, 8, ("find socket returning %d", cache.s));
+      return cache.s;
+    }
+  }
+  if (!create) return -1;
+#if defined(WIN32) && defined(SO_SYNCHRONOUS_NONALERT)
+  {
+    int optionValue = SO_SYNCHRONOUS_NONALERT;
+    int err;
+    err = setsockopt(INVALID_SOCKET,
+		     SOL_SOCKET,
+		     SO_OPENTYPE,
+		     (char *)&optionValue,
+		     sizeof(optionValue));
+    if (err != NO_ERROR) {
+      printf("setsockopt: OPENTYPE failed with %d\n", err);
+      abort();
+    }
+  }
+#endif
+  if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) return -1;
+  memset(&addr, 0, sizeof(addr));
+  addr.sin_family = AF_INET;
+  addr.sin_port = htons(0);
+  addr.sin_addr.s_addr = 0;
+  if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+    perror("findsocket.bind");
+    closesocket(s);
+    return -1;
+  }
+  memset(&addr, 0, sizeof(addr));
+  addr.sin_family = AF_INET;
+  addr.sin_port = htons(t->port);
+  addr.sin_addr.s_addr = t->ipaddress;
+  addrlen = sizeof(addr);
+  TRACE(dist, 1, ("Trying to connect to %08lx.%04x", ntohl(addr.sin_addr.s_addr), ntohs(addr.sin_port)));
+  if (connect(s, (struct sockaddr *)&addr, addrlen) < 0) {
+    TRACE(dist, 3, ("Connect failed with errno %d %s", errno, strerror(errno)));
+    closesocket(s);
+    return -1;
+  }
+  {
+    int on = 1;
+    if (setsockopt(s, IPPROTO_TCP, TCP_NODELAY, (char *)&on, sizeof (on)) < 0) {
+      closesocket(s);
+      perror("setsockopt");
+      return -1;
+    }
+  }
+  maximizeSocketBuffers(s);
+
+  localcopy.id = *t;
+  localcopy.s = s;
+  TRACE(dist, 9, ("Inserting %#x.%d -> %d in others[%d]", ntohl(t->ipaddress), t->port, localcopy.s, nothers));
+  pos = nothers;
+  others[nothers++] = localcopy;
+  {
+    nbo.ipaddress = myid.ipaddress;
+    nbo.port = htons(myid.port);
+    nbo.epoch = htons(myid.epoch);
+    nbo.userid = htonl(getuid());
+    if (writeToSocketN(localcopy.s, &nbo, sizeof(nbo)) != sizeof(nbo) ||
+	readFromSocketN(localcopy.s, &nbo, sizeof(nbo)) != sizeof(nbo)) {
+      TRACE(dist, 0, ("Couldn't exchange epoch info"));
+      closesocket(localcopy.s);
+      nothers--;
+      return -1;
+    } else if(checkSameUser && getuid() != (int)ntohl(nbo.userid)) {
+      printf("Permission denied - user mismatch local %d != remote %d\n", (int)getuid(), (int)ntohl(nbo.userid));
+      closesocket(localcopy.s);
+      nothers--;
+      return -1;
+    }
+    localcopy.id.ipaddress = nbo.ipaddress;
+    localcopy.id.epoch = ntohs(nbo.epoch);
+    assert(localcopy.id.port == ntohs(nbo.port));
+    *t = localcopy.id;
+  }
+  o = (struct other *)vmMalloc(sizeof *o);
+  *o = localcopy;
+  setupReader(o);
+  TRACE(dist, 2, ("find socket returning new %d", localcopy.s));
+  cache = localcopy;
+  if (!SameNode(others[pos].id, cache.id)) {
+    TRACE(dist, 9, ("Inserting %#x.%d -> %d in others[%d]", ntohl(cache.id.ipaddress), cache.id.port, cache.s, nothers));
+    others[nothers++] = cache;
+  }
+  return cache.s;
+}
+
+static void callNotifyFunction(Node id, int comingup)
+{
+  notifyFunction(id, comingup);
+}
+
+typedef struct ReaderState {
+  struct other *ri;
+  readBuffer rb;
+  int readingLength, length;
+} ReaderState;
+
+static void ReaderCB(int sock, EDirection d, void *state)
+{
+  extern int nMessagesReceived, nBytesReceived;
+  ReaderState *rs = state;
+  int res;
+  void *buffer = 0;
+
+  if (!(res = tryReading(&rs->rb, sock))) return;
+  if (res < 0 || res != rs->rb.goal) {
+    /*
+     * Give up on this socket.
+     */
+    resetHandler(sock, EIO_Read);
+    resetHandler(sock, EIO_Except);
+    closesocket(sock);
+    if (notifyFunction) notifyFunction(rs->ri->id, 0);
+    nukeother(*rs->ri);
+    vmFree(rs->ri);
+    vmFree(rs);
+  } else if (rs->readingLength) {
+    nBytesReceived += sizeof(rs->length);
+    rs->length = ntohl(rs->length);
+    rs->readingLength = 0;
+    if (rs->length > 0) {
+      buffer = vmMalloc(rs->length);
+      setupReadBuffer(&rs->rb, buffer, rs->length, 0, readFromSocket);
+    } else {
+      TRACE(dist, 0, ("Negative length %d", rs->length));
+    }
+  } else {
+    nBytesReceived += rs->length;
+    nMessagesReceived ++;
+    assert(ntohl(*(int *)rs->rb.buffer) == 0xdeafdeaf);
+    MQueueInsert(incoming, rs->ri->id, rs->length, rs->rb.buffer);
+    setupReadBuffer(&rs->rb, &rs->length, sizeof(rs->length), 0, readFromSocket);
+    rs->readingLength = 1;
+  }
+}
+
+static void setupReader(struct other *ri)
+{
+  ReaderState *rs = (ReaderState *)vmMalloc(sizeof(*rs));
+  rs->ri = ri;
+  rs->readingLength = 1;
+  setupReadBuffer(&rs->rb, &rs->length, sizeof(rs->length), 0, readFromSocket);
+  setHandler(rs->ri->s, ReaderCB, EIO_Read, rs);
+  setHandler(rs->ri->s, ReaderCB, EIO_Except, rs);
+}
+
+typedef struct {
+  struct other *ri;
+  struct nbo nbo;
+  readBuffer rb;
+} ListenerState;
+  
+static int checkUserOK(int local, int remote)
+{
+  if (checkSameUser && local != remote) {
+      printf("Permission denied - user mismatch local %d != remote %d\n",
+	      local, remote);
+      return 0;
+  } else {
+    return 1;
+  }
+}
+
+static void ListenerStage2(int sock, EDirection d, void *arg)
+{
+  int res;
+  ListenerState *ls = arg;
+  if (!(res = tryReading(&ls->rb, ls->ri->s))) return;
+  resetHandler(sock, EIO_Read);
+  resetHandler(sock, EIO_Except);
+  if (res != sizeof(ls->nbo) || !checkUserOK(getuid(), ntohl(ls->nbo.userid))) {
+    nukeother(*ls->ri);
+    closesocket(ls->ri->s);
+    vmFree(ls->ri);
+  } else {
+    ls->ri->id.port = ntohs(ls->nbo.port);
+    ls->ri->id.ipaddress = ls->nbo.ipaddress;
+    ls->ri->id.epoch = ntohs(ls->nbo.epoch);
+    TRACE(dist, 8, ("Inserting %#x.%4x.%4x -> %d in others[%d]", ntohl(ls->ri->id.ipaddress), ls->ri->id.port, ls->ri->id.epoch, ls->ri->s, nothers));
+    others[nothers++] = *ls->ri;
+    setupReader(ls->ri);
+    if (notifyFunction) callNotifyFunction(ls->ri->id, 1);
+  }
+  vmFree((char *)ls);
+}
+
+static void ListenerCB(int sock, EDirection d, void *s)
+{
+  int newsocket;
+  struct sockaddr_in addr;
+  int addrlen = sizeof(addr), on = 1;
+  ListenerState *ls = (ListenerState *)vmMalloc(sizeof(*ls));
+
+  TRACE(dist, 1, ("ListenerCB on %d", sock));
+  newsocket = accept(sock, (struct sockaddr *)&addr, &addrlen);
+  if (newsocket < 0) return;
+  if (setsockopt(newsocket, IPPROTO_TCP, TCP_NODELAY, (char *)&on, sizeof (on)) < 0) {
+    closesocket(newsocket);
+    perror("setsockopt");
+    return;
+  }
+  maximizeSocketBuffers(newsocket);
+  ls->ri = (struct other *)vmMalloc(sizeof *ls->ri);
+  ls->ri->s = newsocket;
+  ls->ri->id.ipaddress = addr.sin_addr.s_addr;
+  ls->ri->id.port = ntohs(addr.sin_port);
+
+  TRACE(dist, 1, ("Accepted new connection %d from %#x.%x",
+		  ls->ri->s, ntohl(ls->ri->id.ipaddress), ls->ri->id.port));
+  TRACE(dist, 8, ("Inserting %#x.%x -> %d in others[%d]", ntohl(ls->ri->id.ipaddress), ls->ri->id.port, ls->ri->s, nothers));
+  others[nothers++] = *ls->ri;
+  ls->nbo.ipaddress = myid.ipaddress;
+  ls->nbo.port = htons(myid.port);
+  ls->nbo.epoch = htons(myid.epoch);
+  ls->nbo.userid = htonl(getuid());
+  if (send(ls->ri->s, (char *)&ls->nbo, sizeof(ls->nbo), 0) != sizeof(ls->nbo)) {
+    nukeother(*ls->ri);
+    closesocket(ls->ri->s);
+    vmFree(ls->ri);
+    return;
+  }
+  setupReadBuffer(&ls->rb, &ls->nbo, sizeof(ls->nbo), 0, readFromSocket);
+  setHandler(ls->ri->s, ListenerStage2, EIO_Read, ls);
+  setHandler(ls->ri->s, ListenerStage2, EIO_Except, ls);
+}
+
+static void setupListener(int sock)
+{
+  setHandler(sock, ListenerCB, EIO_Read, NULL);
+}
+
+int DNetStart(unsigned int ipaddress, unsigned short port, unsigned short epoch)
+{
+  struct sockaddr_in addr;
+  int addrlen, on = 1;
+  char hostname[128];
+#ifdef alpha
+#pragma pointer_size long
+#endif
+  struct hostent *h;
+#ifdef alpha
+#pragma pointer_size short
+#endif
+
+  assert(myid.ipaddress == 0 && myid.port == 0 && myid.epoch == 0);
+  if ((mysocket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+    return -1;
+  }
+  memset(&addr, 0, sizeof(addr));
+  addr.sin_family = AF_INET;
+  addr.sin_port = htons(port);
+  addr.sin_addr.s_addr = ipaddress;
+  if (bind(mysocket, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+    closesocket(mysocket);
+    return -1;
+  }
+  addrlen = sizeof(addr);
+  if (getsockname(mysocket, (struct sockaddr *)&addr, &addrlen) < 0) {
+    closesocket(mysocket);
+    return -1;
+  }
+  TRACE(dist, 3, ("NetStart on %#lx.%d", addr.sin_addr.s_addr, ntohs(addr.sin_port)));
+  if (listen(mysocket, 5) < 0) {
+    closesocket(mysocket);
+    return -1;
+  }
+  if (setsockopt(mysocket, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof (on)) < 0) {
+    closesocket(mysocket);
+    perror("setsockopt");
+    return -1;
+  }
+  /*
+   * Originally we did this all the time on not windows
+   */
+  if (addr.sin_addr.s_addr == 0 || addr.sin_addr.s_addr == htonl(0x7f000001)) {
+    if (gethostname(hostname, sizeof hostname) < 0) {
+      printf("Can't get my own host name.\n");
+      printf("Emerald won't work well between machines.\n");
+    } else if ((h = gethostbyname(hostname)) == 0) {
+      printf("Can't look up my own host name.\n");
+      printf("Emerald won't work well between machines.\n");
+    } else {
+      memcpy(&addr.sin_addr.s_addr, h->h_addr, sizeof(unsigned int));
+    }
+  }
+  myid.ipaddress = addr.sin_addr.s_addr;
+  myid.port = ntohs(addr.sin_port);
+  myid.epoch = epoch;
+  TRACE(dist, 2, ("Net start on %04x.%04x.%04x", ntohl(myid.ipaddress), myid.port, myid.epoch));
+  setupListener(mysocket);
+  return 0;
+}
+
+int DProd(Node *receiver)
+{
+  int s = findsocket(receiver, 1);
+  return s;
+}
+
+int DSend(Node receiver, void *sbuf, int slen)
+{
+  unsigned int length;
+  int s = -1, res = 1;
+  extern char *NodeString(Node);
+  extern int nMessagesSent, nBytesSent;
+  noderecord *nr;
+
+
+  if (SameNode(receiver, myid)) {
+    res = -1;
+  } else if (isNoNode(receiver)) {
+    res = -1;
+  } else {
+    nr = getNodeRecordFromSrv(receiver);
+    if (nr && !nr->up) {
+      /*
+       * We have an entry for this node, and it is down.
+       */
+      res = -1;
+    } else {
+      s = findsocket(&receiver, 1);
+      nMessagesSent++;
+      nBytesSent += slen;
+
+      TRACE(dist, 3, ("Send"));
+
+      length = htonl(slen);
+      res = Dwrite2(s, &length, sizeof(length), sbuf, slen);
+      if (res != sizeof(length) + slen) {
+	TRACE(dist, 1, ("DSend to %s, socket %d, for %d bytes returned %d\n",
+			NodeString(receiver), s, slen + sizeof(length), res));
+	res = -1;
+      }
+    }
+  }
+  TRACE(dist, ((res < 0) ? 1 : 5), ("DSend %d to %s on %d returning %d", slen,
+				    NodeString(receiver), s, res));
+  return res;
+}
+
+void processMessages(void)
+{
+  if (MQueueSize(incoming) == 0) checkForIO(1);
+  if (MQueueSize(incoming) > 0) serveRequest();
+}
+
+#endif
+
+#ifdef __linux
+# define sigvec		sigaction
+# define sv_mask	sa_mask
+# define sv_flags	sa_flags
+# define sv_handler	sa_handler
+# define sv_onstack	sa_mask /* ouch, this one really hurts */
+#endif /* __linux */
+
+#ifdef hp700
+#define SIGVEC sigvector
+#else
+#define SIGVEC sigvec
+#endif /* hp700 */
+
+void establishHandler(int sig, void (*handler)(int))
+{
+#if defined(__svr4__) || defined(__SYSTYPE_SVR4__) || defined(CYGWIN)
+  struct sigaction action;
+
+  memset(&action, 0, sizeof(action));
+  action.sa_handler = handler;
+  sigaction(sig, &action, NULL);
+#else
+#if defined(WIN32) || defined(DOS)
+  signal(sig, handler);
+#else
+  struct sigvec vec;
+  memset(&vec, 0, sizeof(vec));
+
+  vec.sv_handler = handler;
+  SIGVEC(sig, &vec, NULL);
+#endif
+#endif
+}
+
+void DInit(void)
+{
+  extern void sigdie(int);
+  establishHandler(SIGINT, sigdie);
+#if defined(SIGPIPE) && defined(DISTRIBUTED)
+  establishHandler(SIGPIPE, pipeHandler);
+#endif
+  incoming = MQueueCreate();
+}
+
+#ifdef WIN32
+void perror(const char *msg)
+{
+  printf("%s: %d\n", msg, errno);
+  fflush(stdout);
+}
+#endif /* WIN32 */
+
+char *NodeString(Node srv)
+{
+  static char buf[5][60];
+  static int i = 0;
+  char *rval;
+
+  rval = buf[i]; i = (i+1) % 5;
+  sprintf(rval, "%08lx.%04x.%04x", ntohl(srv.ipaddress), srv.port, srv.epoch);
+  return rval;
+}
+
+int getplane()
+{
+  int port = 0;
+  extern int offsetbyuserid;
+  char *plane = getenv("EMPLANE");
+  if (plane) {
+    port += mstrtol(plane, 0, 10);
+  } else if (offsetbyuserid) {
+    port += getuid() % EMERALDPORTSKIP;
+  }
+  return port;
+}
+
+
+int InitDist()
+{
+  extern Node MyNode;
+  extern OID MyBaseOID;
+  int port;
+  extern char *getenv(const char *);
+
+  InitStorage();
+
+  MyNode.epoch = random() & 0xffff;
+  /* start up the network subsystem */
+  port = EMERALDFIRSTPORT + getplane();
+  
+#ifdef DISTRIBUTED
+  while (DNetStart(0,  port, MyNode.epoch) != 0) {
+    port = EMERALDPORTPROBE(port);
+    if (port > 0x10000) return -1;
+  }
+#else
+  myid.ipaddress = 0xdeadbeef;
+  myid.port = port;
+  myid.epoch = MyNode.epoch;
+#endif
+  MyNode.ipaddress = myid.ipaddress;
+  MyNode.port = myid.port;
+  MyNode.epoch = myid.epoch;
+  MyBaseOID.ipaddress = ntohl(MyNode.ipaddress);
+  MyBaseOID.port = MyNode.port;
+  MyBaseOID.epoch = MyNode.epoch;
+
+  return 0;
+}
+
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/ntoh.h ubc-latest-src/vm/src/ntoh.h
--- sourceforge-1.06alpha/vm/src/ntoh.h	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/ntoh.h	2017-12-11 17:59:03.490711429 +0100
@@ -0,0 +1,15 @@
+#ifndef _EMERALD_NTOH_H
+#define _EMERALD_NTOH_H
+#ifdef WIN32
+/*
+ * For some reason ntoh is in some standard place in WIN32.  I don't know why?
+ */
+#else
+#include <types.h>
+#include <netinet/in.h>
+#ifdef sgi
+#include <endian.h>
+#endif
+#endif
+
+#endif /* _EMERALD_NTOH_H */
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/oidtoobj.c ubc-latest-src/vm/src/oidtoobj.c
--- sourceforge-1.06alpha/vm/src/oidtoobj.c	2017-12-11 17:59:03.090714477 +0100
+++ ubc-latest-src/vm/src/oidtoobj.c	2017-12-11 17:59:03.490711429 +0100
@@ -43,7 +21,11 @@
 #include "read.h"
 #include "assert.h"
 
-#define OBJECTTABLESIZE 101
+/*
+ * The initial size of the object table.  If it is too small, it gets
+ * increased, but due to malloc's behaviour it costs a lot of data space.
+ */
+#define OBJECTTABLESIZE (24 * 1024)
 
 OTable ObjectTable;
 
@@ -59,7 +41,7 @@
  */
 
 void OIDToObjectInit() {
-  ObjectTable = OTableCreateN(4*1024);
+  ObjectTable = OTableCreateN(OBJECTTABLESIZE);
 }
 
 /*
@@ -81,8 +63,7 @@
 #ifndef NDEBUG
   Object old = OIDFetch(oid);
   if (old != o) {
-    ftrace("Botch:  %#x != %#x", (u32)old , (u32)o);
-    assert(0);
+    ftrace("OIDRemove botch:  %#x != %#x", (u32)old , (u32)o);
   }
 #endif
   TRACE(oid, 3, ("Removing id from %#x %s", o, OIDString(oid)));
@@ -108,10 +89,10 @@
   old = OIDFetch(oid);
   if (!ISNIL(old)) {
     if (old != o) {
-      ConcreteType oldct = CODEPTR(old->flags);
       TRACE(oid, 0, ("Defining an id that already exists %s -> %#x, a %.*s",
 		     OIDString(oid), old,
-		     oldct->d.name->d.items, oldct->d.name->d.data));
+		     CODEPTR(old->flags)->d.name->d.items,
+		     CODEPTR(old->flags)->d.name->d.data));
     }
     OTableDeleteByObject(ObjectTable, old);
   }
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/oidtoobj.h ubc-latest-src/vm/src/oidtoobj.h
--- sourceforge-1.06alpha/vm/src/oidtoobj.h	2017-12-11 17:59:03.090714477 +0100
+++ ubc-latest-src/vm/src/oidtoobj.h	2017-12-11 17:59:03.490711429 +0100
@@ -55,6 +33,7 @@
 extern OID FOIDOf(Object o);
 extern OID nooid;
 extern AbCon findAbCon(OID, OID), findConCon(ConcreteType);
+int findOpByName(ConcreteType ct, char *name);
 extern void UpdateObjectLocation(Object oldo, Object newo);
 
 char *OIDString( OID );
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/otable.c ubc-latest-src/vm/src/otable.c
--- sourceforge-1.06alpha/vm/src/otable.c	2017-12-11 17:59:03.091714470 +0100
+++ ubc-latest-src/vm/src/otable.c	2017-12-11 17:59:03.490711429 +0100
@@ -129,7 +107,7 @@
   register indexType ohash, oidhash;
 
   assert(!ISNIL(value));
-  if (sc->count >= sc->size) ExpandHashTable(sc);
+  if (sc->count >= sc->size - 1) ExpandHashTable(sc);
 
   index = sc->free;
   assert(index);
@@ -285,6 +263,10 @@
 {
   Object value;
   OTableTEPtr e = LookupByOID(sc, a);
+  if (!e) {
+    TRACE(oid, 2, ("Can't delete object %#x from otable", a));
+    return;
+  }
   value = e->value;
   Delete(sc, e);
 }
@@ -293,6 +275,10 @@
 {
   OID oid;
   OTableTEPtr e = LookupByObject(sc, a);
+  if (!e) {
+    TRACE(oid, 2, ("Can't delete object %#x from otable", a));
+    return;
+  }
   oid = e->key;
   Delete(sc, e);
 }
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/otable.h ubc-latest-src/vm/src/otable.h
--- sourceforge-1.06alpha/vm/src/otable.h	2017-12-11 17:59:03.091714470 +0100
+++ ubc-latest-src/vm/src/otable.h	2017-12-11 17:59:03.490711429 +0100
@@ -34,7 +12,7 @@
 
 #define OTableIsNIL(X) (ISNIL(X))
 
-typedef unsigned short indexType;
+typedef unsigned int indexType;
 
 /*
  * Hidden, private type declarations.  The only thing
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/read.c ubc-latest-src/vm/src/read.c
--- sourceforge-1.06alpha/vm/src/read.c	2017-12-11 17:59:03.091714470 +0100
+++ ubc-latest-src/vm/src/read.c	2017-12-11 17:59:03.490711429 +0100
@@ -1020,7 +998,7 @@
 	       at->d.name->d.data,
 	       at->d.filename->d.items,
 	       at->d.filename->d.data));
-      } else if ((int)ct < NUMBUILTINS){
+      } else if ((unsigned int)ct < NUMBUILTINS){
 	TRACE(trans, 2, ("%#x has ct index %#x", o, ct));
       } else {
 	TRACE(trans, 2, ("%#x has ct %#x, a %.*s",
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/remote.c ubc-latest-src/vm/src/remote.c
--- sourceforge-1.06alpha/vm/src/remote.c	2017-12-11 17:59:03.091714470 +0100
+++ ubc-latest-src/vm/src/remote.c	2017-12-11 17:59:03.491711421 +0100
@@ -59,6 +37,7 @@
 extern int doDistribution;
 void *ctstr;
 Node ctsrv;
+#if !defined(NTRACE)
 static char *typenames[] = {
   "EchoRequest",
   "EchoReply",
@@ -81,7 +60,7 @@
   "DistGCDoneRequest",
   "DistGCDoneReply",
   "DistGCDoneReport" };
-  
+#endif  
 
 int isLimbo(Node n)
 {
@@ -208,16 +187,14 @@
 #ifdef DISTRIBUTED
 void parseAddr(char *str, unsigned int *addr, unsigned short *port)
 {
-  char *colon, *plane, *comma;
+  char *colon, *comma;
   struct hostent *h = NULL;
 
   comma = (char *)strchr(str, ',');
   if (comma) *comma = '\0';
   colon = (char *)strchr(str, ':');
   if (!colon) {
-    *port = EMERALDFIRSTPORT;
-    plane = getenv("EMPLANE");
-    if (plane) *port += mstrtol(plane, 0, 10);
+    *port = EMERALDFIRSTPORT + getplane();
   } else {
     *colon = '\0';
     *port = mstrtol(colon + 1, 0, 0);
@@ -225,7 +202,7 @@
   if ('a' <= str[0] && str[0] <= 'z') {
     h = gethostbyname(str);
     if (h == NULL) {
-      TRACE(rinvoke, 0, ("parseAddr: gethostbyname failed!"));
+      fprintf(stderr, "parseAddr: gethostbyname failed!\n");
       return;
     } else { 
       memcpy(addr, h->h_addr, sizeof(*addr));
@@ -367,8 +344,7 @@
   stack[1] = (int)ctdg;
   rootdir = CreateObjectFromOutside(ctd, (u32)stack);
   if (doDistribution) {
-    fprintf(stdout,"Emerald listening on port %d %x, epoch %d %x\n", myid.port, myid.port, myid.epoch, myid.epoch);
-    fflush(stdout);
+    printf("Emerald listening on port %d %x, epoch %d %x\n", myid.port, myid.port, myid.epoch, myid.epoch);
   }
 #endif
 
@@ -633,18 +609,39 @@
   } ISetNext();
 }
 
+static void doUpcallHandlers(Object thenode, Object theinctm, char *name)
+{
+  Object args[4];
+  int fn, fail = 0;
+  ConcreteType nodect;
+
+  if (ISNIL(node)) return;
+  nodect = BuiltinInstCT(NODEI);
+
+  args[0] = thenode;
+  args[1] = (Object)CODEPTR(thenode->flags);
+  args[2] = theinctm;
+  args[3] = (Object)CODEPTR(theinctm->flags);
+  fn = findOpByName(nodect, name);
+  upcall(node, fn, &fail, 2, 0, (int *)args);
+}
+
 static void nukeNode(noderecord *nd)
 {
-  assert(!nd->up);
+  Object thenode, theinctm;
+  theinctm = OIDFetch(nd->inctm);
+  thenode = OIDFetch(nd->node);
+  nd->up = 0;
   invokeHandleDown(nd);
   moveHandleDown(nd);
   locateHandleDown(nd);
+  doUpcallHandlers(thenode, theinctm, "nodedown");
 }
 
 noderecord *update_nodeinfo_fromOIDs(OID nodeOID, OID inctmOID, int up)
 {
   noderecord **nd;
-  Object thenode;
+  Object thenode, inctm;
   ConcreteType ct;
 
   TRACE(rinvoke, 8, ("Updating node info for %08x.%04x.%04x -> %s", nodeOID.ipaddress, nodeOID.port, nodeOID.epoch, up ? "up": "down"));
@@ -654,7 +651,9 @@
 	nodeOID.epoch == (*nd)->node.epoch) {
       TRACE(rinvoke, 9, ("Already had one"));      
       (*nd)->up = up;
-      if (!up) nukeNode(*nd);
+      if (!up) {
+	nukeNode(*nd);
+      } 
       return *nd;
     }
   }
@@ -662,7 +661,8 @@
   TRACE(rinvoke, 9, ("Making a new one"));      
   *nd = (noderecord*) vmMalloc(sizeof(noderecord));
   assert(*nd != NULL);
-  (*nd)->up = up; (*nd)->p = NULL; nodecount++;
+  (*nd)->p = NULL; nodecount++;
+  (*nd)->up = up; 
   (*nd)->srv.ipaddress =  htonl(nodeOID.ipaddress);
   (*nd)->srv.port = nodeOID.port;
   (*nd)->srv.epoch = nodeOID.epoch;
@@ -678,11 +678,12 @@
   ct = BuiltinInstCT(TIMEI); assert(ct);
   (*nd)->inctm = inctmOID;
   if (up) {
-    if (ISNIL(doObjectRequest((*nd)->srv, &(*nd)->inctm, ct))) {
+    inctm = doObjectRequest((*nd)->srv, &(*nd)->inctm, ct);
+    if (ISNIL(inctm)) {
       TRACE(rinvoke, 0, ("update_nodeinfo: failed to retrieve inctm"));
       *nd = (*nd)->p; nodecount--; return NULL;
     }
-  } else if (! ISNIL(OIDFetch((*nd)->inctm))) {
+  } else if (! ISNIL((inctm = OIDFetch((*nd)->inctm)))) {
     /* We already have the object */
   } else {
     /* TODO:
@@ -690,16 +691,15 @@
        believe that we will never have stubs for immutable objects.
      */
     int stack[512];
-    Object o;
     ct = BuiltinInstCT(TIMEI); assert(ct);
     stack[0] = 0;
     stack[1] = (unsigned int) intct;
     stack[2] = 0;
     stack[3] = stack[1];
-    o = CreateObjectFromOutside(ct, (u32)stack);
-    OIDInsert(inctmOID, o);
+    inctm = CreateObjectFromOutside(ct, (u32)stack);
+    OIDInsert(inctmOID, inctm);
   }
-
+  doUpcallHandlers(thenode, inctm, up ? "nodeup" : "nodedown");
   return *nd;
 }
 
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/rinvoke.c ubc-latest-src/vm/src/rinvoke.c
--- sourceforge-1.06alpha/vm/src/rinvoke.c	2017-12-11 17:59:03.091714470 +0100
+++ ubc-latest-src/vm/src/rinvoke.c	2017-12-11 17:59:03.491711421 +0100
@@ -49,6 +27,7 @@
 
 int receivingObjects = 0;
 extern int debugInteractively;
+extern int fakeUnavailable;
 
 #ifdef DISTRIBUTED
 
@@ -220,7 +199,7 @@
   Stream newstr;
   int argc = h->option2, retc = h->option1, fn = h->status, i;
   Object obj;
-  ConcreteType ct;
+  ConcreteType ct = 0;
   RemoteOpHeader replyh;
   int *sp;
   State *state;
@@ -271,6 +250,9 @@
 	findAndSendTo(h->target, newstr);
       }
     }
+  } else if (fakeUnavailable && ((random() % 100) < fakeUnavailable)) {
+    newstr = StealStream(str);
+    sendUnavailableReply(newstr);
   } else {
     OID oid;
     state = newState(obj, ct);
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/sisc.c ubc-latest-src/vm/src/sisc.c
--- sourceforge-1.06alpha/vm/src/sisc.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/sisc.c	2017-12-11 17:59:03.491711421 +0100
@@ -0,0 +1,273 @@
+/*
+ * Searchable Collections:
+ *
+ * Expanding hash tables with a key and data.
+ */
+
+#include "system.h"
+
+#include "assert.h"
+#include "sisc.h"
+
+static int sizes[] = {
+  5, 7, 17, 31,
+  67, 131, 257, 521,
+  1031, 2053, 4099, 8093,
+  16193, 32377, 65557, 131071,
+  262187, 524869, 1048829, 2097223,
+  4194371, 8388697, 16777291 };
+#define MAXFILL(x) (((x) * 17) / 20)
+
+/*
+ * Turning this on will cause the package to self-check on every (modifying)
+ * operation.  The package runs very slowly when this is enabled.
+ */
+#undef DEBUGSC
+
+static unsigned stringintHash(unsigned char *);
+
+#define Hash(key, sc) (HASH(key) % sc->size)
+
+#ifdef DEBUGSC
+static void CheckOutHashTable();
+#define CHECKOUTHASHTABLE(sc) CheckOutHashTable(sc)
+#else
+#define CHECKOUTHASHTABLE(sc) 
+#endif
+
+/* Return a new, empty SISc */
+SISc SIScCreate()
+{
+  register int i;
+  register SISc sc;
+
+  sc = (SISc) vmMalloc(sizeof(SIScRecord));
+  sc->size = sizes[0];
+  sc->maxCount = MAXFILL(sc->size);
+  sc->count = 0;
+  sc->table = (SIScTEPtr) vmMalloc((unsigned) sc->size * sizeof(SIScTE));
+  for (i = 0; i < sc->size; i++) {
+    sc->table[i].key = NULL;
+  }
+  CHECKOUTHASHTABLE(sc);
+  return sc;
+}
+
+void SIScDestroy(sc)
+register SISc sc;
+{
+  vmFree((char *)sc->table);
+  vmFree((char *)sc);
+}
+
+/* Expand the hash table.  Each element in the table is re-hashed and entered 
+ * in the new table. */
+static void ExpandHashTable(SISc sc)
+{
+  register SIScTE *nh, *oe, *ne;
+  register int oldHashTableSize = sc->size, i;
+  register DomainType key;
+  int index;
+
+  for (i = 0; sizes[i] <= oldHashTableSize; i++) ;
+  sc->size = sizes[i];
+  sc->maxCount = MAXFILL(sc->size);
+  nh = (SIScTEPtr) vmMalloc((unsigned)(sc->size * sizeof(SIScTE)));
+  for (i = 0; i < sc->size; i++) nh[i].key = NULL;
+  for (i = 0; i < oldHashTableSize; i++) {
+    oe = &sc->table[i];
+    key = oe->key;
+    if (key == NULL) continue;
+    index = Hash((unsigned char *)key, sc);
+    while (1) {
+      ne = &nh[index];
+      if (ne->key == NULL) {
+	ne->key = oe->key;
+	ne->value = oe->value;
+	break;
+      } else {
+	assert(ne->key !=key);
+	index++;
+	if (index >= sc->size) index = 0;
+      }
+    }
+  }
+  vmFree((char *)sc->table);
+  sc->table = nh;
+  CHECKOUTHASHTABLE(sc);
+}
+
+/* Return the value associated with key in collection sc, or SIScNIL */
+RangeType SIScLookup(sc, key)
+register SISc sc;
+register DomainType  key;
+{
+  register int index = Hash((unsigned char *)key, sc);
+  register SIScTEPtr e;
+
+  CHECKOUTHASHTABLE(sc);
+  while (1) {
+    e = &sc->table[index];
+    if (e->key == NULL) {               /* we did not find it */
+      return SIScNIL;
+    } else if (COMPARE(e->key, key)) {
+      return e->value;
+    }
+    if (++index >= sc->size) index = 0;
+  }
+}
+
+/* Insert the key, value pair in sc.  If the key already exists, change its 
+ * value. */
+void SIScInsert(sc, key, value)
+register SISc sc;
+register DomainType key;
+RangeType value;
+{
+  register int index;
+  register SIScTEPtr e;
+
+  if (sc->count >= sc->maxCount) ExpandHashTable(sc);
+  index = Hash((unsigned char *)key, sc);
+  while (1) {
+    e = &sc->table[index];
+    if (e->key == NULL) {               /* put it here */
+      e->key = key;
+      e->value = value;
+      sc->count++;
+      CHECKOUTHASHTABLE(sc);
+      return;
+    } else if (COMPARE(e->key, key)) {
+      e->value = value;
+      CHECKOUTHASHTABLE(sc);
+      return;
+    }
+    if (++index >= sc->size) index = 0;
+  }
+}
+
+/* Remove the entry, if it is there */
+void SIScDelete(sc, key)
+register SISc sc;
+register DomainType key;
+{
+  register int index = Hash((unsigned char *)key, sc);
+  register RangeType value;
+  register SIScTEPtr e;
+
+  while (1) {
+    e = &sc->table[index];
+    if (e->key == NULL) {               /* we did not find it */
+      CHECKOUTHASHTABLE(sc);
+      return;
+    }
+    if (COMPARE(e->key, key)) {
+      /* Found it, now remove it */
+      sc->count--;
+      e->key = NULL;
+      e->value = (int)NULL;
+      while (1) {
+	/* rehash until we reach nil again */
+	if (++index >= sc->size) index = 0;
+	e = & sc->table[index];
+	key = e->key;
+	if (key == NULL) {
+	  CHECKOUTHASHTABLE(sc);
+	  return;
+	}
+	/* rehashing is done by removing then reinserting */
+	value = e->value;
+	e->key = NULL;
+	e->value = (int)NULL;
+	sc->count--;
+	SIScInsert(sc, key, value);
+      }
+    }
+    if (++index >= sc->size) index = 0;
+  }
+}
+
+/* DEBUGGING: Print the sc */
+void SIScPrint(sc)
+register SISc sc;
+{
+  DomainType key;
+  RangeType value;
+  int index;
+
+  printf(
+    "\nDump of sc @ 0x%05x, %d entr%s, current max %d\nIndex\tKey\t\tValue\n",
+    (int)sc, sc->count, sc->count == 1 ? "y" : "ies",  sc->maxCount);
+  for (index = 0; index < sc->size; index++) {
+    key = sc->table[index].key;
+    value = sc->table[index].value;
+    printf("%3d\t%-16.16s0x%08x\n", index, key, value);
+  }
+}
+
+#ifdef DEBUGSC
+/* Make sure that the hash table is internally consistent:
+ *      every key is findable, 
+ *      count reflects the number of elements
+ */
+static void CheckOutHashTable(sc)
+register SISc sc;
+{
+  register int i;
+  register SIScTEPtr realElement, e;
+  register int index, firstIndex, count;
+  count = 0;
+
+  for (i = 0; i < sc->size; i++) {
+    realElement = &sc->table[i];
+    if (realElement->key != NULL) {
+      count++;
+      index = Hash((unsigned char *)realElement->key, sc);
+      firstIndex = index;
+      while (1) {
+	e = &sc->table[index];
+	if (e->key == NULL) {           /* we did not find it */
+	  break;
+	} else if (COMPARE(e->key, realElement->key)) {
+	  break;
+	} else {
+	  index++;
+	  if (index >= sc->size) index = 0;
+	  if (index == firstIndex) {
+	    index = -1;
+	    break;
+	  }
+	}
+      }
+      
+      if (index == -1 || !COMPARE(e->key, realElement->key)) {
+	/* FIX THIS */
+	fprintf(stderr,
+	  "Sc problem: Key %s, rightIndex %d, realIndex %d value 0x%x\n",
+	  realElement->key, firstIndex, index, realElement->value);
+	SIScPrint(sc);
+      }
+    }
+  }  
+  if (count != sc->count) {
+    fprintf(stderr,
+      "Sc problem: Should have %d entries, but found %d.\n", sc->count,
+      count);
+    SIScPrint(sc);
+  }
+}
+#endif
+/* String hashing function, from Red Dragon Book */
+
+static unsigned stringintHash(unsigned char *key)
+{
+  register unsigned h = 0, g;
+  for (; *key; key++) {
+    h =  (h << 4) + (*key);
+    if ((g = h & 0xf0000000)) {
+      h = h ^ (g >> 24);
+      h = h ^ g;
+    }
+  }
+  return h;
+}
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/sisc.h ubc-latest-src/vm/src/sisc.h
--- sourceforge-1.06alpha/vm/src/sisc.h	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/sisc.h	2017-12-11 17:59:03.491711421 +0100
@@ -0,0 +1,94 @@
+/* 
+ * SIScs (searchable collections) are things that map 
+ * elements of some domain onto some range.  Operations:
+ *	create, destroy, insert, lookup, size, and print
+ */
+
+#ifndef _EMERALD_SISC_H
+#define _EMERALD_SISC_H
+/*
+ * Before using this, one must define the following:
+ *	DomainType	- a typedef for the domain
+ *	RangeType	- a typedef for the range
+ *	HASH		- a macro that computes an integer from a given
+ *			  element of the domain
+ *	COMPARE		- a macro that compares two elements of the domain,
+ *			  evaluating to 1 if they are the same
+ */
+typedef char *DomainType;
+typedef int   RangeType;
+
+#define COMPARE(A, B) (!strcmp((A), (B)))
+
+#define HASH(key) stringintHash((unsigned char *)key)
+#define SIScNIL (-1)
+#define SIScIsNIL(x) (((int)x) == SIScNIL)
+
+/*
+ * Hidden, private type declarations.  The only thing
+ * that applications of this package are to see is SISc,
+ * and they are to treat it as opaque:  that is, they may
+ * assign it, and pass it as arguments, but not manipulate
+ * what it points to directly.
+ */
+
+typedef struct SIScTE {
+    DomainType	 key;		/* the key for this entry */
+    RangeType	 value;		/* what we want */
+} SIScTE, *SIScTEPtr;
+
+typedef struct SIScRecord {
+    SIScTEPtr table;
+    int size, maxCount, count;
+} SIScRecord, *SISc;
+
+/* OPERATIONS */
+
+/* Return a new, empty Searchable Collection */
+SISc SIScCreate(void);
+
+/* Destroy a collection */
+void SIScDestroy(SISc sc);
+
+/* Insert the pair <key, value> into collection SISc */
+void SIScInsert(SISc sc, DomainType key, RangeType value);
+
+/* Delete the pair with key key from the collection SISc */
+void SIScDelete(SISc sc, DomainType key);
+
+/* Return the value associated with key in collection 
+ * SISc, or 0 if no such pair exists */
+int SIScLookup(SISc sc, DomainType key);
+
+/* DEBUGGING: Print the collection SISc */
+void SIScPrint(SISc sc);
+
+/* Iterate over the elements of the collection SISc.  
+ * At each iteration, SISckey and SIScvalue are set to the next
+ * <key, value> pair in the collection.  
+ * Usage:
+ *	SIScForEach(someSc, key, value) {
+ *	  / * whatever you want to do with key, value * /
+ *	} SIScNext();
+ */
+#define SIScForEach(SISc, SISckey, SIScvalue) \
+  { \
+    int SIScxx_index; \
+    for (SIScxx_index = 0; SIScxx_index < (SISc)->size; SIScxx_index++) { \
+      if ((SISc)->table[SIScxx_index].key != NULL) { \
+	(SISckey) = SISc->table[SIScxx_index].key; \
+	*(RangeType *)(&(SIScvalue)) = SISc->table[SIScxx_index].value; \
+	{ 
+
+#define SIScNext() \
+	} \
+      } \
+    } \
+  }
+
+/* Return the number of elements in SISc */
+#define SIScSize(SISc) ((SISc)->count)
+
+#include "storage.h"
+
+#endif /* _EMERALD_SISC_H */
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/sockstr.c ubc-latest-src/vm/src/sockstr.c
--- sourceforge-1.06alpha/vm/src/sockstr.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/sockstr.c	2017-12-11 17:59:03.491711421 +0100
@@ -0,0 +1,221 @@
+/****************************************************************************
+ File     : socketstreams.c 
+ Date     : 08-11-92
+ Author   : Mark Immel
+
+ Contents : Socket Streams package
+
+ Modifications
+ -------------
+
+*****************************************************************************/
+
+#include <stddef.h>
+#ifdef WIN32
+#include <io.h>
+#else /* not WIN32 */
+#include <sys/file.h>
+#endif /* not WIN32 */
+#include <sys/stat.h>
+#ifndef WIN32
+#include <sys/socket.h>
+#endif
+#include "sockstr.h"
+#include "error.h"
+#include "memory.h"
+#include "misc.h"
+#include "assert.h"
+
+/*
+ * NOTE: The code in this file assumes that sizeof(int) <= sizeof(void *).
+ *       The Hook pointer is used to store a file descriptor.  If this is
+ *       inappropriate, set the Hook pointer to point to the file descriptor.
+ */
+
+#define READSOCKETBUFFERSIZE  4096
+#define WRITESOCKETBUFFERSIZE 4096
+
+static struct StreamConstructor ReadSocketStreamConstructor;
+static struct StreamConstructor WriteSocketStreamConstructor;
+
+StreamConstructor ReadSocketStream = &ReadSocketStreamConstructor;
+StreamConstructor WriteSocketStream = &WriteSocketStreamConstructor;
+
+static int  CreateReadSocketStream(StreamBuffer theBuffer, void **Hook);
+static int  FillReadSocketStream(StreamBuffer theBuffer, void **Hook);
+static int  DestroyReadSocketStream(StreamBuffer theBuffer, void **Hook);
+
+static int  CreateWriteSocketStream(StreamBuffer theBuffer, void **Hook);
+static int  FlushWriteSocketStream(StreamBuffer theBuffer, void **Hook);
+static int  DestroyWriteSocketStream(StreamBuffer theBuffer, void **Hook);
+
+static struct StreamConstructor ReadSocketStreamConstructor = {
+  Read,
+  CreateReadSocketStream,
+  FillReadSocketStream,
+  DestroyReadSocketStream,
+  NULL };
+
+static struct StreamConstructor WriteSocketStreamConstructor = {
+  Write,
+  CreateWriteSocketStream,
+  FlushWriteSocketStream,
+  DestroyWriteSocketStream,
+  NULL }; 
+
+static StreamBuffer BufferCache[MAX_FILE_DESCRIPTORS];
+
+/*
+ * Initialize a new ReadSocketStream
+ *
+ * Hook should point to the file descriptor of the socket.
+ * This function then resets Hook to contain the file descriptor.
+ */
+
+static int
+CreateReadSocketStream(StreamBuffer theBuffer, void **Hook)
+{
+  int   fd;
+
+  assert(sizeof(int) <= sizeof(void *)); /* Make sure it's OK to store
+					    fd in *Hook */
+
+  fd = *((int *) *Hook);
+  *((int *) Hook) = fd;
+
+  theBuffer->Start = (StreamByte *) vmMalloc(READSOCKETBUFFERSIZE);
+  theBuffer->End = theBuffer->Start + READSOCKETBUFFERSIZE;
+  theBuffer->Head = theBuffer->Start;
+  theBuffer->ValidBytes = 0;
+
+  BufferCache[fd] = theBuffer;
+  RegisterFD(fd, ProcessNewSocketData);
+  return 0;
+}
+
+/*
+ * Fill the file buffer
+ */
+
+#ifdef WIN32
+#define read _read
+#define close _close
+#define write _write
+#endif
+
+static int
+FillReadSocketStream(StreamBuffer theBuffer, void **Hook)
+{
+  int fd, BytesRead;
+
+  fd = *((int *) Hook);
+
+  BytesRead = read(fd, theBuffer->Start + theBuffer->ValidBytes,
+		   theBuffer->End - theBuffer->Start - theBuffer->ValidBytes);
+
+  if (BytesRead < 0) {
+#ifndef WIN32
+    if (errno == EWOULDBLOCK)
+      return 0;
+    else
+#endif /* not WIN32 */
+      FatalError("FillReadSocketStream ");
+  }
+  
+  if (BytesRead == 0)
+    theBuffer->AtEOF = 1;
+
+  return BytesRead;
+}
+
+/*
+ * Destroy the ReadSocketStream 
+ */
+
+static int
+DestroyReadSocketStream(StreamBuffer theBuffer, void **Hook)
+{
+  int fd;
+
+  fd = *((int *) Hook);
+
+  UnRegisterFD(fd);
+  if (close(fd) < 0) 
+    FatalError("DestroyReadSocketStream ");
+
+  if (theBuffer->Start)
+    vmFree(theBuffer->Start);
+  return 0;
+}
+
+/*
+ * Initialize a new WriteSocketStream
+ *
+ * Hook should point to a char * containing the name of the file to open.
+ * This function then resets Hook to contain the file descriptor.
+ */
+
+static int
+CreateWriteSocketStream(StreamBuffer theBuffer, void **Hook)
+{
+  int   fd;
+
+  assert(sizeof(int) <= sizeof(void *)); /* Make sure it's OK to store
+					    fd in *Hook */
+
+  fd = *((int *) *Hook);
+  *((int *) Hook) = fd;
+
+  theBuffer->Start = (StreamByte *) vmMalloc(WRITESOCKETBUFFERSIZE);
+  theBuffer->End = theBuffer->Start + WRITESOCKETBUFFERSIZE;
+  theBuffer->Head = theBuffer->Start;
+  theBuffer->ValidBytes = 0;
+  return 0;
+}
+
+/*
+ * Flush the file buffer
+ */
+
+static int
+FlushWriteSocketStream(StreamBuffer theBuffer, void **Hook)
+{
+  int fd, BytesWritten;
+
+  fd = *((int *) Hook);
+
+  BytesWritten = write(fd, theBuffer->Start, theBuffer->ValidBytes);
+
+  if (BytesWritten < 0)
+    FatalError("FlushWriteSocketStream ");
+
+  assert(BytesWritten == theBuffer->ValidBytes);
+
+  return BytesWritten;
+}
+
+/*
+ * Destroy the WriteSocketStream 
+ */
+
+static int
+DestroyWriteSocketStream(StreamBuffer theBuffer, void **Hook)
+{
+  if (theBuffer->Start)
+    vmFree(theBuffer->Start);
+  return 0;
+}
+
+/*
+ * Deal with new data arriving on a socket.
+ */
+
+void ProcessNewSocketData(Socket theSocket) 
+{
+  int BytesRead;
+
+  BytesRead = FillReadSocketStream(BufferCache[theSocket], (void**)&theSocket);
+  BufferCache[theSocket]->ValidBytes += BytesRead;
+
+  ActivateFD(theSocket);
+}
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/sockstr.h ubc-latest-src/vm/src/sockstr.h
--- sourceforge-1.06alpha/vm/src/sockstr.h	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/sockstr.h	2017-12-11 17:59:03.491711421 +0100
@@ -0,0 +1,32 @@
+/****************************************************************************
+ File     : socketstreams.h 
+ Date     : 08-11-92
+ Author   : Mark Immel
+
+ Contents : Socket Streams package
+
+ Modifications
+ -------------
+
+*****************************************************************************/
+
+#ifndef _EMERALD_SOCKETSTREAMS_H
+#define _EMERALD_SOCKETSTREAMS_H
+
+/*
+  This module provides a stream implementation for sockets.
+
+  The Hook argument to CreateStream should be the address of a integer
+  containing the file descriptor associated with the socket to be used.
+
+  All sockets given to these routines should be marked non-blocking.
+*/
+
+#include "streams.h"
+#include "types.h"
+
+extern StreamConstructor ReadSocketStream;
+extern StreamConstructor WriteSocketStream;
+extern void              ProcessNewSocketData(Socket theSocket);
+
+#endif /* _EMERALD_SOCKESTREAMS_H */
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/strtol.c ubc-latest-src/vm/src/strtol.c
--- sourceforge-1.06alpha/vm/src/strtol.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/strtol.c	2017-12-11 17:59:03.491711421 +0100
@@ -0,0 +1,57 @@
+#if !defined(lint) && defined(SCCSIDS)
+static	char sccsid[] = "@(#)strtol.c 1.4 88/02/08 SMI"; /* from S5R2 2.1 */
+#endif
+
+/*LINTLIBRARY*/
+#include <ctype.h>
+#define DIGIT(x)	(isdigit(x) ? (x) - '0' : \
+			islower(x) ? (x) + 10 - 'a' : (x) + 10 - 'A')
+#define MBASE	('z' - 'a' + 1 + 10)
+
+long
+strtol(str, ptr, base)
+register char *str;
+char **ptr;
+register int base;
+{
+	register long val;
+	register int c;
+	int xx, neg = 0;
+
+	if (ptr != (char **)0)
+		*ptr = str; /* in case no number is formed */
+	if (base < 0 || base > MBASE)
+		return (0); /* base is invalid -- should be a fatal error */
+	if (!isalnum(c = *str)) {
+		while (isspace(c))
+			c = *++str;
+		switch (c) {
+		case '-':
+			neg++;
+		case '+': /* fall-through */
+			c = *++str;
+		}
+	}
+	if (base == 0)
+		if (c != '0')
+			base = 10;
+		else if (str[1] == 'x' || str[1] == 'X')
+			base = 16;
+		else
+			base = 8;
+	/*
+	 * for any base > 10, the digits incrementally following
+	 *	9 are assumed to be "abc...z" or "ABC...Z"
+	 */
+	if (!isalnum(c) || (xx = DIGIT(c)) >= base)
+		return (0); /* no number formed */
+	if (base == 16 && c == '0' && isxdigit(str[2]) &&
+	    (str[1] == 'x' || str[1] == 'X'))
+		c = *(str += 2); /* skip over leading "0x" or "0X" */
+	for (val = -DIGIT(c); isalnum(c = *++str) && (xx = DIGIT(c)) < base; )
+		/* accumulate neg avoids surprises near MAXLONG */
+		val = base * val - xx;
+	if (ptr != (char **)0)
+		*ptr = str;
+	return (neg ? val : -val);
+}
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/system.h ubc-latest-src/vm/src/system.h
--- sourceforge-1.06alpha/vm/src/system.h	2017-12-11 17:59:03.092714462 +0100
+++ ubc-latest-src/vm/src/system.h	2017-12-11 17:59:03.491711421 +0100
@@ -92,7 +70,9 @@
 #    define EINTR 999
 #    define ETIMEDOUT 999
 #  endif
-extern int errno;
+#  ifndef errno
+     extern int errno;
+#  endif
 #endif
 
 #if defined(E_NEEDS_NTOH)
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/threads.c ubc-latest-src/vm/src/threads.c
--- sourceforge-1.06alpha/vm/src/threads.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/threads.c	2017-12-11 17:59:03.491711421 +0100
@@ -0,0 +1,342 @@
+/* threads.c - threads abstractions (for MTHREADS)
+ */
+
+#pragma warning(disable: 4068)
+#pragma pointer_size long
+#include <stdio.h>
+#include <stdlib.h>
+#pragma pointer_size short
+#include "threads.h"
+#include "types.h"
+#include "trace.h"
+#include "read.h"
+#include "write.h"
+#include "assert.h"
+#include "misc.h"
+#include "vm_exp.h"
+
+extern int nMessagesSent, nMessagesReceived, nBytesSent, nBytesReceived;
+#ifdef WIN32
+extern semaphore theBigLock;
+#endif /* not WIN32 */
+
+#if defined(MALLOCPARANOID)
+#if 1
+static FILE *junk;
+#define PMEXTRA 0
+#define MAXBLOCKS 1024
+#define TRWINDOW 1
+static int trindex = 0;
+typedef struct {
+  char command;
+  short size;
+  void *buf1, *buf2;
+  unsigned NodeAddr;
+} trrec;
+trrec trbuf[TRWINDOW];
+#define lassert(b) if (!(b)) { printf("lassert failure at %s, %d\n", __FILE__, __LINE__); trdump(); fflush(stdout); abort(); }
+void trdump(void);
+
+static void trm(char c, int size, void *buf1, void *buf2)
+{
+  trbuf[trindex].command = c;
+  trbuf[trindex].size = size;
+  trbuf[trindex].buf1 = buf1;
+  trbuf[trindex].buf2 = buf2;
+  trbuf[trindex].NodeAddr = MTGetCurrentNodeAddr();
+  trindex = (trindex + 1) % TRWINDOW;
+  if (trindex == 0) trdump();
+#if 0
+  if (c == 'M') {
+    int i = (trindex - 2 + TRWINDOW) % TRWINDOW;
+    while (i != trindex) {
+      if (trbuf[i].command == 'R' && trbuf[i].buf2 == buf1) break;
+      if (trbuf[i].buf1 == buf1) {
+	lassert(trbuf[i].command == 'F');
+	break;
+      }
+      i = (i - 1 + TRWINDOW) % TRWINDOW;
+    }
+  }
+#endif
+}
+
+void trdump(void)
+{
+  int i, j;
+  for (i = 0; i < TRWINDOW; i++) {
+    j = (trindex + i) % TRWINDOW;
+    printf("%08x: [%4d] %c %d ", trbuf[j].NodeAddr, j, trbuf[j].command, trbuf[j].size);
+    if (trbuf[j].command == 'R')
+      printf(" %x", trbuf[j].buf2);
+    printf(" -> %x\n", trbuf[j].buf1);
+  }
+  fflush(stdout);
+}
+
+static unsigned *allblocks[MAXBLOCKS];
+
+static void setupOne(unsigned *t, int b)
+{
+  int i;
+  t[0] = 0xaaaabbbb;
+  t[1] = 0xbbbbcccc;
+  t[2] = b;
+  t[3] = (unsigned)t;
+  t[((b + 3)>>2) + 4] = 0xccccdddd;
+  t[((b + 3)>>2) + 5] = 0xddddeeee;
+  t[((b + 3)>>2) + 6] = 0xeeeeffff;
+  t[((b + 3)>>2) + 7] = 0xffffaaaa;
+  for (i = 0; i < PMEXTRA; i++) {
+    t[((b + 3)>>2) + 8 + i] = 0xffffaaaa + i;
+  }
+}
+
+static void checkOne(unsigned *t)
+{
+  int a, i;
+  lassert(t[0] == 0xaaaabbbb);
+  lassert(t[1] == 0xbbbbcccc);
+  a = t[2];
+  lassert(t[3] == (unsigned)t);
+  lassert(t[((a + 3)>>2) + 4] == 0xccccdddd);
+  lassert(t[((a + 3)>>2) + 5] == 0xddddeeee);
+  lassert(t[((a + 3)>>2) + 6] == 0xeeeeffff);
+  lassert(t[((a + 3)>>2) + 7] == 0xffffaaaa);
+  for (i = 0; i < PMEXTRA; i++) {
+    lassert(t[((a + 3)>>2) + 8 + i] == 0xffffaaaa + i);
+  }
+}
+
+void checkAll(void)
+{
+  int i;
+  return;
+  for (i = 0; i < MAXBLOCKS; i++) {
+    if (allblocks[i] != NULL) {
+      checkOne(allblocks[i]);
+    }
+  }
+}
+
+void rememberOne(unsigned *t)
+{
+  int i;
+  return;
+  for (i = 0; i < MAXBLOCKS; i++) {
+    if (allblocks[i] == 0) {
+      allblocks[i] = t;
+      return;
+    }
+  }
+  assert(0);
+}
+
+void forgetOne(unsigned *t)
+{
+  int i;
+  return;
+  for (i = 0; i < MAXBLOCKS; i++) {
+    if (allblocks[i] == t) {
+      allblocks[i] = NULL;
+      return;
+    }
+  }
+  assert(0);
+}
+  
+void *vmMalloc(a)
+{
+  unsigned *t = (unsigned *)malloc(((a + 3)&~3) + (8 + PMEXTRA) * sizeof(int));
+
+  /*  if (!junk) junk = fopen("junk", "w");*/
+  setupOne(t, a);
+  rememberOne(t);
+  trm('M', a, &t[4], 0);
+  /*  fprintf(junk, "M %d -> %#x\n", a, &t[4]); fflush(junk); */
+  checkAll();
+  return (void *)&t[4];
+}
+
+void *vmRealloc(void *old, int b)
+{
+  int a;
+  unsigned *t = (unsigned *)old - 4;
+  a = t[2];
+  checkOne(t);
+  forgetOne(t);
+  t = (unsigned *)realloc(t, ((b + 3)&~3) + (8 + PMEXTRA) * sizeof(int));
+  setupOne(t, b);
+  rememberOne(t);
+  trm('R', b, &t[4], old);
+  /*  fprintf(junk, "R %#x[%d] %d -> %#x\n", old, a, b, &t[4]); fflush(junk); */
+  checkAll();
+  return (void *)&t[4];
+}
+void *vmCalloc(int a, int b)
+{
+  void *t = vmMalloc(a * b);
+  memset(t, 0, a * b);
+  return t;
+}
+
+void vmFree(void *old)
+{
+  int a;
+  unsigned *t = (unsigned *)old - 4;
+  if (!old) return;
+  checkAll();
+  checkOne(t);
+  a = t[2];
+  forgetOne(t);
+  trm('F', a, old, 0);
+  /*  fprintf(junk, "F %#x[%d]\n", old, a); fflush(junk); */
+  free(t);
+}
+#else
+static int nmallocs, nfrees, nbigmallocs;
+void *vmMalloc(int a)
+{
+  if (a > 40000) {
+    nbigmallocs ++;
+  }
+  nmallocs++;
+  return malloc(a);
+}
+
+void *vmRealloc(void *old, int b)
+{
+  if (b > 40000) {
+    nbigmallocs++;
+  }
+  return realloc(old, b);
+}
+void *vmCalloc(int a, int b)
+{
+  if (a * b > 40000) {
+    nbigmallocs ++;
+  }
+  nmallocs++;
+  return malloc(a * b);
+}
+
+void vmFree(void *old)
+{
+  if (old) nfrees++;
+  free(old);
+}
+#endif
+#endif
+#ifdef MTHREADS
+
+#ifdef WIN32MALLOCDEBUG
+_CrtMemState onceinitialized;
+#endif
+
+int
+vmInitThreads()
+{
+  extern Node MyNode;
+  extern OID MyBaseOID;
+  int port;
+  char *plane;
+  extern char *getenv(const char *);
+
+#ifdef WIN32MALLOCDEBUG
+   // Send all reports to STDOUT
+
+#define  SET_CRT_DEBUG_FIELD(a) \
+	_CrtSetDbgFlag((a) | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG))
+
+#if 0
+   // Set the debug-heap flag so that freed blocks are kept on the
+   // linked list, to catch any inadvertent use of freed memory
+   // You only can do this if you are allocating a few blocks
+   SET_CRT_DEBUG_FIELD( _CRTDBG_DELAY_FREE_MEM_DF );
+#endif
+
+   _CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_FILE );
+   _CrtSetReportFile( _CRT_WARN, _CRTDBG_FILE_STDOUT );
+   _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_FILE );
+   _CrtSetReportFile( _CRT_ERROR, _CRTDBG_FILE_STDOUT );
+   _CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_FILE );
+   _CrtSetReportFile( _CRT_ASSERT, _CRTDBG_FILE_STDOUT );
+#endif
+
+  MyNode.Epoch = random() & 0xffff;
+  /* start up the network subsystem */
+  port = EMERALDFIRSTPORT + getplane();
+
+  while (MTNetStart(0,  port, MyNode.Epoch) != 0) {
+    port = EMERALDPORTPROBE(port);
+    if (port > 0x10000) return -1;
+  }
+  MyNode.IPAddress = myid.ipaddress;
+  MyNode.EmeraldInstance = myid.port;
+  MyNode.Epoch = myid.incarnation;
+  MyBaseOID.IPAddress = ntohl(MyNode.IPAddress);
+  MyBaseOID.EmeraldInstance = MyNode.EmeraldInstance;
+  MyBaseOID.Epoch = MyNode.Epoch;
+
+  return 0;
+}
+
+#ifndef WORKERSTACKSIZE
+#define WORKERSTACKSIZE (32 * 1024)
+#endif
+
+#ifdef WIN32MALLOCDEBUG
+void vmDoneInit()
+{
+    // Store a memory checkpoint in the memory-state structure
+	_CrtMemCheckpoint( &onceinitialized );
+}
+
+void vmMallocCheck()
+{
+  _CrtCheckMemory();
+}
+
+void vmMallocDump()
+{
+  _CrtMemState temp;
+  _CrtMemCheckpoint( &temp );  
+  _CrtMemDumpStatistics(&temp);
+
+  _CrtCheckMemory( );
+
+  /* This one dumps all objects. */
+  /* _CrtDumpMemoryLeaks( ); */
+
+  /*
+   * This will only dump the objects that have been allocated
+   * since the node finished initializing
+   */
+  _CrtMemDumpAllObjectsSince( &onceinitialized );
+
+}
+
+
+void vmMallocDumpAll()
+{
+  _CrtMemState temp;
+  _CrtMemCheckpoint( &temp );  
+  _CrtMemDumpStatistics(&temp);
+
+  _CrtCheckMemory( );
+
+  _CrtDumpMemoryLeaks( );
+}
+#endif
+
+char *NodeAddrString(NodeAddr srv)
+{
+  static char buf[5][60];
+  static int i = 0;
+  char *rval;
+
+  rval = buf[i]; i = (i+1) % 5;
+  sprintf(rval, "%08lx.%04x.%04x", srv.ipaddress, srv.port, srv.incarnation);
+  return rval;
+}
+#endif /* MTHREADS */
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/threads.h ubc-latest-src/vm/src/threads.h
--- sourceforge-1.06alpha/vm/src/threads.h	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/threads.h	2017-12-11 17:59:03.491711421 +0100
@@ -0,0 +1,79 @@
+/*
+ * threads.h
+ */
+
+#ifndef _EMERALD_THREADS_H
+#define _EMERALD_THREADS_H
+
+#ifndef _EMERALD_STORAGE_H
+#include "storage.h"
+#endif
+extern int useThreads;
+
+#define EMERALDFIRSTPORT 0x3ee3
+#define EMERALDPORTSKIP 0x400
+#define EMERALDPORTPROBE(n) ((n) + EMERALDPORTSKIP)
+#ifdef MTHREADS
+
+#include "mthreads.h"
+#ifdef WIN32
+#include <io.h>
+#endif /* not WIN32 */
+#define filesizeofNodeAddr (sizeof(unsigned int) + 2 * sizeof(unsigned short))
+int vmInitThreads(void);
+char *NodeAddrString(NodeAddr);
+extern NodeAddr myid;
+
+#define SameNodeAddrHost(a,b) ((a).ipaddress == (b).ipaddress && (a).port == (b).port)
+#define SameNodeAddr(a,b) ((a).ipaddress == (b).ipaddress && (a).port == (b).port && (a).incarnation == (b).incarnation)
+
+#define vmOpen(a,b,c) open(a,b,c)
+#ifdef WIN32
+#define reax(fd, buf, nbytes) _read(fd, buf, nbytes)
+extern size_t vmRead(int fd, void *buf, size_t nbytes);
+#define writx(fd, buf, nbytes) _write(fd, buf, nbytes)
+extern size_t vmWrite(int fd, void *buf, size_t nbytes);
+#define selecx(fd, r, w, x, t) select(fd, r, w, x, t)
+#else /* not WIN32 */
+
+#define vmRead(fd, buf, nbytes) read(fd, buf, nbytes)
+#define vmWrite(fd, buf, nbytes) write(fd, buf, nbytes)
+#ifndef FAKESELECT
+#define selecx(fd, r, w, x, t) select(fd, r, w, x, t)
+#endif
+#endif /* not WIN32 */
+#define vmClose(a) close(a)
+#define vmSocket(a,b,c) socket(a,b,c)
+#define vmAccept(a,b,c) accept(a,b,c)
+
+#else
+
+typedef int NodeAddr;
+#define filesizeofNodeAddr sizeof(unsigned)
+typedef int semaphore;
+#define vmInitThreads() (-1)
+#define vmCreateThread(b,c) (-1)
+#define vmThreadSleep(a) sleep(a)
+#define vmThreadMSleep(a, b) sleep(a)
+#define SameNodeAddrHost(a,b) (0)
+
+#define vmMain(a,b) main(a,b)
+#define vmOpen(a,b,c) open(a,b,c)
+#define vmRead(a,b,c) read(a,b,c)
+#define vmWrite(a,b,c) write(a,b,c)
+#define vmClose(a) close(a)
+#ifdef WIN32
+#define vmSocket(a,b,c) xxxxsocket(a,b,c)
+#else /* not WIN32 */
+#define vmSocket(a,b,c) socket(a,b,c)
+#endif /* not WIN32 */
+#define vmAccept(a,b,c) accept(a,b,c)
+
+#define WriteNodeAddr(a, b) abort()
+#define ReadNodeAddr(a, b) abort()
+#define NodeAddrString(x) "a thread"
+#endif /* MTHREADS */
+
+#endif /* _EMERALD_THREADS_H */
+
+/* EOF */
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/trace.c ubc-latest-src/vm/src/trace.c
--- sourceforge-1.06alpha/vm/src/trace.c	2017-12-11 17:59:03.092714462 +0100
+++ ubc-latest-src/vm/src/trace.c	2017-12-11 17:59:03.492711414 +0100
@@ -92,7 +70,9 @@
   tracelocate,
   tracedist,
   traceunavailable,
-  tracefailure = 1
+  tracefailure = 1,
+  tracex,
+  traceT
 ;
 
 typedef struct {
@@ -129,6 +109,8 @@
   { "dist", &tracedist },
   { "unavailable", &traceunavailable },
   { "failure", &tracefailure },
+  { "x", &tracex },
+  { "t", &traceT },
   { NULL, 0 },
 };
 
@@ -191,7 +173,6 @@
       value = 1;
     } else {
       value = mstrtol(equals+1, 0, 0);
-      if (value <= 0) value = 1;
       *equals = '\0';
     }
     setTrace(f, value);
@@ -234,37 +215,30 @@
   }
 }
 
-#define USEDIFFS
-#ifdef USEDIFFS
 static struct timeval original;
-#endif
+
 void TraceInit(void)
 {
-#ifdef USEDIFFS
   gettimeofday(&original, 0);
-#endif
   tracefile = stdout;
 }
 
 void traceTS(int level)
 {
-#ifdef USEDIFFS
   extern struct timeval TimeMinus(struct timeval, struct timeval);
-#endif
   struct timeval print, now;
 
   gettimeofday(&now, 0);
-#ifdef USEDIFFS
   print = TimeMinus(now, original);
-#else
-  print = now;
-#endif
+
+  if (traceT) {
   if (tracebufferpointer) {
     sprintf(tracebufferpointer, "%5d.%06d: ", (int)print.tv_sec%100000, (int)print.tv_usec);
     updatetracebufferpointer();
   } else {
     fprintf(tracefile, "%5d.%06d: ", (int)print.tv_sec%100000, (int)print.tv_usec);
   }
+  }
   while (--level > 0) {
     if (tracebufferpointer) {
       tracebufferpointer[0] = ' ';
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/trace.h ubc-latest-src/vm/src/trace.h
--- sourceforge-1.06alpha/vm/src/trace.h	2017-12-11 17:59:03.092714462 +0100
+++ ubc-latest-src/vm/src/trace.h	2017-12-11 17:59:03.492711414 +0100
@@ -88,7 +66,9 @@
   tracelocate,
   tracedist,
   traceunavailable,
-  tracefailure
+  tracefailure,
+  tracex,
+  traceT
 ;
 
 extern void TraceInit(void);
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/types.h ubc-latest-src/vm/src/types.h
--- sourceforge-1.06alpha/vm/src/types.h	2017-12-11 17:59:03.092714462 +0100
+++ ubc-latest-src/vm/src/types.h	2017-12-11 17:59:03.492711414 +0100
@@ -117,37 +95,13 @@
 #define SETISIMUT(f)      ((f) |= ISIMUTBIT)
 #define CLEARISIMUT(f)    ((f) &= ~ISIMUTBIT)
 
-#define CODEPTREXTRA 0
-#ifdef mips
-#undef CODEPTREXTRA
-#define CODEPTREXTRA 0x10000000
-#endif
-#ifdef alpha
-#undef CODEPTREXTRA
-#define CODEPTREXTRA 0x14000000
-#endif
-#ifdef hp700
-#undef CODEPTREXTRA
-#define CODEPTREXTRA 0x40000000
-#endif
-#ifdef ibm
-#undef CODEPTREXTRA
-#define CODEPTREXTRA 0x20000000
-#endif
-#if defined(i386) && defined(linux)
-#undef CODEPTREXTRA
-#define CODEPTREXTRA 0x40000000
-#endif
-#if defined(i386) && (!defined(linux) && defined(__svr4__))
-#undef CODEPTREXTRA
-#define CODEPTREXTRA 0x08000000
-#endif
+extern int codeptrextra;
 
 #define CODEPTRBITS (0xffffffff & ~ALLBITS)
-#define CODEPTR(f)       ((ConcreteType)((((unsigned int)f) & CODEPTRBITS) | CODEPTREXTRA))
+#define CODEPTR(f)       ((ConcreteType)((((unsigned int)f) & CODEPTRBITS) | codeptrextra))
 #define CODEPTRINDEX(f)  ((unsigned int)f & CODEPTRBITS)
 #define SETCODEPTR(f,cp)  \
-  ((f) = ((((unsigned int)f) & ~CODEPTRBITS)) | ((unsigned int)cp & ~CODEPTREXTRA))
+  ((f) = ((((unsigned int)f) & ~CODEPTRBITS)) | ((unsigned int)cp & ~codeptrextra))
 #define SETCODEPTRINDEX(f,cp)  \
   ((f) = (((unsigned int)f) & ~CODEPTRBITS) | (unsigned int)cp)
 
@@ -479,4 +433,3 @@
 ****************************************************************************/
 
 #endif /* _EMERALD_TYPES_H */
-#include "codeptrextra.h"
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/upcall.c ubc-latest-src/vm/src/upcall.c
--- sourceforge-1.06alpha/vm/src/upcall.c	2017-12-11 17:59:03.092714462 +0100
+++ ubc-latest-src/vm/src/upcall.c	2017-12-11 17:59:03.492711414 +0100
@@ -1,27 +1,6 @@
 /*
- * The Emerald Distributed Programming Language
- * 
- * Copyright (C) 2004 Emerald Authors & Contributors
- * 
- * This file is part of the Emerald Distributed Programming Language.
- *
- * The Emerald Distributed Programming Language is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- *  The Emerald Distributed Programming Language is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with the Emerald Distributed Programming Language; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- * 
+ * upcall.c - call from the runtime into Emerald
  */
-
-/* upcall.c - call from the runtime into Emerald
-*/
 #include "system.h"
 
 #include "vm_exp.h"
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/vm.c ubc-latest-src/vm/src/vm.c
--- sourceforge-1.06alpha/vm/src/vm.c	2017-12-11 17:59:03.092714462 +0100
+++ ubc-latest-src/vm/src/vm.c	2017-12-11 17:59:03.492711414 +0100
@@ -1,32 +1,10 @@
-/*
- * The Emerald Distributed Programming Language
- * 
- * Copyright (C) 2004 Emerald Authors & Contributors
- * 
- * This file is part of the Emerald Distributed Programming Language.
- *
- * The Emerald Distributed Programming Language is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- *  The Emerald Distributed Programming Language is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with the Emerald Distributed Programming Language; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- * 
- */
-
 #include "vm_i.h"
 #include <stdlib.h>
 #ifndef FILE
 #include <stdio.h>
 #endif
 void disassemble(unsigned int ptr, int len, FILE *f);
-int totalbytecodes;
+long long totalbytecodes;
 #ifdef PROFILEINTERPRET
 int bc_freq[NINSTRUCTIONS];
 #endif
@@ -40,13 +18,14 @@
 #define sb state->sb 		/* Stack base */
   Object op;		/* Object pointer */
   ConcreteType cp;		/* Concrete type */
+#define opp state->opp 		/* Operation pointer */
 #define ep state->ep 		/* Environment pointer */
 #define et state->et 		/* Environment type */
 #define nsoid state->nsoid 		/* Next SS OID */
 #define nstoid state->nstoid 		/* Next target OID */
 #define psoid state->psoid 		/* Prev SS OID */
 #define psnres state->psnres 		/* Results to return */
-  int addtototalbytecodes = 0;
+  long long addtototalbytecodes = 0;
   unsigned char opcode;
 #if defined(INTERPRETERLOCALS)
   INTERPRETERLOCALS
@@ -164,7 +143,13 @@
         break;
       case DUP: { u32 a;   POP(u32,a); PUSH(u32,a); PUSH(u32,a); }
         break;
-      case DUPV: { SYNCH(); obsolete("DUPV", state); }
+      case ENSURESPACE: {
+      int size;
+      POP(unsigned, size);
+      F_SYNCH();
+      ensureSpace(size + 32);
+      F_UNSYNCH();
+    }
         break;
       case SWAP: { SYNCH(); obsolete("SWAP", state); }
         break;
@@ -564,6 +549,7 @@
 		  POP(u32, fp);
 		  POP(Object, op);
 		  POP(ConcreteType, cp);
+		  opp = (OpVectorElement)JNIL;
 		  IFTRACE(call, 1) {
 		    doret(fp, sb, pc, xcp);
 		  }
@@ -865,8 +851,31 @@
 		  if (o == op) DEBUG("Breakme executed");
 		}
         break;
-      case FORWARD: {
-	       SYNCH(); obsolete("FORWARD", state);
+      case ACPTBLCK: {
+		AbstractType acceptable;
+		State *otherstate;
+		monitor *m = (monitor *)((Object) op)->d;
+
+		POP(AbstractType, acceptable);
+		otherstate = findAcceptable(m->waiting, acceptable);
+		if (!otherstate) {
+		  m->busy = 2;
+		  PUSH(AbstractType, acceptable);
+		  pc --;
+		  SYNCH();
+		  if (!m->waiting) m->waiting = SQueueCreate();
+		  SQueueInsertFront(m->waiting, state);
+		  TRACE(process, 3, ("Blocking synchronizing process %#x", state));
+		  return 1;
+		} else {
+		  m->busy = 3;
+		  SYNCH();
+		  assert(m->waiting);
+		  SQueueInsertFront(m->waiting, state);
+		  TRACE(process, 3, ("Synchronizing process accepted state %#x", otherstate));
+		  state = otherstate;
+		  UNSYNCH();
+		}
                }
         break;
       case BREAKPT: {
@@ -1175,10 +1184,9 @@
         break;
       case GCOLLECT: {
 		  {
-		    extern void startDistGC(void);
+		    SYNCH();
 		    gcollect();
-		    gcollect_old();
-		    startDistGC();
+		    UNSYNCH();
 		  }
 		}
         break;
@@ -1271,12 +1279,63 @@
 		  fixObjectReferenceFromSeq(id, (Object)xct, OffsetOf(xct, &xct->d.type));
 		}
         break;
-      case STUBCALL: {
-                   SYNCH(); obsolete("STUBCALL", state);
+      case SYNCHINIT: {
+		   monitor *m = (monitor *)((Object) op)->d;
+		   /*
+		    * Busy encodes two things:
+		    *	Low order bit:  open (== 0) or locked (== 1)
+		    *	Next bit:       process alive (== 2) or dead (== 0)
+		    *
+		    * The initial value is 3, locked and the process is alive
+		    * (or at least, hasn't died yet).
+		    */
+		   m->busy = 3;
+		   m->waiting = 0;
 		 }
         break;
-      case STUBRETURN: {
-                   SYNCH(); obsolete("STUBRETURN", state);
+      case SYNCHENTER: {
+		   monitor *m = (monitor *)((Object) op)->d;
+		   State *otherstate;
+		   if (prevOP(fp) == op) {
+		     TRACE(process, 3, ("SYNCHENTER on self invoke, passed"));
+		   } else {
+		     switch (m->busy) {
+		     case 0:
+		       /*
+			* Process dead, object unlocked.
+			*/
+		       m->busy = 1;
+		       break;
+		     case 1:
+		     case 3:
+		       /*
+			* Process dead or alive, object locked.
+			*/
+		       SYNCH();
+		       if (!m->waiting) m->waiting = SQueueCreate();
+		       SQueueInsert(m->waiting, state);
+		       TRACE(process, 3, ("Blocking process %x - synchronized object entry",
+					  state));
+		       return 1;
+		       break;
+		     case 2:
+		       /*
+			* Process alive, object unlocked.  The process will be
+			* at the head of the waiting queue, so block yourself and
+			* run it.  It will decide whether to allow entry.
+			*/
+		       assert(m->waiting);
+		       SYNCH();
+		       otherstate = SQueueRemove(m->waiting);
+		       SQueueInsert(m->waiting, state);
+		       state = otherstate;
+		       UNSYNCH();
+		       break;
+		     default:
+		       assert(0);
+		       break;
+		     }
+		   }
                  }
         break;
       case GETOID: {
@@ -1306,8 +1365,30 @@
 		    PUSH(ConcreteType, intct);
 		  }
         break;
-      case TESTREMOTE: {
-                  SYNCH(); obsolete("TESTREMOTE", state);
+      case SYNCHEXIT: {
+		   monitor *m = (monitor *)((Object) op)->d;
+		   State *otherstate;
+		   if (prevOP(fp) == op) {
+		     TRACE(process, 3, ("SYNCHEXIT of self invoke - passed"));
+		   } else {
+		     if ((otherstate = SQueueRemove(m->waiting)) != NULL) {
+		       /*
+			* Either the process is still alive or some other
+			* operation wants in, in either case, schedule it.
+			*/
+		       makeReady(otherstate);
+		       TRACE(process, 3, ("Unblocking process %x - synchronized object exit",
+					  otherstate));
+		     } else {
+		       /*
+			* There is no other process waiting, the process
+			* better be dead and we want to unlock the object.
+			*/
+		       assert(m->busy == 1);
+		       m->busy = 0;
+		       TRACE(process, 3, ("No waiters - synchronized object exit"));
+		     }
+		   }
 		}
         break;
       case GETIDSEQ: {
@@ -1324,8 +1405,26 @@
 		  PUSH(u32, oid.Seq);
 		}
         break;
-      case CCALL: {
-		  SYNCH(); obsolete("CCALL", state);
+      case SYNCHDIE: {
+		   monitor *m = (monitor *)((Object) op)->d;
+		   State *otherstate;
+		   assert(m->busy == 3);
+
+		   if ((otherstate = SQueueRemove(m->waiting)) != NULL) {
+		     /*
+		      * Some other operation wants in, schedule it.
+		      */
+		     makeReady(otherstate);
+		     TRACE(process, 3, ("Unblocking process %x - synchronizing process exit",
+					otherstate));
+		     m->busy = 1;
+		   } else {
+		     /*
+		      * There is no other process waiting, we want to unlock the object.
+		      */
+		     m->busy = 0;
+		     TRACE(process, 3, ("No waiters - synchronizing process exit"));
+		   }
 		}
         break;
       case LDLITB: { 
@@ -1366,8 +1465,11 @@
       sp -= 4 * n;
     }
         break;
-      case TESTREMOTE2: {
-      SYNCH(); obsolete("TESTREMOTE2", state);
+      case GCOLLECTOLD: {
+		     SYNCH();
+		     gcollect();
+		     gcollect_old();
+		     UNSYNCH();
     }
         break;
       case CODEOF: {
@@ -1765,6 +1867,7 @@
   }
 }
 #undef sb
+#undef opp
 #undef ep
 #undef et
 #undef nsoid
@@ -1819,7 +1922,7 @@
   { "STVOB", "s8", 41 } ,
   { "STVAB", "s8", 42 } ,
   { "DUP", "", 43 } ,
-  { "DUPV", "", 44 } ,
+  { "ENSURESPACE", "", 44 } ,
   { "SWAP", "", 45 } ,
   { "ADD", "", 46 } ,
   { "SUB", "", 47 } ,
@@ -1891,7 +1994,7 @@
   { "CREATEVECLIT", "", 113 } ,
   { "STRHASH", "", 114 } ,
   { "BREAKME", "", 115 } ,
-  { "FORWARD", "", 116 } ,
+  { "ACPTBLCK", "", 116 } ,
   { "BREAKPT", "", 117 } ,
   { "UPB", "", 118 } ,
   { "STRLIT", "", 119 } ,
@@ -1928,17 +2031,17 @@
   { "DLOAD", "", 150 } ,
   { "RELOCATEVECTOR", "", 151 } ,
   { "RELOCATETYPE", "", 152 } ,
-  { "STUBCALL", "", 153 } ,
-  { "STUBRETURN", "", 154 } ,
+  { "SYNCHINIT", "", 153 } ,
+  { "SYNCHENTER", "", 154 } ,
   { "GETOID", "", 155 } ,
-  { "TESTREMOTE", "", 156 } ,
+  { "SYNCHEXIT", "", 156 } ,
   { "GETIDSEQ", "", 157 } ,
-  { "CCALL", "u8", 158 } ,
+  { "SYNCHDIE", "", 158 } ,
   { "LDLITB", "u8", 159 } ,
   { "SWAPV", "", 160 } ,
   { "DOCTLITERALS", "", 161 } ,
   { "CVX", "u8", 162 } ,
-  { "TESTREMOTE2", "", 163 } ,
+  { "GCOLLECTOLD", "", 163 } ,
   { "CODEOF", "", 164 } ,
   { "BUILDABCON", "", 165 } ,
   { "CHECKARGABCONB", "u8", 166 } ,
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/vm.d ubc-latest-src/vm/src/vm.d
--- sourceforge-1.06alpha/vm/src/vm.d	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/vm.d	2017-12-11 17:59:03.492711414 +0100
@@ -0,0 +1,1964 @@
+{/* This file should probably be read in -*- c -*- mode. */
+/*
+ * Jekyll Virtual Machine description file, for use with VMC
+ */
+
+#define _EMERALD_VM_I_H
+#define E_NEEDS_MATH
+#define E_NEEDS_NTOH
+#define E_NEEDS_STRING
+#include "system.h"
+#ifndef max
+#define max(x,y) (((x)<(y))?(y):(x))
+#endif
+#ifndef min
+#define min(x,y) (((x)<(y))?(x):(y))
+#endif
+#define ARGOFF (-24)
+
+#include "trace.h"
+#include "assert.h"
+#include "rinvoke.h"
+#include "globals.h"
+#include "iisc.h"
+#include "misc.h"
+#include "jsys.h"
+#include "creation.h"
+#include "oidtoobj.h"
+#include "squeue.h"
+#include "concurr.h"
+#include "iset.h"
+#include "call.h"
+#include "gc.h"
+
+extern ISet allProcesses;
+extern SQueue ready;
+extern int runningProcesses;
+#if defined(SINGLESTEP)
+extern int instructionsToExecute, gotsigint;
+#if !defined(COUNTBYTECODES)
+#define COUNTBYTECODES
+#endif
+#endif
+
+extern int debug(struct State *state, char *m);
+extern int doNCCall(struct State *state);
+extern void stoCheck (Object intoObj, Object storedObj);
+extern void obsolete(char *name, struct State *state);
+extern void setBits(Vector v, int off, int len, u32 val);
+extern void ntohBits(Vector v, int off, int len);
+extern int invoke(Object obj, ConcreteType ct, int opindex, struct State *state);
+extern struct State *newStackChunk(struct State *);
+extern void doret(int fp, int sb, int pc, ConcreteType ct);
+extern void thaw(Object obj, Reason why);
+extern void freeze(Object obj, Reason why);
+extern void processMovedOut(struct State *state);
+extern void CheckpointToFile(Object o, ConcreteType ct, String file);
+extern void gcollect(void);
+extern void gcollect_old(void);
+extern void docall(int op, int sp, int fp, ConcreteType ct, Object oop, int sb);
+extern void docallct(OpVectorElement ove, int sp, int fp, ConcreteType ct, Object oop, int sb);
+extern int conforms(AbstractType a, AbstractType b);
+
+extern void createGaggle(OID g);
+extern void add_gmember(OID gid, OID newMember);
+extern void sendGaggleUpdate(OID moid, OID ooid, OID ctoid, int dead);
+extern void loadNGo(String s);
+extern void fixObjectReferenceFromSeq(unsigned seq, Object within, int offset);
+extern void fixCTLiterals(ConcreteType ct);
+extern void stringTok(String s, String brk, int *startp, int *endp);
+extern void disassemble(unsigned int ptr, int len, FILE *f);
+#ifdef hp700
+extern int random(void);
+extern int srandom(unsigned int);
+#endif
+extern int interpret(struct State *);
+
+/* 
+ * Compute the offset of a field within a structure.
+ */
+#define OffsetOf(within, addr) ((char *)(addr) - (char *)(within))
+
+/*
+ * macros for load/store operations
+ */
+#define PF(x,y) PUSH(u32,FETCH(u32,x,y))
+#define PS(x,y) POP(u32,v); STORE(u32,x,y,v)
+#define LD(x)   u32 t;   IFETCH4(t); PUSH(u32, x)
+#define EST(x,y) u32 t,v; IFETCH4(t); PS(x,y)
+/* although the immediates we fetch are 16-bits, push a 32 bit result */
+#define LDS(x)   s16 t;   IFETCH2(t); PUSH(u32, (u32)(x))
+#define STS(x,y) s16 t; u32 v; IFETCH2(t); PS(x,y)
+/* although the immediates we fetch are 8-bits, push a 32 bit result */
+#define LDB(x)   s8 t;   IFETCH1(t); PUSH(u32, (u32)(x))
+#define STB(x,y) s8 t; u32 v; IFETCH1(t); PS(x,y)
+/*
+ * macros for arithmetic and logic operations
+ */
+#define UNARY(type,c_op) type a; TOP(type, a); SETTOP(type, c_op a);
+#define UNARYZ(type,c_op) type a; TOP(type, a); SETTOP(type, a c_op 0);
+#define BINARY(type,c_op) \
+  type a, b; POP(type,a); TOP(type,b); SETTOP(type, b c_op a);
+/*
+ * Miscellany
+ */
+
+#define ASSTR(type,fmt) { type a; String s; \
+  POP(type, a); sprintf(buf,fmt,a); \
+  F_SYNCH(); s = CreateString(buf); F_UNSYNCH(); \
+  PUSH(String, s); }
+
+#if defined(TIMESLICE)
+#   define CONTEXTSWITCHINVOKES (random() % 200)
+#   define CONTEXTSWITCHBRANCHS (random() % 500)
+#   define CONTEXTSWITCH					\
+	TRACE(process, 3, ("Preempting process %x", state));	\
+	SYNCH();						\
+	makeReady(state);					\
+	return 1;
+
+#   define CHECKSWITCH(count, limit)				\
+       if (runningProcesses && (--count < 0)) {			\
+	count = limit;						\
+	CONTEXTSWITCH						\
+      }
+
+#   define TIMESLICELOCALS \
+      static int totalinvocs = 50; \
+      static int branches = 10;
+#else
+#   define CHECKSWITCH(a, b)
+#   define TIMESLICELOCALS 
+#endif /* TIMESLICE */
+
+#define BRANCHCHECKSWITCH CHECKSWITCH(branches, CONTEXTSWITCHBRANCHS)
+#define INVOKECHECKSWITCH CHECKSWITCH(totalinvocs, CONTEXTSWITCHINVOKES)
+
+#ifdef SINGLESTEP
+#   define DEBUG(m) { \
+	       SYNCH(); \
+	       if (debug(state, m)) { \
+		 return 1; \
+	       } else { \
+	         UNSYNCH(); \
+	       } \
+      }
+#else
+#   define DEBUG(m) { \
+	       SYNCH(); \
+	       if (debug(state, m)) { \
+		 return 1; \
+	       } else { \
+		 UNSYNCH(); \
+	       } \
+      }
+#endif
+
+#define CHECKNILV(v,m) CHECKNIL(Vector, v, m)
+#define CHECKNILS(s,m) CHECKNIL(String, s, m)
+#define CHECKNILO(o,m) CHECKNIL(Object, o, m)
+#define CHECKNILU(u,m) CHECKNIL(u32, u, m)
+
+#if defined(NEMCHECK)
+#   define BOUNDSCHECK(v, i)
+#   define CHECKNIL(t, v, m)
+#else
+#   define BOUNDSCHECK(v, i)					\
+      if (i < 0 || i >= (v)->d.items) {				\
+	sprintf(buf, "Subscript %d out of range [0:%d] on access to %.*s", \
+		i, (v)->d.items - 1,				\
+		CODEPTR(v->flags)->d.name->d.items,		\
+		(char *)CODEPTR(v->flags)->d.name->d.data);	\
+	DEBUG(buf);						\
+	continue;						\
+      }
+#   define CHECKNIL(t, v, m) if (ISNIL(v)) DEBUG(m);
+#endif
+
+#if defined(PROFILEINVOKES)
+#   define TOPOFTHEINTERPRETLOOPA if (doInvokeProfiling) ++*currentOPECount;
+#   define PROFILEBUMP(pc,ove,a) if (doInvokeProfiling) profileBump(pc,ove,a)
+#   define PROFILERET() profileRet()
+#else
+#   define TOPOFTHEINTERPRETLOOPA
+#   define PROFILEBUMP(pc,ove,a) 
+#   define PROFILERET()
+#endif
+
+#define TOPOFTHEINTERPRETLOOPB 
+#if defined(SINGLESTEP)
+#   define TOPOFTHEINTERPRETLOOPC \
+	if (instructionsToExecute > 0 && addtototalbytecodes >= instructionsToExecute) { DEBUG(gotsigint ? "Interrupt" : "Single step"); }
+#else
+#   define TOPOFTHEINTERPRETLOOPC
+#endif
+
+#define TOPOFTHEINTERPRETLOOP \
+  TOPOFTHEINTERPRETLOOPA \
+  TOPOFTHEINTERPRETLOOPB \
+  TOPOFTHEINTERPRETLOOPC
+
+#ifdef SINGLESTEP
+#   define INTERPRETERLOCALS \
+      u32 opoid; \
+      char buf[80]; \
+      TIMESLICELOCALS
+#else
+#   define INTERPRETERLOCALS \
+      u32 opoid; \
+      char buf[80]; \
+      TIMESLICELOCALS
+#endif /* SINGLESTEP */
+
+#define prevOP(xx) ((Object)((u32 *)xx)[-3])
+}
+
+
+@ Design decisions:
+@   When variables are pushed on the stack, they are pushed data then AbCon
+@   Object creations push a code pointer, and return an object pointer
+@   An activation record looks like:
+@
+@	return value 1	(variable)	8
+@	...
+@	return value n	(variable)	8
+@	argument     1	(variable)	8
+@	...
+@	argument     n	(variable)	8     <-- fp - ARGOFF 
+@       saved cp                        4
+@	saved op			4
+@	saved fp			4
+@	saved pc			4
+@	local 1		(whatever)	?     <--- new fp
+@	...
+@	local n		(whatever)	?
+@
+@
+
+State:
+@	implicit registers include:
+@	pc	"Program counter"	"u32"
+@	my explicit registers:
+	sp	"Stack pointer"		"u32"
+	fp	"Frame pointer"		"u32"
+	_sb     "Stack base"            "u32"
+	op	"Object pointer"	"Object"
+	cp	"Concrete type"		"ConcreteType"
+	_opp	"Operation pointer"	"OpVectorElement"
+	_ep	"Environment pointer"	"Object"
+	_et	"Environment type"	"ConcreteType"
+	_nsoid	"Next SS OID"		"OID"
+	_nstoid	"Next target OID"	"OID"
+	_psoid	"Prev SS OID"		"OID"
+	_psnres	"Results to return"	"u32"
+
+Interrupts:
+	IO	{ microcode ... }
+	INT	{ microcode ... }
+
+Instructions:
+@ Most load instructions use an implicit temporary t, which is the
+@ argument to the load instruction.
+    LDI "u32"	{ LD(t); }
+@ Load a relative address.
+    LDIR "u32"	{ LD(FETCH(u32,pc,t)); }
+@ Load a local variable.
+    LDL "u32"	{ LD(FETCH(u32,fp,t)); }
+    LDO "u32"	{ LD(FETCH(u32,op,t)); }
+@ Load an argument.
+    LDA "u32"	{ LD(FETCH(u32,fp,-(int)t+ARGOFF)); }
+@ general purpose escape to the system
+    NCCALL "u8u8"  {
+		  int res;
+		  SYNCH();
+		  res = doNCCall(state);
+		  if (res) return 1;
+		  UNSYNCH();
+		}
+    STL "u32"	{ EST(fp,t); }
+    STO "u32"	{ EST(op,t); stoCheck(op, (Object)v); }
+    STA "u32"	{ EST(fp,-(int)t+ARGOFF); }
+
+    LDVL "u32"	{ LD(FETCH(u32,fp,t)); PF(fp,t+4); }
+    LDVO "u32"	{ LD(FETCH(u32,op,t)); PF(op,t+4); }
+    LDVA "u32"	{ LD(FETCH(u32,fp,-(int)t+ARGOFF)); PF(fp,-(int)t+ARGOFF+4); }
+    STVL "u32"	{ EST(fp,t+4); PS(fp,t); }
+    STVO "u32"	{ EST(op,t+4); stoCheck(op, (Object)v); PS(op,t); stoCheck(op, (Object)v); }
+    STVA "u32"	{ EST(fp,-(int)t+ARGOFF+4); PS(fp,-(int)t+ARGOFF); }
+
+@ 16-bit versions of the loads and stores; branches are already 16-bit ops
+@ These use a 16-bit immediate offset but otherwise deal in 32-bit entities
+    LDIS "s16"	{ LDS(t); }
+    FPOW ""	{ f32 a, b; POP(f32,a); TOP(f32, b); SETTOP(f32, (float)pow((double)b, (double)a)); }
+    LDLS "s16"	{ LDS(FETCH(u32,fp,t)); }
+    LDOS "s16"	{ LDS(FETCH(u32,op,t)); }
+    LDAS "s16"	{ LDS(FETCH(u32,fp,-t+ARGOFF)); }
+
+    STLS "s16"	{ STS(fp,t); }
+    STOS "s16"	{ STS(op,t); stoCheck(op, (Object)v); }
+    STAS "s16"	{ STS(fp,-t+ARGOFF); }
+
+    LDVLS "s16"	{ LDS(FETCH(u32,fp,t)); PF(fp,t+4); }
+    LDVOS "s16"	{ LDS(FETCH(u32,op,t)); PF(op,t+4); }
+    LDVAS "s16"	{ LDS(FETCH(u32,fp,-t+ARGOFF)); PF(fp,-t+ARGOFF+4); }
+    STVLS "s16"	{ STS(fp,t+4); PS(fp,t); }
+    STVOS "s16"	{ STS(op,t+4); stoCheck(op, (Object)v); PS(op,t); stoCheck(op, (Object)v); }
+    STVAS "s16"	{ STS(fp,-t+ARGOFF+4); PS(fp,-t+ARGOFF); }
+
+@ 8-bit versions of the loads and stores; branches are already 8-bit ops
+@ These use a 8-bit immediate offset but otherwise deal in 32-bit entities
+    LDIB "s8"	{ LDB(t); }
+    ISTRX ""    { ASSTR(s32,"%08x"); }
+    LDLB "s8"	{ LDB(FETCH(u32,fp,t)); }
+    LDOB "s8"	{ LDB(FETCH(u32,op,t)); }
+    LDAB "s8"	{ LDB(FETCH(u32,fp,-t+ARGOFF)); }
+
+    STLB "s8"	{ STB(fp,t); }
+    STOB "s8"	{ STB(op,t); stoCheck(op, (Object)v); }
+    STAB "s8"	{ STB(fp,-t+ARGOFF); }
+
+    LDVLB "s8"	{ LDB(FETCH(u32,fp,t)); PF(fp,t+4); }
+    LDVOB "s8"	{ LDB(FETCH(u32,op,t));
+		  PF(op,t+4); }
+    LDVAB "s8"	{ LDB(FETCH(u32,fp,-t+ARGOFF)); PF(fp,-t+ARGOFF+4); }
+    STVLB "s8"	{ STB(fp,t+4); PS(fp,t); }
+    STVOB "s8"	{ STB(op,t+4); stoCheck(op, (Object)v); PS(op,t); stoCheck(op, (Object)v); }
+    STVAB "s8"	{ STB(fp,-t+ARGOFF+4); PS(fp,-t+ARGOFF); }
+
+@ Miscellaneous stack machine operations
+    DUP   ""    { u32 a;   POP(u32,a); PUSH(u32,a); PUSH(u32,a); }
+    ENSURESPACE  ""    {
+      int size;
+      POP(unsigned, size);
+      F_SYNCH();
+      ensureSpace(size + 32);
+      F_UNSYNCH();
+    }
+    SWAP  ""    { SYNCH(); obsolete("SWAP", state); }
+
+@ Arithmetic operations find operands on the stack, and push the result
+@ Floating point versions are preceded by F
+@ String versions are preceded by S
+    ADD ""	{ BINARY(s32,+) }
+    SUB ""	{ BINARY(s32,-) }
+    MUL ""	{ BINARY(s32,*) }
+    DIV ""	{ BINARY(s32,/) }
+    MOD ""	{ BINARY(s32,%) }
+    NEG ""      {  UNARY(s32,-) }
+    FADD ""	{ BINARY(f32,+) }
+    FSUB ""	{ BINARY(f32,-) }
+    FMUL ""	{ BINARY(f32,*) }
+    FDIV ""	{ BINARY(f32,/) }
+    FNEG ""     {  UNARY(f32,-) }
+@ Comparison operations
+    EQ  ""      { UNARYZ(s32,==) }
+    NE  ""      { UNARYZ(s32,!=) }
+    GT  ""      { UNARYZ(s32,> ) }
+    GE  ""      { UNARYZ(s32,>=) }
+    LT  ""      { UNARYZ(s32,< ) }
+    LE  ""      { UNARYZ(s32,<=) }
+@   ICMP is now called SUB!
+    FCMP ""     {
+                  f32 a, b;
+		  POP(f32,b); POP(f32,a);
+		  a = a-b;
+		  PUSH(s32,((a>0)?1:((a<0)?(-1):0)));
+		}
+    SCMP ""     {
+                  String a, b;
+		  int i;
+		  POP(String,b);
+		  POP(String,a);
+		  CHECKNILS(b, "SCMP on a string which is nil");
+		  CHECKNILS(a, "SCMP on a string which is nil");
+		  i = memcmp((char *)a->d.data, (char *)b->d.data,min(a->d.items,b->d.items));
+		  if (!i) i = a->d.items - b->d.items;
+		  PUSH(s32,i);
+                }
+@ Logical operations
+    AND ""      { BINARY(s32,&&) }
+    OR  ""      { BINARY(s32,||) }
+    NOT ""      {  UNARY(s32, !) }
+    ASSERT ""   { s32 a; POP(s32,a);
+                  if(!a) DEBUG("Assertion failed");
+                }
+@ Conversions
+    CSTR ""     { s32 a;
+                  String s;
+
+                  POP(s32,a);
+		  F_SYNCH();
+		  s = (String)CreateVector(BuiltinInstCT(STRINGI),1);
+		  F_UNSYNCH();
+                  s->d.items = 1;
+		  s->d.data[0] = (char)a;
+		  PUSH(String,s);
+                }
+    FINT ""     { f32 a; POP(f32,a); PUSH(s32,(s32)a); }
+    IFLO ""     { s32 a; POP(s32,a); PUSH(f32,(f32)a); }
+    ISTR ""     { ASSTR(s32,"%d"); }
+    FSTR ""     { ASSTR(f32,"%g"); }
+    EBSTR ""     { s32 a;
+		  POP(s32,a);
+		  PUSH(String, (a?TrueString:FalseString));
+                }
+@ Bitchunk operations
+@
+@ At the moment, these are only defined for lengths <= 32.
+     BGETS ""      {
+                     u32 off, len;
+		     s32 temp;
+		     Vector v;
+
+                     POP(u32,len);
+                     POP(u32,off);
+                     POP(Vector,v);
+		     CHECKNILV(v, "BGETS on nil");
+		     temp = ((int *)v->d.data)[off >> 5];
+		     temp = temp << (off & 31);
+		     temp = temp >> (32 - len);
+		     PUSH(u32,temp);
+                   }
+     BGETU ""      {
+                     u32 off, len;
+		     u32 temp;
+		     Vector v;
+
+                     POP(u32,len);
+                     POP(u32,off);
+                     POP(Vector,v);
+		     CHECKNILV(v, "BGETU on nil");
+		     temp = ((int *)v->d.data)[off >> 5];
+		     temp = temp << (off & 31);
+		     temp = temp >> (32 - len);
+		     PUSH(u32,temp);
+                   }
+     BSET  ""      {
+                     u32 off, len;
+		     u32 setval;
+		     Vector v;
+
+		     POP(u32, setval);
+                     POP(u32,len);
+                     POP(u32,off);
+                     POP(Vector,v);
+		     CHECKNILV(v, "BSET on nil");
+		     setBits(v, off, len, setval);
+                   }
+     NTOH  ""      {
+                     u32 off, len;
+		     Vector v;
+
+                     POP(u32,len);
+                     POP(u32,off);
+                     POP(Vector,v);
+		     CHECKNILV(v, "NTOH on nil");
+		     ntohBits(v, off, len);
+                   }
+@ Vector operations
+     GETB   ""     {
+                     Vector v;
+                     s32 i;
+
+                     POP(s32,i);
+                     POP(Vector,v);
+		     CHECKNILV(v, "GETB on a vector which is nil");
+		     BOUNDSCHECK(v, i);
+		     PUSH(s32,(s32)(v->d.data[i]));
+                   }
+     GET    ""     {
+                     Vector o1;
+		     s32 i, v;
+		     ConcreteType ct;
+
+		     POP(s32,i);
+		     POP(Vector,o1);
+		     CHECKNILV(o1, "GET on a vector which is nil");
+		     ct = CODEPTR(o1->flags);
+		     BOUNDSCHECK(o1, i);
+		     if (ct->d.instanceSize == -1 || ct->d.instanceSize == 1) {
+		       v = o1->d.data[i];
+		     } else {
+		       v = *(((s32 *)(o1->d.data)) + i);
+		     }
+		     PUSH(s32, v);
+                   }
+     GETV   ""     {
+                     Vector o1;
+		     s32 i, *p;
+		     POP(s32,i);
+		     POP(Vector,o1);
+
+		     CHECKNILV(o1, "GETV on a vector which is nil");
+		     BOUNDSCHECK(o1, i);
+                     p = (((s32 *)(o1->d.data)) + (i<<1));
+		     PUSH(s32,*p++);
+		     PUSH(s32,*p);
+                   }
+     SET    ""     {
+                     Vector o1;
+		     s32 i, o;
+		     ConcreteType ct, valct;
+		     POP(s32,o);
+		     POP(s32,i);
+		     POP(Vector,o1);
+		     CHECKNILV(o1, "SET on a vector which is nil");
+		     ct = CODEPTR(o1->flags);
+		     BOUNDSCHECK(o1, i);
+		     stoCheck((Object)o1, (Object)o);
+		     if (ct->d.instanceSize == -1 || ct->d.instanceSize == 1) {
+		       o1->d.data[i] = o;
+		     } else if (ct->d.instanceSize == -4 || ct->d.instanceSize == 4) {
+		       *(s32 *)(&(o1->d.data[i<<2])) = o;
+		     } else {
+		       assert(ct->d.instanceSize == -8 || ct->d.instanceSize == 8);
+		       /* We have to be in the SET in IVec.Literal */
+		       if (ISNIL(o)) {
+			 valct = (ConcreteType)JNIL;
+		       } else {
+			 valct = CODEPTR(((Object)o)->flags);
+		       }
+		       stoCheck((Object)o1, (Object)valct);
+		       ((u32 *)o1->d.data)[i * 2] = o;
+		       ((ConcreteType *)o1->d.data)[i * 2 + 1] = valct;
+		     }
+                   }
+     SETV    ""    {
+                     Vector o1;
+		     u32 ct, o;
+		     s32 i;
+		     POP(u32, ct);
+		     POP(u32, o);
+		     POP(s32, i);
+		     POP(Vector, o1);
+		     CHECKNILV(o1, "SETV on a vector which is nil");
+		     BOUNDSCHECK(o1, i);
+		     stoCheck((Object)o1, (Object)o);
+		     stoCheck((Object)o1, (Object)ct);
+		     ((u32 *)o1->d.data)[i * 2] = o;
+		     ((u32 *)o1->d.data)[i * 2 + 1] = ct;
+                   }
+
+@ As defined here, slice ops are object : startindex : numbertoslice
+     GSLICE ""     {
+                     Vector o1, o2;
+		     s32 index, number;
+		     ConcreteType t1;
+                     POP(s32, number);
+                     POP(s32, index);
+		     POP(Vector,o1);
+		     CHECKNILV(o1, "GSLICE on a vector which is nil");
+		     if (number > 0) {
+		       BOUNDSCHECK(o1, index);
+		       BOUNDSCHECK(o1, index + number - 1);
+		     }
+		     t1 = CODEPTR(o1->flags);
+		     regRoot(o1);
+		     regRoot(t1);
+		     F_SYNCH();
+		     o2 = CreateVector(t1, number);
+		     F_UNSYNCH();
+		     unregRoot();
+		     unregRoot();
+#define abs(x) (((x)<0)?-(x):(x))
+		     index *= abs(t1->d.instanceSize);
+		     number *= abs(t1->d.instanceSize);
+#undef abs
+		     memmove(o2->d.data, &(o1->d.data[index]), number);
+		     PUSH(Vector,o2);
+                   }
+     SETLOCSRV ""   {
+		      Object newlocsrv;
+		      POP(Object, newlocsrv);
+		      if (ISNIL(locsrv)) {
+			locsrv = newlocsrv;
+		      }
+                    }
+     CAT    ""     {
+                     Vector o1, o2, o3;
+		     int size;
+		     ConcreteType t1; /* assumed identical for o1, o2 */
+		     POP(Vector,o2);
+		     POP(Vector,o1);
+		     CHECKNILV(o1, "CAT on a vector which is nil");
+		     CHECKNILV(o2, "CAT with an argument vector which is nil");
+		     CHECKNILV(o1->flags, "CAT with an argument vector which is scrambled");
+		     CHECKNILV(o2->flags, "CAT with an argument vector which is scrambled");
+		     t1 = CODEPTR(o1->flags);
+		     if (HASINITIALLY(t1)) DEBUG("Cat on a funny CT");
+		     regRoot(o1);
+		     regRoot(o2);
+		     regRoot(t1);
+		     F_SYNCH();
+		     o3 = (Vector)CreateVector(t1, o1->d.items + o2->d.items);
+		     F_UNSYNCH();
+		     unregRoot();
+		     unregRoot();
+		     unregRoot();
+#define abs(x) (((x)<0)?-(x):(x))
+		     size = abs(t1->d.instanceSize);
+#undef abs
+		     memmove(o3->d.data, o1->d.data, o1->d.items * size);
+		     memmove(o3->d.data+(o1->d.items * size), o2->d.data,
+			   o2->d.items * size);
+		     PUSH(Vector,o3);
+                   }
+     LEN   ""     {
+                    Vector o1;
+		    POP(Vector,o1);
+		    CHECKNILV(o1,"LEN on a vector which is nil");
+		    PUSH(s32,o1->d.items);
+                  }
+
+@ Call finds the target object on the stack, and the operation number as an
+@ immediate operand.  Call is only used under USEABCONS
+    SETDEBUGGER ""  {
+		      Object newdebugger;
+		      POP(Object, newdebugger);
+		      if (ISNIL(debugger)) {
+			debugger = newdebugger;
+		      }
+                    }
+@ Calloid finds the target object on the stack, and the operation oid as an
+@ immediate operand (4 bytes)
+    CALLOID "u32" {
+      int opindex;
+      ConcreteType a;
+      Object o;
+      IFETCH4(opoid);
+restofcalloid: ;
+
+      POP(ConcreteType, a);
+      POP(Object, o);
+
+      if (ISNIL(a)) { 
+	(opindex) = 0; 
+      } else { 
+	OpVector ov = (a)->d.opVector;
+	OpVectorElement ope;
+	int i;
+	(opindex) = 0;
+	for (i = 3; i < ov->d.items; i++) {
+	  ope = ov->d.data[i];
+	  if (ope->d.id == (opoid)) {
+	    (opindex) = i; 
+	    break;
+	  }
+	}
+	if ((opindex) == 0){
+	  TRACE(interpret, 0, ("FindCode: op %s id %d undefined for ct %.*s (0x%08x)",
+		  OperationName(opoid),(opoid),
+		  (a)->d.name->d.items,
+		  (a)->d.name->d.data,
+		  (u32)(a)));
+	  DEBUG("");
+	}
+      }
+      SYNCH();
+      if (invoke(o, a, opindex, state)) {
+	return 1;
+      } else {
+	UNSYNCH();
+	INVOKECHECKSWITCH;
+      }
+    }
+    LINK "u16"	{
+		  /* allocate space for locals */
+		  u16 space;
+		  IFETCH2(space);
+		  space /= 4;
+		  if (sp + space * 4 + 200 > sb + stackSize) {
+		    SYNCH();
+		    state = newStackChunk(state);
+		    UNSYNCH();
+		  }
+		  for (; space; space--) {
+		    *(int *)sp = JNIL;
+		    sp += 4;
+		  }
+    		}
+    LINKB "u8"	{
+		  /* allocate space for locals, in words! */
+		  u32 space;
+		  IFETCH1(space);
+		  if (sp + space * 4 + 200 > sb + stackSize) {
+		    SYNCH();
+		    state = newStackChunk(state);
+		    UNSYNCH();
+		  }
+		  for (; space; space--) {
+		    *(int *)sp = JNIL;
+		    sp += 4;
+		  }
+    		}
+    RET "u8"	{
+		  u8 nargs;
+		  ConcreteType xcp;
+
+		  IFETCH1(nargs);
+		  PROFILERET();
+
+		  xcp = cp;
+		  sp = fp;
+		  POP(u32, pc);
+		  POP(u32, fp);
+		  POP(Object, op);
+		  POP(ConcreteType, cp);
+		  opp = (OpVectorElement)JNIL;
+		  IFTRACE(call, 1) {
+		    doret(fp, sb, pc, xcp);
+		  }
+		  sp -= (nargs * 2 * sizeof(u32));
+#ifdef DISTRIBUTED
+		  if (BROKEN(op->flags)) {
+		    SYNCH();
+		    if (!RESDNT(op->flags)) {
+		      /* It left */
+		      returnToForeignObject(state, JNIL);
+		      return 1;
+		    } else if (isBroken(op) && returnToBrokenObject(state)) {
+		      return 1;
+		    } else {
+		      UNSYNCH();
+		    }
+		  }
+#endif
+		}
+    QUIT "u8"	{ 
+                  u8 nargs;
+		  Object xop;
+		  ConcreteType xcp;
+		  IFETCH1(nargs);
+
+		  PROFILERET();
+		  thaw(op, RInitially);
+
+		  xcp = cp; xop = op; sp = fp;
+		  POP(u32, pc);
+		  POP(u32, fp);
+		  POP(Object, op);
+		  POP(ConcreteType, cp);
+		  IFTRACE(call, 1) {
+		    doret(fp, sb, -1, xcp);
+		  }
+		  sp -= (nargs * 2 * sizeof(u32));
+
+		  TRACE( initiallies, 1,
+			( "QUIT at sb=%#x, sp=%#x in object %#x (%.*s)",
+			 sb, sp, xop, xcp->d.name->d.items, xcp->d.name->d.data ) );
+
+		  if (HASPROCESS(xcp)) {
+		    TRACE(process, 1,
+			  ("QUIT forking process in object %#x (%.*s)",
+			   xop, xcp->d.name->d.items, xcp->d.name->d.data ) );
+		    run(xop, OVE_PROCESS, 1);
+		  } 
+		}
+    GETLOCSRV "" { 
+  		  Object o;
+		  o = locsrv;
+		  PUSH(Object, o);
+		  if (ISNIL(o)) {
+		    PUSH(ConcreteType, (ConcreteType)JNIL);
+		  } else {
+		    PUSH(ConcreteType, CODEPTR(o->flags));
+		  }
+		 }
+    CREATE ""	{
+                  ConcreteType p;
+		  Object o;
+		  OpVectorElement ove;
+
+		  POP(ConcreteType, p);
+		  F_SYNCH();
+		  regRoot(p);
+                  o = (Object) gc_malloc(sizeofObject + p->d.instanceSize);
+		  unregRoot();
+                  SETRESDNT(o->flags);
+                  SETCODEPTR(o->flags, p);
+		  if (inDistGC()) SETDISTGC(o->flags);
+
+		  ove = p->d.opVector->d.data[OVE_INITIALLY];
+		  if (ISNIL(ove)) {
+		    STORE(Object, sp, -4, o);
+		    if (HASPROCESS(p)) {
+		      TRACE( process, 1,
+			    ( "CREATE invoking process in object %#x (%.*s)",
+			     o, p->d.name->d.items, p->d.name->d.data ) );
+		      run(o, OVE_PROCESS, 1);
+		    }
+		  } else {
+		    STORE(Object, sp, -(4 + ove->d.nargs * 8), o);
+		    freeze(o, RInitially);
+		    TRACE( initiallies, 1,
+			  ( "CREATE invoking initially in object %#x (%.*s)",
+			   o, p->d.name->d.items, p->d.name->d.data ) );
+		    IFTRACE(call, 1) { docall(-1, sp, fp, p, o, sb); }
+		    pushAR(state, o, p, OVE_INITIALLY);
+		  }
+		  F_UNSYNCH();
+	        }
+    CREATEVEC ""  {
+                  ConcreteType p;
+		  Vector o;
+		  unsigned n;
+                  int is;
+
+		  POP(unsigned, n);
+		  POP(ConcreteType, p);
+                  is = (p->d.instanceSize < 0 ?
+                	-p->d.instanceSize : p->d.instanceSize);
+		  regRoot(p);
+		  F_SYNCH();
+                  o = (Vector) gc_malloc(sizeofObject + n * is + sizeof(int));
+		  F_UNSYNCH();
+		  unregRoot();
+                  SETRESDNT(o->flags);
+                  SETCODEPTR(o->flags, p);
+		  if (inDistGC()) SETDISTGC(o->flags);
+                  if (HASINITIALLY(p)) DEBUG("Create vec on a funny CT");
+                  o->d.items = n;
+		  SETTOP(Vector, o);
+		}
+@ Terminate a process
+    QUITP ""    { 
+      extern State *processDone(State *, int);
+      if (TRACING(call, 1)) doret(fp, sb, -2, cp);
+      SYNCH(); 
+      TRACE( process, 2,
+	    ( "End of process in object %#x (%.*s)", state->op,
+	     state->cp->d.name->d.items, state->cp->d.name->d.data ) );
+      if ((state = processDone(state, 0))) {
+	makeReady(state);
+      }
+      return 0;
+    }		   
+@ branching instructions
+    BR "s16"	{ s16 o; IFETCH2(o); pc += o; if (o < 0) BRANCHCHECKSWITCH;}
+    BRT "s16"	{ s16 o; u32 t; IFETCH2(o); POP(u32, t);
+		  if (t) pc += o; }
+    BRF "s16"	{ s16 o; u32 f; IFETCH2(o); POP(u32, f);
+		  if (!f) pc += o; }
+    CASE "case32"	{ s16 low, high, off; s32 v;
+    		  IFETCH2(low); 
+		  IFETCH2(high);
+		  POP(s32, v);
+		  v -= low; high -= low;
+		  if (v < 0 || v > high) v = high + 1;
+		  pc += v * 2;
+		  IFETCH2(off);
+		  pc += off;
+		  BRANCHCHECKSWITCH;
+		}
+    TRAPF ""	{ u32 t; POP(u32, t); if (!t) DEBUG("Assertion failure"); }
+    RETFAIL "u8"{ DEBUG("Return and fail"); }
+    LDSELF ""	{ PUSH(Object, op); }
+    LDSELFV ""	{ 
+		  PUSH(Object, op);
+#ifdef USEABCONS
+		  if (ISNIL(cp->d.type)) {
+		    PUSH(AbCon, findConCon(cp));
+		  } else {
+		    PUSH(AbCon, findAbCon(OIDOf(cp->d.type), OIDOf(cp)));
+		  }
+#else
+		  PUSH(ConcreteType, cp); 
+#endif
+		}
+    PUSHNIL ""  { PUSH(u32, 0x80000000); }
+    PUSHNILV ""  { PUSH(u32, 0x80000000); PUSH(u32, 0x80000000); }
+@ Throw away top of stack.
+    POOP      "" { u32 t; POP(u32, t); }
+@ general purpose escape to the system
+    SYS "u8u8"   {
+                  s32 rv, sysindex, ac;
+                  /* Fetch the operation and number of args from the
+		     instruction stream. */
+		  IFETCH1(sysindex);
+		  IFETCH1(ac);
+		  if (sysindex < 0 || sysindex >= JSYS_OPS) {
+		    sprintf(buf, "Illegal sys index %d (ac = %d)", 
+			    sysindex, ac);
+		    DEBUG(buf);
+		    continue;
+		  }
+		  /* Change the stack so the arguments are above the
+		     stack pointer. */
+		  sp -= (ac<<2);
+		  SYNCH();
+		  /* Call the actual code for the operation. */
+  		  rv = sysfuncs[sysindex](state);
+		  switch (rv) {
+		  case 0:
+		    UNSYNCH();
+		    break;
+		  case 1:
+		    return 1;
+		    break;
+		  case 0x1000:
+		    sprintf( buf, "exception in JSYS %d", sysindex );
+		    DEBUG( buf );
+		    break;
+		  default:
+		    assert(0);
+		    break;
+		  }
+		}
+@ Environment manipulation
+    GETENV ""	{
+		  PUSH(Object, ep);
+		  PUSH(ConcreteType, et);
+		}
+    SETENV ""	{
+		  POP(ConcreteType, et);
+		  POP(Object, ep);
+		}
+    STRI ""	{
+		  String s;
+		  s32 x;
+		  POP(String, s);
+		  CHECKNILS(s, "Nil in STRI");
+		  memmove(buf, s->d.data, s->d.items);
+		  buf[s->d.items] = '\0';
+		  x = mstrtol(buf, 0, 0);
+		  PUSH(s32, x);
+    		}
+    CREATEVECLIT "" {
+                      ConcreteType p;
+		      Vector o;
+		      unsigned n, e, est;
+		      int i;
+
+		      POP(unsigned, n);
+		      POP(ConcreteType, p);
+		      regRoot(p);
+		      F_SYNCH();
+		      o = CreateVector(p,n);
+		      F_UNSYNCH();
+		      unregRoot();
+		      for (i = n-1; i >= 0; i--) {
+			switch (p->d.instanceSize) {
+			case 1:
+			case -1:
+			  POP(u32, e);
+			  o->d.data[i] = e;
+			  break;
+			case -4:
+			case 4:
+			  POP(u32, e);
+			  *(s32 *)(&(o->d.data[i<<2])) = e;
+			  break;
+			case -8:
+			case 8:
+			  POP(u32, est);
+			  POP(u32, e);
+			  *(s32 *)(&(o->d.data[i<<3])) = e;
+			  *(s32 *)(&(o->d.data[(i<<3) + 4])) = est;
+			  break;
+			default:
+			  DEBUG("Bogus size of vector elements");
+			  goto nextInstruction;
+			  break;
+			}
+		      }
+		      PUSH(Vector, o);
+nextInstruction: ;
+		    }
+    STRHASH ""	{
+		  String s;
+		  u32 h = 0, g, i, l;
+		  POP(String, s);
+		  CHECKNILS(s, "Nil in STRHASH");
+		  l = s->d.items;
+		  for (i = 0; i < l; i++) {
+		    h = (h << 4) + s->d.data[i];
+		    if ((g = h & 0xf0000000)) {
+		      h = h ^ (g >> 24);
+		      h = h ^ g;
+		    }
+		  }
+		  h = h & 0x7fffffff;
+		  PUSH(u32, h);
+    		}
+@
+@ "Boring stuff" above this point.  "Research" starts here.
+@
+    BREAKME ""  {
+		  Object o;
+		  extern void breakObject(Object o);
+		  POP(Object, o);
+		  breakObject(o);
+		  if (o == op) DEBUG("Breakme executed");
+		}
+@ Acptblck is blocking selective method acceptance
+
+  ACPTBLCK "" {
+		AbstractType acceptable;
+		State *otherstate;
+		monitor *m = (monitor *)((Object) op)->d;
+
+		POP(AbstractType, acceptable);
+		otherstate = findAcceptable(m->waiting, acceptable);
+		if (!otherstate) {
+		  m->busy = 2;
+		  PUSH(AbstractType, acceptable);
+		  pc --;
+		  SYNCH();
+		  if (!m->waiting) m->waiting = SQueueCreate();
+		  SQueueInsertFront(m->waiting, state);
+		  TRACE(process, 3, ("Blocking synchronizing process %#x", state));
+		  return 1;
+		} else {
+		  m->busy = 3;
+		  SYNCH();
+		  assert(m->waiting);
+		  SQueueInsertFront(m->waiting, state);
+		  TRACE(process, 3, ("Synchronizing process accepted state %#x", otherstate));
+		  state = otherstate;
+		  UNSYNCH();
+		}
+	      }
+ 
+    BREAKPT "" {
+		 DEBUG("Breakpoint");
+    	       }
+    UPB   ""     {
+                    Vector o1;
+		    POP(Vector,o1);
+		    CHECKNILV(o1, "Nil in UPB");
+		    PUSH(s32,o1->d.items-1);
+                  }
+    STRLIT ""  {
+                 Vector v;
+		 String o;
+		 u32 off, length;
+		 POP(u32, length);
+		 POP(u32, off);
+		 POP(Vector, v);
+		 CHECKNILV(v, "Nil in STRLIT");
+		 regRoot(v);
+		 F_SYNCH();
+		 o = (String)CreateVector(BuiltinInstCT(STRINGI),length);
+		 F_UNSYNCH();
+		 unregRoot();
+		 memmove(&o->d.data[0], &v->d.data[off], length);
+		 PUSH(String, o);
+	       }
+    LDINDS "u16" {
+                   Object o;
+
+		   POP(Object, o);
+		   CHECKNILO(o, "Nil invoked (LDINDS)");
+		   {
+		     LDS(FETCH(u32, (int) o, t));
+		   }
+		 }
+    LDVINDS "u16" {
+		   u32 v;
+		   POP(u32, v);
+		   CHECKNILU(v, "Nil invoked (LDVINDS)");
+		   {
+		     LDS(FETCH(u32,v,t));
+		     PF(v, t+4);
+		   }
+		 }
+    PUSHCT ""	{
+		  Object o;
+		  ConcreteType xct;
+		  TOP(Object, o);
+		  if (ISNIL(o)) {
+		    PUSH(ConcreteType, (ConcreteType)JNIL);
+		  } else {
+ 		    xct = CODEPTR(o->flags);
+		    assert(xct);
+#ifdef USEABCONS
+		    if (ISNIL(xct->d.type)) {
+		      PUSH(AbCon, findConCon(xct));
+		    } else {
+		      PUSH(AbCon, findAbCon(OIDOf(xct->d.type), OIDOf(xct)));
+		    }
+#else
+		    PUSH(ConcreteType, xct);
+#endif
+		  }
+		}
+    STRF ""	{
+		  String s;
+		  float x;
+		  POP(String, s);
+		  CHECKNILS(s, "Nil in STRF");
+		  memmove(buf, s->d.data, s->d.items);
+		  buf[s->d.items] = '\0';
+		  x = (float)atof(buf);
+		  PUSH(float, x);
+    		}
+    XCREATE ""	{
+                  ConcreteType p;
+		  Vector v;
+		  Object o;
+		  int i;
+		  OpVectorElement ove;
+
+		  POP(Vector, v);
+		  POP(ConcreteType, p);
+		  regRoot(v);
+		  regRoot(p);
+		  F_SYNCH();
+                  o = (Object) gc_malloc(sizeofObject + p->d.instanceSize);
+		  F_UNSYNCH();
+		  unregRoot();
+		  unregRoot();
+                  SETRESDNT(o->flags);
+                  SETCODEPTR(o->flags, p);
+		  if (inDistGC()) SETDISTGC(o->flags);
+		  PUSH(Object, o);
+		  ove = p->d.opVector->d.data[OVE_INITIALLY];
+		  /* I really should push the concrete type too, but this */
+		  /* would break where we use XCREATE for now */
+		  /* This currently leaves the stack unaligned (4 not 8) */
+		  /* PUSH(ConcreteType, p); */
+		  if (!ISNIL(ove)) {
+		    if (ove->d.nargs > 0 && 
+			(ISNIL(v) || ove->d.nargs < v->d.items)) {
+		      DEBUG("Not enough arguments to XCREATE");
+		      continue;
+		    }
+		    TRACE(initiallies, 1, ("Invoking initially of a %.*s",
+					   p->d.name->d.items,
+					   p->d.name->d.data));
+		    for (i = 0; i < ove->d.nargs; i++) {
+		      PUSH(u32, ((u32 *)v->d.data)[2 * i]);
+		      PUSH(u32, ((u32 *)v->d.data)[2 * i + 1]);
+		    }
+		    F_SYNCH();
+		    pushAR(state, o, p, OVE_INITIALLY);
+		    F_UNSYNCH();
+		  }
+	        }
+@ X Window escape
+    XSYS "u8u8"   {
+		    SYNCH(); obsolete("XSYS", state);
+		  }
+@ Concurrency stuff
+    MONINIT ""	{
+		  monitor *m = (monitor *)((Object) op)->d;
+		  m->busy = 0;
+		  m->waiting = 0;
+		}
+    MONENTER "" {
+		  monitor *m = (monitor *)((Object) op)->d;
+		  if (m->busy) {
+		    SYNCH();
+		    if (!m->waiting) m->waiting = SQueueCreate();
+		    SQueueInsert(m->waiting, state);
+		    TRACE(process, 3, ("Blocking process %x - monitor entry",
+				       state));
+		    return 1;
+		  } else {
+		    TRACE(process, 3, ("Monitor entry, no delay"));
+		    m->busy = 1;
+		  }
+		}
+    MONEXIT "" {
+		  monitor *m = (monitor *)((Object) op)->d;
+		  void *new;
+		  if ((new = (void*) SQueueRemove(m->waiting)) == NULL) {
+		    TRACE(process, 3, ("Monitor exit, no waiters"));
+		    m->busy = 0;
+		  } else {
+		    makeReady((State*) new);
+		    TRACE(process, 3, ("Unblocking process %x - monitor exit",
+			   new));
+		  }
+		}
+    CONDINIT ""	{
+		  /* containingop holds the object for this CV */
+		  int *fpintp = (int *)fp;
+		  Object o;
+		  condition *c;
+
+		  /* first fetch the saved fp from acondition.initially */
+		  fpintp = (int *)fpintp[-2];
+		  /* Now get the saved op from that frame */
+		  o = (Object) fpintp[-3];
+		  c = (condition *) ((Object) op)->d;
+		  c->o = o;
+		  c->waiting = 0;
+		}
+    CONDWAIT ""	{
+		  Object o;
+		  condition *c;
+		  monitor *m;
+		  void *s;
+
+		  POP(Object, o);
+		  CHECKNILO(o, "Nil in condition wait");
+		  c = (condition *)((Object) o)->d;
+		  if (c->o != op) {
+		    DEBUG("condition wait on foreign condition");
+		    continue;
+		  }
+		  SYNCH();
+		  if (!c->waiting) c->waiting = SQueueCreate();
+		  SQueueInsert(c->waiting, state);
+		  TRACE(process, 3, ("Blocking process %x - condition wait",
+				     state));
+		  m = (monitor *)c->o->d;
+		  if ((s = (void*) SQueueRemove(m->waiting)) != NULL) {
+		    state = (State*) s;
+		    TRACE(process, 3, ("Resuming process %x - monitor queue",
+				       state));
+		    UNSYNCH();
+		  } else {
+		    m->busy = 0;
+		    return 1;
+		  }
+		}
+    CONDSIGNAL "" {
+		  Object o;
+		  condition *c;
+		  monitor *m;
+		  void *s;
+		  POP(Object, o);
+		  CHECKNILO(o, "Nil in condition signal");
+		  c = (condition *)((Object) o)->d;
+		  if (c->o != op) {
+		    DEBUG("condition signal on foreign condition");
+		    continue;
+		  }
+		  m = (monitor *)c->o->d;
+		  if ((s = SQueueRemove(c->waiting)) != NULL) {
+		    SYNCH();
+		    TRACE(process, 3,
+			   ("Blocking process %x - condition signal", state));
+		    if (m->waiting == 0) m->waiting = SQueueCreate();
+		    SQueueInsertFront(m->waiting, state);
+		    state = (State*) s;
+		    TRACE(process, 3,
+			  ("Resuming process %x - condition signal", state));
+		    if (SQueueSize(c->waiting) == 0) {
+		      SQueueDestroy(c->waiting);
+		      c->waiting = 0;
+		    }
+		    UNSYNCH();
+		  } else {
+		    TRACE(process, 3, ("Signal, but no waiters"));
+		  }
+		}
+    CONDAWAITING "" {
+		  Object o;
+		  u32 nwaiters;
+		  condition *c;
+		  POP(Object, o);
+		  CHECKNILO(o, "Nil in condition awaiting");
+		  c = (condition *)((Object) o)->d;
+		  if (c->o != op) {
+		    DEBUG("condition awaiting on foreign condition");
+		    continue;
+		  }
+		  nwaiters = SQueueSize(c->waiting);
+		  PUSH(u32, nwaiters);
+		}
+    DOLITERALS "" {
+		    Code c;
+		    POP(Code, c);
+		    SYNCH(); obsolete("DOLITERALS", state);
+		  }
+    INSTALLINOID "" {
+		    Object o;
+		    u32 seq;
+		    POP(Object, o);
+		    POP(u32, seq);
+		    OIDInsertFromSeq(seq, o);
+		  }
+    GETROOTDIR "" {
+		    char *buf;
+		    String s;
+		    buf = getenv("EMERALDROOT");
+		    if (buf == NULL) buf = EMERALDROOT;
+		    F_SYNCH();
+		    s = CreateString(buf);
+		    F_UNSYNCH();
+		    PUSH(String, s);
+		  }
+    CHECKPOINT "" {
+		    Object o;
+		    ConcreteType ct;
+		    String filename;
+
+		    POP(ConcreteType, ct);	  /* String's CT - ignore */
+		    POP(String, filename);
+#ifdef USEABCONS
+		    {
+		      AbCon abcon;
+		      POP(AbCon, abcon);
+		      ct = abcon->d.con;
+		    }
+#else
+		    POP(ConcreteType, ct);
+#endif
+		    POP(Object, o);
+		    CHECKNILO(o, "Nil in checkpoint");
+		    CheckpointToFile(o, ct, filename);
+		  }
+@ X Window escape --- could block the caller
+    BXSYS "u8u8"   {
+		     SYNCH(); obsolete("BXSYS", state);
+		   }
+    GCOLLECT "" {
+		  {
+		    SYNCH();
+		    gcollect();
+		    UNSYNCH();
+		  }
+		}
+    LAND ""     { BINARY(s32,&) }
+    LOR  ""     { BINARY(s32,|) }
+    LSETBIT ""  { 
+		  u32 a, b, v;
+		  POP(u32, v);
+		  POP(u32, b);
+		  TOP(u32, a);
+		  if (v) {
+		    a = a | (1 << (32 - b - 1));
+		  } else {
+		    a = a & ~(1 << (32 - b - 1));
+		  }
+		  SETTOP(u32, a);
+		}
+    LGETBIT ""  {
+		  u32 a, b;
+		  POP(u32, b);
+		  TOP(u32, a);
+		  SETTOP(u32, (a & (1 << (32 - b - 1))) ? 1 : 0);
+		}
+    CALCSIZE "" {
+		  SYNCH(); obsolete("CALCSIZE", state);
+	        }
+    IABS ""     { s32 a;
+		  TOP(s32, a);
+		  SETTOP(s32, ISNIL(a) ? 0 : a < 0 ? -a : a);
+		}
+@ Calloids finds the target object on the stack, and the operation oid as an
+@ immediate operand (2 bytes)
+    CALLOIDS "u16"	{
+		  IFETCH2(opoid);
+		  goto restofcalloid;
+		}
+    CALLSTAR "" {
+		  SYNCH(); obsolete("CALLSTAR", state);
+		}
+    CALLSTARCLEAN "" {
+		       SYNCH(); obsolete("CALLSTARCLEAN", state);
+		     }
+    CONFORMS "" {
+		  AbstractType a, b;
+		  POP(AbstractType, b);
+		  POP(AbstractType, a);
+		  CHECKNIL(AbstractType, a, "Nil a in conforms");
+		  CHECKNIL(AbstractType, b, "Nil b in conforms");
+		  PUSH(u32, conforms(a, b));
+		}
+
+    DSTR ""     { 
+		  u32 secs;
+		  String s, timeToDate(int);
+		  POP(u32, secs);
+		  F_SYNCH();
+		  s = timeToDate(secs);
+		  F_UNSYNCH();
+		  PUSH(String, s);
+		}
+    DLOAD ""	{
+		  String s;
+		  POP(String, s);
+		  CHECKNILS(s, "Nil in DLOAD");
+		  loadNGo(s);
+		}
+    RELOCATEVECTOR ""	{
+		  u32 id, i;
+		  ATTypeVector v;
+		  POP(u32, id);
+		  POP(u32, i);
+		  POP(ATTypeVector, v);
+		  fixObjectReferenceFromSeq(id, (Object)v, OffsetOf(v, &v->d.data[i]));
+		}
+    RELOCATETYPE ""	{
+		  u32 id;
+		  ConcreteType xct;
+		  POP(u32, id);
+		  POP(ConcreteType, xct);
+		  fixObjectReferenceFromSeq(id, (Object)xct, OffsetOf(xct, &xct->d.type));
+		}
+@ Initialize a lock for an object which is synchronized using accept
+   SYNCHINIT "" {
+		   monitor *m = (monitor *)((Object) op)->d;
+		   /*
+		    * Busy encodes two things:
+		    *	Low order bit:  open (== 0) or locked (== 1)
+		    *	Next bit:       process alive (== 2) or dead (== 0)
+		    *
+		    * The initial value is 3, locked and the process is alive
+		    * (or at least, hasn't died yet).
+		    */
+		   m->busy = 3;
+		   m->waiting = 0;
+		 }
+@ Enter a routine which is synchronized using accept
+   SYNCHENTER "" {
+		   monitor *m = (monitor *)((Object) op)->d;
+		   State *otherstate;
+		   if (prevOP(fp) == op) {
+		     TRACE(process, 3, ("SYNCHENTER on self invoke, passed"));
+		   } else {
+		     switch (m->busy) {
+		     case 0:
+		       /*
+			* Process dead, object unlocked.
+			*/
+		       m->busy = 1;
+		       break;
+		     case 1:
+		     case 3:
+		       /*
+			* Process dead or alive, object locked.
+			*/
+		       SYNCH();
+		       if (!m->waiting) m->waiting = SQueueCreate();
+		       SQueueInsert(m->waiting, state);
+		       TRACE(process, 3, ("Blocking process %x - synchronized object entry",
+					  state));
+		       return 1;
+		       break;
+		     case 2:
+		       /*
+			* Process alive, object unlocked.  The process will be
+			* at the head of the waiting queue, so block yourself and
+			* run it.  It will decide whether to allow entry.
+			*/
+		       assert(m->waiting);
+		       SYNCH();
+		       otherstate = SQueueRemove(m->waiting);
+		       SQueueInsert(m->waiting, state);
+		       state = otherstate;
+		       UNSYNCH();
+		       break;
+		     default:
+		       assert(0);
+		       break;
+		     }
+		   }
+                 }
+@GETOID returns three integers: the ipaddress, the incarnation (port and epoch), and the seq
+@ of the OID of the argument object.  If the 
+@ argument object doesn't yet have an OID it is assigned one.
+   GETOID     "" {
+                    OID theOID;
+		    Object obj; ConcreteType ct;
+
+		    POP(ConcreteType, ct);
+		    POP(Object, obj);
+		    if (HASODP(ct->d.instanceFlags)) {
+		      if (!HASOID(obj->flags)) {
+			NewOID(&theOID);
+			UpdateOIDTables(theOID, obj);
+		      } else {
+			theOID = OIDOf(obj);
+		      }
+		    } else {
+		      theOID.ipaddress = 0xffffffff;
+		      theOID.port = 0xffff;
+		      theOID.epoch = 0xffff;
+		      theOID.Seq = (Bits32)obj;
+		    }
+		    PUSH(u32, theOID.ipaddress);
+		    PUSH(ConcreteType, intct);
+		    PUSH(u32, (theOID.port << 16 | theOID.epoch));
+		    PUSH(ConcreteType, intct);
+		    PUSH(u32, theOID.Seq);
+		    PUSH(ConcreteType, intct);
+		  }
+@ Exit a routine which is synchronized using accept
+    SYNCHEXIT "" {
+		   monitor *m = (monitor *)((Object) op)->d;
+		   State *otherstate;
+		   if (prevOP(fp) == op) {
+		     TRACE(process, 3, ("SYNCHEXIT of self invoke - passed"));
+		   } else {
+		     if ((otherstate = SQueueRemove(m->waiting)) != NULL) {
+		       /*
+			* Either the process is still alive or some other
+			* operation wants in, in either case, schedule it.
+			*/
+		       makeReady(otherstate);
+		       TRACE(process, 3, ("Unblocking process %x - synchronized object exit",
+					  otherstate));
+		     } else {
+		       /*
+			* There is no other process waiting, the process
+			* better be dead and we want to unlock the object.
+			*/
+		       assert(m->busy == 1);
+		       m->busy = 0;
+		       TRACE(process, 3, ("No waiters - synchronized object exit"));
+		     }
+		   }
+		 }
+    GETIDSEQ ""	{
+		  OID oid;
+		  Object o;
+		  POP(Object, o);
+		  CHECKNILO(o, "Nil in GETIDSEQ");
+		  oid = OIDOf(o);
+		  if (isNoOID(oid)) {
+		    /* Merge: This is wrong - look at GETOID. */
+		    NewOID(&oid);
+		    OIDInsert(oid, o);
+		  }
+		  PUSH(u32, oid.Seq);
+		}
+@ announce the death of the synchronizing process
+    SYNCHDIE "" {
+		   monitor *m = (monitor *)((Object) op)->d;
+		   State *otherstate;
+		   assert(m->busy == 3);
+
+		   if ((otherstate = SQueueRemove(m->waiting)) != NULL) {
+		     /*
+		      * Some other operation wants in, schedule it.
+		      */
+		     makeReady(otherstate);
+		     TRACE(process, 3, ("Unblocking process %x - synchronizing process exit",
+					otherstate));
+		     m->busy = 1;
+		   } else {
+		     /*
+		      * There is no other process waiting, we want to unlock the object.
+		      */
+		     m->busy = 0;
+		     TRACE(process, 3, ("No waiters - synchronizing process exit"));
+		   }
+		 }
+    LDLITB "u8"	{ 
+      		  u8 t;
+		  IFETCH1(t);
+		  PUSH(Object, cp->d.literals->d.data[t].ptr);
+		}
+
+    SWAPV  ""    { u32 ad, at, bd, bt; 
+		   POP(u32, at); 
+		   POP(u32, ad); 
+		   POP(u32, bt);
+		   POP(u32, bd);
+		   PUSH(u32, ad);
+		   PUSH(u32, at);
+		   PUSH(u32, bd);
+		   PUSH(u32, bt);
+		 }
+    DOCTLITERALS "" {
+		    ConcreteType c;
+		    POP(ConcreteType, c);
+		    /* fix the literals in c */
+		    TRACE(trans, 1, ("Fixing literals in %#x (OID %#x) a %.*s",
+				     c, OIDSeqOf((Object)c), 
+				     c->d.name->d.items, c->d.name->d.data));
+		    fixCTLiterals(c);
+		  }
+    CVX "u8" {
+      u32 n, i;
+      u32 *tsp;
+      IFETCH1(n);
+      tsp = (u32 *) sp - 2 * n;
+      for (i = 1; i < n; i++) {
+	tsp[i] = tsp[2 * i];
+      }
+      sp -= 4 * n;
+    }
+
+    GCOLLECTOLD "" {
+		     SYNCH();
+		     gcollect();
+		     gcollect_old();
+		     UNSYNCH();
+    }
+  
+    CODEOF "" {
+#ifdef USEABCONS
+      AbCon abcon;
+      Object o;
+      POP(AbCon, abcon);
+      POP(Object, o);
+      if (ISNIL(o)) {
+	PUSH(ConcreteType, BuiltinInstCT(NILI));
+      } else {
+	PUSH(ConcreteType, abcon->d.con);
+      }
+#else
+      ConcreteType ct;
+      Object o;
+      POP(ConcreteType, ct);
+      POP(Object, o);
+      if (ISNIL(o)) {
+	PUSH(ConcreteType, BuiltinInstCT(NILI));
+      } else {
+	PUSH(ConcreteType, ct);
+      }
+#endif
+    }
+
+    BUILDABCON "" {
+#ifdef USEABCONS
+      ConcreteType con;
+      AbstractType ab;
+      AbCon abcon;
+      POP(ConcreteType, con);
+      POP(AbstractType, ab);
+      abcon = findAbCon(OIDOf(ab), OIDOf(con));
+      PUSH(AbCon, abcon);
+#else
+      assert(0);
+#endif
+    }
+
+    CHECKARGABCONB "u8" {
+#ifdef USEABCONS
+      AbstractType ab;
+      AbCon *abcon;
+      u8 t;
+      IFETCH1(t);
+      abcon = (AbCon *)(fp - (8 * t) + ARGOFF + 4);
+      POP(AbstractType, ab);
+      verifyAbCon(abcon, ab);
+#else
+      SYNCH(); obsolete("CHECKARGABCONB", state);
+#endif
+    }
+
+@ Calls finds the target object on the stack, and the operation number as an
+@ immediate operand.  Calls is used only with abcons.
+    CALLS "u16"	{
+#ifndef USEABCONS
+      assert(0);
+#else
+      assert(0);
+#endif /* USEABCONS */
+    }
+
+@ Callct finds the target object on the stack, and the operation index as an
+@ immediate operand.  This assumes we know the CT of the target.
+    CALLCTB "u8" {
+      int opindex;
+      ConcreteType a;
+      Object o;
+
+      IFETCH1(opindex);
+      POP(ConcreteType, a);
+      POP(Object, o);
+      SYNCH();
+      if (invoke(o, a, opindex, state)) {
+	return 1;
+      } else {
+	UNSYNCH();
+	INVOKECHECKSWITCH;
+      }
+    }	        
+
+    CONDSIGNALANDEXIT "u8" {
+		  Object o;
+		  u8 nargs;
+		  condition *c;
+		  void *new;
+		  ConcreteType xcp;
+
+		  IFETCH1(nargs);
+		  POP(Object, o);
+		  CHECKNILO(o, "Nil in condition signal");
+		  c = (condition *)((Object) o)->d;
+		  if (c->o != op) {
+		    DEBUG("condition signal on foreign condition");
+		    continue;
+		  }
+		  if ((new = SQueueRemove(c->waiting)) != NULL) {
+		    makeReady((State*)new);
+		    TRACE(process, 3,
+			  ("Unblocking process %x - condition signalandexit",
+			   new));
+		    if (SQueueSize(c->waiting) == 0) {
+		      SQueueDestroy(c->waiting);
+		      c->waiting = 0;
+		    }
+		    xcp = cp;
+		    sp = fp;
+		    POP(u32, pc);
+		    POP(u32, fp);
+		    POP(Object, op);
+		    POP(ConcreteType, cp);
+		    IFTRACE(call, 1) {
+		      doret(fp, sb, pc, xcp);
+		    }
+		    sp -= (nargs * 2 * sizeof(u32));
+		    PROFILERET();
+		  } else {
+		    TRACE(process, 3, ("Condition signal and exit, no waiters"));
+		  }
+		}
+    LSETBITS ""  { 
+		  u32 a, o, l, v, m = -1L;
+		  POP(u32, v);
+		  POP(u32, l);
+		  POP(u32, o);
+		  TOP(u32, a);
+		  m = m << (32 - l);
+		  m = m >> (o);
+		  a = (a & ~m) | (m & (v << (32 - o - l)));
+		  SETTOP(u32, a);
+		}
+    LGETBITS ""  {
+		  u32 a, o, l;
+		  POP(u32, l);
+		  POP(u32, o);
+		  TOP(u32, a);
+		  SETTOP(u32, ((a << o) >> (32 - l)));
+		}
+    VIEW "" {
+      AbstractType desired;
+      ConcreteType ct;
+      Object o;
+#ifdef USEABCONS
+      AbCon abcon;
+#endif
+      POP(AbstractType, desired);
+#ifdef USEABCONS
+      POP(AbCon, abcon);
+      TOP(Object, o);
+      if (!ISNIL(o)) {
+	ct = abcon->d.con;
+      }
+#else
+      POP(ConcreteType, ct);
+      TOP(Object, o);
+#endif
+      if (ISNIL(o) || conforms(ct->d.type, desired)) {
+	/* Everything is fine. */
+      } else {
+	DEBUG("View failure");
+      }
+#ifdef USEABCONS
+      PUSH(AbCon, ISNIL(o) ? (AbCon)JNIL : findAbCon(OIDOf(desired), OIDOf(ct)));
+#else
+      PUSH(ConcreteType, ct);
+#endif
+    }
+@ doesn't handle abcons -brian[0]
+    CALLER "" {
+      int *fpintp = (int*) fp;
+      Object o = (Object) fpintp[-3];
+      ConcreteType ct = (ConcreteType) fpintp[-4];
+      PUSH( Object, o );
+      PUSH( ConcreteType, ct );
+    }
+    INDIR "" {
+      u32 v;
+      POP(u32, v);
+      PF(v, 0);
+    }
+    INDIRV "" {
+      u32 v;
+      POP(u32, v); /* The first one is the concrete type, which we ignore */
+      POP(u32, v);
+      PF(v, 0);
+      PF(v, 4);
+    }
+    GETISTATE "" {
+      ConcreteType p = BuiltinInstCT(INTERPRETERSTATEI);
+      InterpreterState o;
+      F_SYNCH();
+      regRoot(p);
+      o = (InterpreterState) gc_malloc(sizeofObject + p->d.instanceSize);
+      F_UNSYNCH();
+      unregRoot();
+      *o = *state;
+      o->firstThing = RESDNTBIT;
+      SETCODEPTR(o->firstThing, p);
+      if (inDistGC()) SETDISTGC(o->firstThing);
+      PUSH( InterpreterState, o );
+    }
+    STRTOK "" {
+      String s, me;
+      int start, end;
+      POP(String, s);
+      POP(String, me);
+      CHECKNILS(s, "Nil string in String.token");
+      CHECKNILS(me, "Nil invoked in String.token");
+      stringTok(me, s, &start, &end);
+      if (start >= me->d.items) {
+	PUSH(String, (String)JNIL);
+	PUSH(String, (String)JNIL);
+      } else {
+	regRoot(me);
+	F_SYNCH();
+	s = (String)CreateVector(BuiltinInstCT(STRINGI), end - start);
+	F_UNSYNCH();
+	memmove(&s->d.data[0], &me->d.data[start], end - start);
+	PUSH(String, s);
+	if (me->d.items <= end) {
+	  s = (String)JNIL;
+	} else {
+	  F_SYNCH();
+	  s = (String)CreateVector(BuiltinInstCT(STRINGI), me->d.items - end);
+	  F_UNSYNCH();
+	  memmove(&s->d.data[0], &me->d.data[end], me->d.items - end);
+	}
+	PUSH(String, s);
+	unregRoot();
+      }
+    }
+    ADJSP "u16" {
+      u16 space;
+      IFETCH2(space);
+      sp = fp + space;
+    }
+    LSECS "u32" {
+      struct tm tm;
+      s32 res;
+      POP(u32, tm.tm_sec);
+      POP(u32, tm.tm_min);
+      POP(u32, tm.tm_hour);
+      POP(u32, tm.tm_mday);
+      POP(u32, tm.tm_mon);
+      POP(u32, tm.tm_year);
+      tm.tm_isdst = -1;
+      tm.tm_year -= 1900;
+      res = mktime(&tm);
+      if (res < 0) DEBUG("Invalid time");
+      PUSH(u32, res);
+    }
+      
+    CREATEGAGGLE "" {
+      Object manager;
+      ConcreteType xxx;
+
+      POP(ConcreteType, xxx);
+      POP(Object, manager);
+#ifdef DISTRIBUTED
+      {
+	OID oid = OIDOf(manager);
+	if (isNoOID(oid)) {
+	  NewOID(&oid);
+	  UpdateOIDTables(oid, manager);
+	}
+	createGaggle(oid);
+      }
+#endif
+    }
+    ADDTOGAGGLE "" {
+      Object manager, newobject;
+      ConcreteType xxx, oct;
+        
+      POP(ConcreteType, oct);
+      POP(Object, newobject);
+      POP(ConcreteType, xxx);
+      POP(Object, manager);
+      
+#ifdef DISTRIBUTED
+      {
+	OID moid, ooid;
+
+	moid = OIDOf(manager);
+	assert(!isNoOID(moid));
+	ooid = OIDOf(newobject);
+	if (isNoOID(ooid)) {
+	  NewOID(&ooid);
+	  UpdateOIDTables(ooid, newobject);
+	}
+	add_gmember(moid, ooid);
+	sendGaggleUpdate(moid, ooid, OIDOf(oct), 0);
+      }
+#endif
+    }
+    
+    GETGAGGLEMEMBER "" {
+      Object manager;
+      ConcreteType xxx;
+
+      POP(ConcreteType, xxx);
+      POP(Object, manager);
+#ifdef DISTRIBUTED
+      {
+	Object member;
+	OID moid, ooid, get_gmember(OID);
+
+	moid = OIDOf(manager);
+	assert(!isNoOID(moid));
+	ooid = get_gmember(moid);
+	if (isNoOID(ooid)){
+	  PUSH(Object, (Object)JNIL);
+	  PUSH(ConcreteType, (ConcreteType)JNIL);
+	} else{
+	  member = OIDFetch(ooid);
+	  PUSH(Object, member);
+	  PUSH(ConcreteType, CODEPTR(member->flags));
+	}
+      }
+#else
+      PUSH(Object, (Object)JNIL);
+      PUSH(ConcreteType, (ConcreteType)JNIL);
+#endif
+    }
+    GETGAGGLEELEMENT "" {
+      Object manager;
+      u32 index;
+      ConcreteType xxx;
+
+      POP(ConcreteType, xxx);
+      POP(u32, index);
+      POP(ConcreteType, xxx);
+      POP(Object, manager);
+#ifdef DISTRIBUTED
+      {
+	OID moid, ooid, get_gelement(OID, int);
+	Object member;
+	moid = OIDOf(manager);
+	assert(!isNoOID(moid));
+	ooid = get_gelement(moid, index);
+	if (isNoOID(ooid)){
+	  PUSH(Object, (Object)JNIL);
+	  PUSH(ConcreteType, (ConcreteType)JNIL);
+	}
+	else{
+	  member = OIDFetch(ooid);
+	  PUSH(Object, member);
+	  PUSH(ConcreteType, CODEPTR(member->flags));
+	}
+      }
+#else
+      PUSH(Object, (Object)JNIL);
+      PUSH(ConcreteType, (ConcreteType)JNIL);
+#endif
+    }
+    GETGAGGLESIZE "" {
+      Object manager;
+      ConcreteType xxx;
+
+      POP(ConcreteType, xxx);
+      POP(Object, manager);
+#ifdef DISTRIBUTED
+      {
+	OID moid;
+	u32 size, get_gsize(OID);
+
+	moid = OIDOf(manager);
+	if (isNoOID(moid)) {
+	  size = 0;
+	} else {
+	  size = get_gsize(moid);
+	}
+	PUSH(u32, size);
+	PUSH(ConcreteType, intct);
+      }
+#else
+      PUSH(u32, 0);
+      PUSH(ConcreteType, intct);
+#endif
+    }
+@ EOF
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/vm.h ubc-latest-src/vm/src/vm.h
--- sourceforge-1.06alpha/vm/src/vm.h	2017-12-11 17:59:03.092714462 +0100
+++ ubc-latest-src/vm/src/vm.h	2017-12-11 17:59:03.492711414 +0100
@@ -64,7 +42,7 @@
 #define STVOB 41
 #define STVAB 42
 #define DUP 43
-#define DUPV 44
+#define ENSURESPACE 44
 #define SWAP 45
 #define ADD 46
 #define SUB 47
@@ -136,7 +114,7 @@
 #define CREATEVECLIT 113
 #define STRHASH 114
 #define BREAKME 115
-#define FORWARD 116
+#define ACPTBLCK 116
 #define BREAKPT 117
 #define UPB 118
 #define STRLIT 119
@@ -173,17 +151,17 @@
 #define DLOAD 150
 #define RELOCATEVECTOR 151
 #define RELOCATETYPE 152
-#define STUBCALL 153
-#define STUBRETURN 154
+#define SYNCHINIT 153
+#define SYNCHENTER 154
 #define GETOID 155
-#define TESTREMOTE 156
+#define SYNCHEXIT 156
 #define GETIDSEQ 157
-#define CCALL 158
+#define SYNCHDIE 158
 #define LDLITB 159
 #define SWAPV 160
 #define DOCTLITERALS 161
 #define CVX 162
-#define TESTREMOTE2 163
+#define GCOLLECTOLD 163
 #define CODEOF 164
 #define BUILDABCON 165
 #define CHECKARGABCONB 166
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/vm_i.h ubc-latest-src/vm/src/vm_i.h
--- sourceforge-1.06alpha/vm/src/vm_i.h	2017-12-11 17:59:03.093714455 +0100
+++ ubc-latest-src/vm/src/vm_i.h	2017-12-11 17:59:03.492711414 +0100
@@ -285,6 +263,7 @@
       TIMESLICELOCALS
 #endif /* SINGLESTEP */
 
+#define prevOP(xx) ((Object)((u32 *)xx)[-3])
 
 #define NINSTRUCTIONS 185
 typedef struct State {
@@ -295,6 +274,7 @@
   u32 sb;		/* Stack base */
   Object op;		/* Object pointer */
   ConcreteType cp;		/* Concrete type */
+  OpVectorElement opp;		/* Operation pointer */
   Object ep;		/* Environment pointer */
   ConcreteType et;		/* Environment type */
   OID nsoid;		/* Next SS OID */
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/xdr_float.c ubc-latest-src/vm/src/xdr_float.c
--- sourceforge-1.06alpha/vm/src/xdr_float.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/xdr_float.c	2017-12-11 17:59:03.493711406 +0100
@@ -0,0 +1,283 @@
+/*
+ * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
+ * unrestricted use provided that this legend is included on all tape
+ * media and as a part of the software program in whole or part.  Users
+ * may copy or modify Sun RPC without charge, but are not authorized
+ * to license or distribute it to anyone else except as part of a product or
+ * program developed by the user.
+ *
+ * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
+ * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
+ *
+ * Sun RPC is provided with no support and without any obligation on the
+ * part of Sun Microsystems, Inc. to assist in its use, correction,
+ * modification or enhancement.
+ *
+ * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
+ * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
+ * OR ANY PART THEREOF.
+ *
+ * In no event will Sun Microsystems, Inc. be liable for any lost revenue
+ * or profits or other special, indirect and consequential damages, even if
+ * Sun has been advised of the possibility of such damages.
+ *
+ * Sun Microsystems, Inc.
+ * 2550 Garcia Avenue
+ * Mountain View, California  94043
+ */
+
+#if defined(LIBC_SCCS) && !defined(lint)
+/*static char *sccsid = "from: @(#)xdr_float.c 1.12 87/08/11 Copyr 1984 Sun Micro";*/
+/*static char *sccsid = "from: @(#)xdr_float.c	2.1 88/07/29 4.0 RPCSRC";*/
+static char *rcsid = "$Id: xdr_float.c,v 1.1 1997/01/21 23:59:53 norm Exp $";
+#endif
+
+/*
+ * xdr_float.c, Generic XDR routines impelmentation.
+ *
+ * Copyright (C) 1984, Sun Microsystems, Inc.
+ *
+ * These are the "floating point" xdr routines used to (de)serialize
+ * most common data items.  See xdr.h for more info on the interface to
+ * xdr.
+ */
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/param.h>
+#include <rpc/types.h>
+#include <rpc/xdr.h>
+
+/*
+ * NB: Not portable.
+ * This routine works on Suns (Sky / 68000's), i386's, MIPS, NS32k and Vaxen.
+ */
+
+#if defined(mc68000)||defined(sparc)||defined(i386)||defined(mips)||defined(ns32000)
+#define IEEEFP
+#endif
+
+#ifdef vax
+
+/* What IEEE single precision floating point looks like on a Vax */
+struct	ieee_single {
+	unsigned int	mantissa: 23;
+	unsigned int	exp     : 8;
+	unsigned int	sign    : 1;
+};
+
+/* Vax single precision floating point */
+struct	vax_single {
+	unsigned int	mantissa1 : 7;
+	unsigned int	exp       : 8;
+	unsigned int	sign      : 1;
+	unsigned int	mantissa2 : 16;
+};
+
+#define VAX_SNG_BIAS	0x81
+#define IEEE_SNG_BIAS	0x7f
+
+static struct sgl_limits {
+	struct vax_single s;
+	struct ieee_single ieee;
+} sgl_limits[2] = {
+	{{ 0x7f, 0xff, 0x0, 0xffff },	/* Max Vax */
+	{ 0x0, 0xff, 0x0 }},		/* Max IEEE */
+	{{ 0x0, 0x0, 0x0, 0x0 },	/* Min Vax */
+	{ 0x0, 0x0, 0x0 }}		/* Min IEEE */
+};
+#endif /* vax */
+
+bool_t
+xdr_float(xdrs, fp)
+	register XDR *xdrs;
+	register float *fp;
+{
+#ifndef IEEEFP
+	struct ieee_single is;
+	struct vax_single vs, *vsp;
+	struct sgl_limits *lim;
+	int i;
+#endif
+	switch (xdrs->x_op) {
+
+	case XDR_ENCODE:
+#ifdef IEEEFP
+		return (XDR_PUTLONG(xdrs, (long *)fp));
+#else
+		vs = *((struct vax_single *)fp);
+		for (i = 0, lim = sgl_limits;
+			i < sizeof(sgl_limits)/sizeof(struct sgl_limits);
+			i++, lim++) {
+			if ((vs.mantissa2 == lim->s.mantissa2) &&
+				(vs.exp == lim->s.exp) &&
+				(vs.mantissa1 == lim->s.mantissa1)) {
+				is = lim->ieee;
+				goto shipit;
+			}
+		}
+		is.exp = vs.exp - VAX_SNG_BIAS + IEEE_SNG_BIAS;
+		is.mantissa = (vs.mantissa1 << 16) | vs.mantissa2;
+	shipit:
+		is.sign = vs.sign;
+		return (XDR_PUTLONG(xdrs, (long *)&is));
+#endif
+
+	case XDR_DECODE:
+#ifdef IEEEFP
+		return (XDR_GETLONG(xdrs, (long *)fp));
+#else
+		vsp = (struct vax_single *)fp;
+		if (!XDR_GETLONG(xdrs, (long *)&is))
+			return (FALSE);
+		for (i = 0, lim = sgl_limits;
+			i < sizeof(sgl_limits)/sizeof(struct sgl_limits);
+			i++, lim++) {
+			if ((is.exp == lim->ieee.exp) &&
+				(is.mantissa == lim->ieee.mantissa)) {
+				*vsp = lim->s;
+				goto doneit;
+			}
+		}
+		vsp->exp = is.exp - IEEE_SNG_BIAS + VAX_SNG_BIAS;
+		vsp->mantissa2 = is.mantissa;
+		vsp->mantissa1 = (is.mantissa >> 16);
+	doneit:
+		vsp->sign = is.sign;
+		return (TRUE);
+#endif
+
+	case XDR_FREE:
+		return (TRUE);
+	}
+	return (FALSE);
+}
+
+/*
+ * This routine works on Suns (Sky / 68000's), i386's, MIPS and Vaxen.
+ */
+
+#ifdef vax
+/* What IEEE double precision floating point looks like on a Vax */
+struct	ieee_double {
+	unsigned int	mantissa1 : 20;
+	unsigned int	exp       : 11;
+	unsigned int	sign      : 1;
+	unsigned int	mantissa2 : 32;
+};
+
+/* Vax double precision floating point */
+struct  vax_double {
+	unsigned int	mantissa1 : 7;
+	unsigned int	exp       : 8;
+	unsigned int	sign      : 1;
+	unsigned int	mantissa2 : 16;
+	unsigned int	mantissa3 : 16;
+	unsigned int	mantissa4 : 16;
+};
+
+#define VAX_DBL_BIAS	0x81
+#define IEEE_DBL_BIAS	0x3ff
+#define MASK(nbits)	((1 << nbits) - 1)
+
+static struct dbl_limits {
+	struct	vax_double d;
+	struct	ieee_double ieee;
+} dbl_limits[2] = {
+	{{ 0x7f, 0xff, 0x0, 0xffff, 0xffff, 0xffff },	/* Max Vax */
+	{ 0x0, 0x7ff, 0x0, 0x0 }},			/* Max IEEE */
+	{{ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0},		/* Min Vax */
+	{ 0x0, 0x0, 0x0, 0x0 }}				/* Min IEEE */
+};
+
+#endif /* vax */
+
+
+bool_t
+xdr_double(xdrs, dp)
+	register XDR *xdrs;
+	double *dp;
+{
+	register long *lp;
+#ifndef IEEEFP
+	struct	ieee_double id;
+	struct	vax_double vd;
+	register struct dbl_limits *lim;
+	int i;
+#endif
+
+	switch (xdrs->x_op) {
+
+	case XDR_ENCODE:
+#ifdef IEEEFP
+		lp = (long *)dp;
+#if BYTE_ORDER == BIG_ENDIAN
+		return (XDR_PUTLONG(xdrs, lp++) && XDR_PUTLONG(xdrs, lp));
+#else
+		return (XDR_PUTLONG(xdrs, lp+1) && XDR_PUTLONG(xdrs, lp));
+#endif
+#else
+		vd = *((struct vax_double *)dp);
+		for (i = 0, lim = dbl_limits;
+			i < sizeof(dbl_limits)/sizeof(struct dbl_limits);
+			i++, lim++) {
+			if ((vd.mantissa4 == lim->d.mantissa4) &&
+				(vd.mantissa3 == lim->d.mantissa3) &&
+				(vd.mantissa2 == lim->d.mantissa2) &&
+				(vd.mantissa1 == lim->d.mantissa1) &&
+				(vd.exp == lim->d.exp)) {
+				id = lim->ieee;
+				goto shipit;
+			}
+		}
+		id.exp = vd.exp - VAX_DBL_BIAS + IEEE_DBL_BIAS;
+		id.mantissa1 = (vd.mantissa1 << 13) | (vd.mantissa2 >> 3);
+		id.mantissa2 = ((vd.mantissa2 & MASK(3)) << 29) |
+				(vd.mantissa3 << 13) |
+				((vd.mantissa4 >> 3) & MASK(13));
+	shipit:
+		id.sign = vd.sign;
+		lp = (long *)&id;
+		return (XDR_PUTLONG(xdrs, lp++) && XDR_PUTLONG(xdrs, lp));
+#endif
+
+	case XDR_DECODE:
+#ifdef IEEEFP
+		lp = (long *)dp;
+#if BYTE_ORDER == BIG_ENDIAN
+		return (XDR_GETLONG(xdrs, lp++) && XDR_GETLONG(xdrs, lp));
+#else
+		return (XDR_GETLONG(xdrs, lp+1) && XDR_GETLONG(xdrs, lp));
+#endif
+#else
+		lp = (long *)&id;
+		if (!XDR_GETLONG(xdrs, lp++) || !XDR_GETLONG(xdrs, lp))
+			return (FALSE);
+		for (i = 0, lim = dbl_limits;
+			i < sizeof(dbl_limits)/sizeof(struct dbl_limits);
+			i++, lim++) {
+			if ((id.mantissa2 == lim->ieee.mantissa2) &&
+				(id.mantissa1 == lim->ieee.mantissa1) &&
+				(id.exp == lim->ieee.exp)) {
+				vd = lim->d;
+				goto doneit;
+			}
+		}
+		vd.exp = id.exp - IEEE_DBL_BIAS + VAX_DBL_BIAS;
+		vd.mantissa1 = (id.mantissa1 >> 13);
+		vd.mantissa2 = ((id.mantissa1 & MASK(13)) << 3) |
+				(id.mantissa2 >> 29);
+		vd.mantissa3 = (id.mantissa2 >> 13);
+		vd.mantissa4 = (id.mantissa2 << 3);
+	doneit:
+		vd.sign = id.sign;
+		*dp = *((double *)&vd);
+		return (TRUE);
+#endif
+
+	case XDR_FREE:
+		return (TRUE);
+	}
+	return (FALSE);
+}
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN sourceforge-1.06alpha/vm/src/xsys.c ubc-latest-src/vm/src/xsys.c
--- sourceforge-1.06alpha/vm/src/xsys.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/xsys.c	2017-12-11 17:59:03.493711406 +0100
@@ -0,0 +1,501 @@
+/* comment me!
+ */
+
+#ifdef XWindows
+#include "vm_exp.h"
+#include "assert.h"
+#include "misc.h"
+#include "sisc.h"
+
+#include <sys/file.h>
+#include <sys/time.h>
+#include <errno.h>
+
+
+#undef True
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+
+static Display *display;
+
+XWMHints xwmh={
+    (InputHint|StateHint),
+    True,
+    NormalState,
+    0,
+    0,
+    0,0,
+    0,
+    0
+  };
+
+static  unsigned long black,white;
+
+/* Macro to convert a String to a char *. */
+#define JTOCString(js, cs) { \
+			       (cs) = malloc((js)->d.items + 1); \
+			       bcopy((js)->d.data, (cs), \
+				     (js)->d.items); \
+			       (cs)[(js)->d.items] = '\0'; \
+			   }
+
+static XEvent *waitingEvent;
+static State *waitingState;
+
+void XCreateDisplay(String es)
+{
+
+  if (es == (String)JNIL) {
+    display = XOpenDisplay("");
+  } else {
+    char *s;
+    JTOCString(es, s);
+    display = XOpenDisplay(s);
+    free(s);
+  }
+  if (display == NULL) {
+    TRACE(x, 0, ("Cannot initialize display"));
+    exit(1);
+  } 
+  black = BlackPixel(display,DefaultScreen(display));
+  white = WhitePixel(display,DefaultScreen(display));
+}
+
+static int tryRead(XEvent *ev)
+{
+  if (XPending(display) > 0) {
+    TRACE(x, 5, ("XEvent: calling NextEvent"));
+    XNextEvent(display, ev);
+    TRACE(x, 5, ("XEvent: NextEvent returned"));
+    TRACE(x, 5, ("event = (%d %d %d %d %d)", 
+      *(0 + (int *)ev),
+      *(1 + (int *)ev),
+      *(2 + (int *)ev),
+      *(3 + (int *)ev),
+      *(4 + (int *)ev)));
+    return 1;
+  } else {
+/*     XSync(display, False); */
+    return 0;
+  }
+}
+
+/**********************************************************************/
+/*      EMXReadEvent                                                    */
+/**********************************************************************/
+/* Kernel Call */
+int EMXReadEvent(int *sp)
+{
+  Bitchunk                      event;
+  XEvent			* ev;
+
+  TRACE(x, 3, ("EMXReadEvent"));
+
+  event = *(Bitchunk *)sp;
+  if (ISNIL(event)) {
+    TRACE(x, 0,("Event is NIL in EMXReadEvent."));
+    return 0;
+  }
+
+  /* Check the size of the Bitchunk */
+  if (event->d.items < sizeof(XEvent)) {
+    TRACE(x, 2, ("Read attempt with a too small Bitchunk: %d should be %d.",
+      event->d.items, sizeof(XEvent)));
+    return 0;
+  }
+
+  /* Check for a display */
+  if (!display) {
+    TRACE(x, 1, ("Read attempt with no display (= nil)."));
+    return 0;
+  }
+
+  ev = (XEvent *)&event->d.data[0];
+  if (tryRead(ev)) {
+  } else {
+    do {
+      processEverythingOnce();
+    } while (tryRead(ev) == 0);
+  }
+  return 0;
+}
+
+int EMXCreateWindow(int *sp)
+{
+  int x = sp[0], y = sp[1], w = sp[2], h = sp[3];
+  String name = (String) sp[4];
+  Window window;
+  XSizeHints xsh;
+  char *cname;
+
+  sp[0] = (long) JNIL;
+
+  if (display == NULL) {
+    TRACE(x, 1, ("Create window called with no display"));
+    return 1;
+  }
+
+  JTOCString(name, cname);
+  TRACE(x, 3, ("Create window named %s", cname));
+
+  xsh.x = x;
+  xsh.y = y;
+  xsh.width = w;
+  xsh.height = h;
+  xsh.flags = (USPosition|USSize); 
+
+  TRACE(x, 3, ("Create window at (%d, %d) size (%d, %d)",
+    xsh.x, xsh.y, xsh.width, xsh.height));
+  window = XCreateSimpleWindow(display, DefaultRootWindow(display), xsh.x,
+			       xsh.y, xsh.width, xsh.height, 1, black, white);
+  TRACE(x, 3, ("XCreateWindow returns %d", window));
+  XSetStandardProperties(display,window,cname,cname,None,NULL,0,&xsh);
+/*  XSetWMHints(display,window,&xwmh); */
+  XMapWindow(display,window);
+#if 0
+  XSelectInput(display, window, ExposureMask);
+  XWindowEvent(display, window, ExposureMask, &event);
+#endif
+  sp[0] = (long) window;
+  free(cname);
+  return 1;
+}
+
+/*-----------------------------------------------------------------------
+ * FUCTION : EMXSelectInput
+ *           To requests X server report the events associated with the event
+ *           Mask
+ * Jyhlin Chang Jul 15,1988
+ *-----------------------------------------------------------------------*/
+
+int EMXSelectInput(int *sp)
+{
+  Window w = sp[0];
+  unsigned long event_mask = sp[1];
+  
+  XSelectInput(display, w, event_mask);
+  return 0;
+
+}
+
+typedef struct {
+  XFontStruct *f;
+  int rc;
+} FontInfo, *FontInfoPtr;
+
+IISc GCToFontInfo;
+SISc nameToFont;
+
+void setUpFont(GC gc, char *fontname)
+{
+  Font font;
+  FontInfoPtr fi;
+  XGCValues gcvalues;
+
+  font = (Font) SIScLookup(nameToFont, fontname);
+  if (SIScIsNIL(font)) {
+    font = XLoadFont(display , fontname);
+    SIScInsert(nameToFont, fontname, (int)font);
+    fi = (FontInfoPtr) malloc(sizeof(FontInfo));
+    fi->f = XQueryFont(display, font);
+    fi->rc = 0;
+    TRACE(x, 3, ("Inserting %s %#x -> %#x in gctofontinfo", fontname, (int)font, (int)fi));
+    IIScInsert(GCToFontInfo, (int)font, (int)fi);
+  } else {
+    fi = (FontInfoPtr)IIScLookup(GCToFontInfo, (int)font);
+    assert(!IIScIsNIL(fi));
+  }
+  fi->rc++;
+  gcvalues.font = font;
+  XChangeGC(display, gc, GCFont, &gcvalues);
+  TRACE(x, 3, ("Inserting %#x -> %#x in gctofontinfo", (int)gc, (int)fi));
+  IIScInsert(GCToFontInfo, (int)gc, (int)fi);  
+}
+    
+int EMXInitGc(int *sp)
+{
+  Window win = sp[0];
+  XGCValues gcvalues;
+  GC gc;
+  int flags;
+
+  TRACE(x, 3, ("XInitGC"));
+  gcvalues.foreground = black; 
+  gcvalues.background = white; 
+  gcvalues.line_width =  0;
+  flags = GCLineWidth | GCForeground | GCBackground;
+
+  gc = XCreateGC(display,win,flags,&gcvalues);
+  setUpFont(gc, "9x15");
+  sp[0] = (long) gc;
+  TRACE(x, 3, ("XInitGC returns %x", gc));
+  return 1;
+}
+
+int EMXSetWidth(int *sp)
+{
+  GC gc = (GC) sp[0];
+  Window  win = (Window) sp[1];
+  int width = sp[2];
+  XGCValues gcvalues;
+
+  gcvalues.line_width =  width;
+  XChangeGC(display,gc,GCLineWidth,&gcvalues);
+  return 0;
+} 
+
+int EMXSetFont(int *sp)
+{
+  GC gc = (GC) sp[0];
+  Window win = (Window)sp[1];
+  String  fontname = (String)sp[2];   
+  char *cfontname;
+
+  JTOCString(fontname, cfontname);
+  setUpFont(gc, cfontname);
+  free(cfontname);
+  return 0;
+}
+
+int EMXLine(int *sp)
+{
+  Window win = (Window)sp[0];
+  int  x1 = sp[1], y1 = sp[2];
+  int  x2 = sp[3], y2 = sp[4];
+  GC gc = (GC)sp[5];
+
+  TRACE(x, 3, ("X Line on window %d from (%d, %d) to (%d, %d)",
+    win, x1, y1, x2, y2));
+  XDrawLine(display,win,gc,x1, y1, x2, y2);
+  TRACE(x, 3, ("XLine done"));
+  return 0;
+}
+
+int EMXTextWidth(int *sp)
+{
+  Window win = (Window)sp[0];
+  String string = (String)sp[1]; 
+  GC gc = (GC)sp[2];
+  FontInfoPtr fi;
+  
+  TRACE(x, 3, ("XTextWidth begin %.*s", string->d.items, string->d.data));
+  fi = (FontInfoPtr)IIScLookup(GCToFontInfo, (int)gc);
+  assert(!IIScIsNIL(fi));
+  sp[0] = XTextWidth(fi->f, (char *)string->d.data, string->d.items);
+  TRACE(x, 3, ("XTextWidth done"));
+  return 1;
+}
+  
+int EMXString(int *sp)
+{
+  Window win = (Window)sp[0];
+  String string = (String)sp[1]; 
+  int x = sp[2], y = sp[3];
+  GC gc = (GC)sp[4];
+
+  TRACE(x, 3, ("XString begin %.*s", string->d.items, string->d.data));
+  XDrawString(display, win, gc, x, y, (char *)string->d.data, string->d.items);
+  TRACE(x, 3, ("XString done"));
+  return 0;
+}
+
+int EMXConfigureWindow(int *sp)
+{
+  Window win = (Window)sp[0];
+  int x = sp[1], y = sp[2], w = sp[3], h = sp[4];
+  XWindowChanges values;
+
+  TRACE(x, 3, ("X ConfigureWindow on window %d (%d, %d) (%d, %d)",
+    win, x, y, w, h));
+  values.x = x;
+  values.y = y;
+  values.width = w;
+  values.height = h;
+  XConfigureWindow(display, win, CWX|CWY|CWWidth|CWHeight, &values);
+  TRACE(x, 3, ("XConfigureWindow done"));
+  return 0;
+}
+
+int EMXFlush(int *sp)
+{
+  TRACE(x, 3, ("X Flush called"));
+  XFlush(display);
+  TRACE(x, 3, ("X Flush done"));
+  return 0;
+}
+
+int EMXWFlush(int *sp)
+{
+  Window w = (Window) sp[0];
+  XFlush(display);
+  return 0;
+}
+
+int EMXRaiseWindow(int *sp)
+{
+  Window w = (Window)sp[0];
+  XRaiseWindow(display, w);
+  return 0;
+}
+
+int EMXLowerWindow(int *sp)
+{
+  Window w = (Window)sp[0];
+  XLowerWindow(display, w);
+  return 0;
+}
+
+int EMXUnmapWindow(int *sp)
+{
+  Window w = (Window)sp[0];
+  XUnmapWindow(display, w);
+  return 0;
+}
+
+int EMXResizeWindow(int *sp)
+{
+  Window w =(Window)sp[0];
+  int x = sp[1],y = sp[2];
+  XResizeWindow(display,w,x,y);
+  return 0;
+}
+
+int EMXMoveWindow(int *sp)
+{
+  Window w =(Window)sp[0];
+  int x = sp[1],y = sp[2];
+  XMoveWindow(display,w,x,y);
+  return 0;
+}
+
+int EMXClearWindow(int *sp)
+{
+  Window w = (Window)sp[0];
+  XClearWindow(display, w);
+  return 0;
+}
+
+int EMXClearArea(int *sp)
+{
+  Window w = (Window)sp[0];
+  int tlx = sp[1], tly = sp[2], width = sp[3], height = sp[4];
+  XClearArea(display, w, tlx, tly, width, height, False);
+  return 0;
+}
+
+int EMXCloseWindow(int *sp)
+{
+  Window w = (Window)sp[0];
+  XDestroyWindow(display,w);
+  return 0;
+}
+
+int EMXBatch(int *sp)
+{
+  int value = sp[0];
+  if (value) {
+  }
+  return 0;
+}
+
+int EMXGet(int *sp)
+{
+  Window win = (Window)sp[0];
+  String string = (String)sp[1]; 
+  sp[0] = (long)string;
+  return 1;
+}
+
+int EMXSet(int *sp)
+{
+  Window win = (Window)sp[0];
+  String string = (String)sp[1]; 
+
+  return 0;
+}
+
+/*----------------------------------------------------------------------
+ *
+ * Translate KeyBoard Event's input keycode to ASCII String 
+ *----------------------------------------------------------------------*/
+#define BUFFERSIZE 255
+static char CInputBuffer[BUFFERSIZE];
+
+int EMXGetCharacter(int *sp)
+{
+  Bitchunk                      event = (Bitchunk)sp[0];
+  int                             length;
+  String                          s;
+  XEvent                          *ev;
+
+  sp[0] = (long)JNIL;
+
+  if (event == (Bitchunk) JNIL) {
+    TRACE(x, 2, ("Event is NIL in EMXGetCharacter."));
+    return 1;
+  }
+
+  ev = (XEvent *)event->d.data; 
+  TRACE(x, 5, ("event = (%d %d %d %d %d)", 
+    *(0 + (int *)ev),
+    *(1 + (int *)ev),
+    *(2 + (int *)ev),
+    *(3 + (int *)ev),
+    *(4 + (int *)ev)));
+
+  TRACE(x, 5, ("Before XLookupString"));
+  CInputBuffer[0] = '\0';
+  length = XLookupString((XKeyEvent *)ev, CInputBuffer, BUFFERSIZE,
+			 (KeySym *)NULL, (XComposeStatus *)NULL);
+  TRACE(x, 5, ("After XLookupString, len=%d, str=%s, end=%d", length,
+	 CInputBuffer, *(CInputBuffer+length)));
+
+  s = (String)CreateString(CInputBuffer);
+  TRACE(x, 5, ("After BuildString, s = %x", s));
+  sp[0] = (long) s;
+  return 1;
+} 
+
+int EMXInit(int *sp)
+{
+  TRACE(x, 1, ("XInit"));
+  XCreateDisplay((String)JNIL);
+  GCToFontInfo = IIScCreate();
+  nameToFont = SIScCreate();
+#if 0
+  MTRegisterFD(ConnectionNumber(display));
+#endif
+  return 0;
+}
+#endif
+
+int (*xfuncs[])(int *) = {
+#ifdef XWindows
+  EMXInitGc,		/* 0 */
+  EMXSetFont,		/* 1 */
+  EMXSetWidth,		/* 2 */
+  EMXLine,		/* 3 */
+  EMXString,		/* 4 */
+  EMXCreateWindow,	/* 5 */
+  EMXUnmapWindow,	/* 6 */
+  EMXClearWindow,	/* 7 */
+  EMXCloseWindow,	/* 8 */
+  EMXMoveWindow,	/* 9 */
+  EMXResizeWindow,	/* 10 */
+  EMXConfigureWindow,	/* 11 */
+  EMXRaiseWindow,	/* 12 */
+  EMXLowerWindow,	/* 13 */
+  EMXFlush,		/* 14 */
+  EMXReadEvent,		/* 15 */
+  EMXGetCharacter,	/* 16 */
+  EMXSelectInput,	/* 17 */
+  EMXInit,		/* 18 */
+  EMXWFlush,		/* 19 */
+  EMXBatch,		/* 20 */
+  0,			/* 21 */
+  EMXGet,		/* 22 */
+  EMXSet,		/* 23 */
+  EMXTextWidth,		/* 24 */
+  EMXClearArea,		/* 25 */
+#endif
+};
