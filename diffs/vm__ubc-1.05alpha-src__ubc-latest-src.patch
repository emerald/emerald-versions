diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/call.c ubc-latest-src/vm/src/call.c
--- ubc-1.05alpha-src/vm/src/call.c	2017-12-11 17:59:03.420711962 +0100
+++ ubc-latest-src/vm/src/call.c	2017-12-11 17:59:03.483711482 +0100
@@ -54,7 +54,8 @@
   PUSH(u32, state->pc);
 
   /* switch to the called environment */
-  state->pc = (u32)ct->d.opVector->d.data[opindex]->d.code->d.data;
+  state->opp = ct->d.opVector->d.data[opindex];
+  state->pc = (u32)state->opp->d.code->d.data;
   state->cp = ct;
   state->op = obj;
   state->fp = sp;
@@ -181,7 +182,6 @@
   extern IISc fixqueue;
   ISet fixq;
   int why = IIScLookup(allfrozen, (int)obj);
-  ConcreteType ct = CODEPTR(obj->flags);
 
   if ((Reason)why != RInitially) return;
   fixq = (ISet) IIScLookup(fixqueue, (int)obj);
@@ -190,7 +190,8 @@
   IIScInsert(fixqueue, (int)obj, (int)SQueueCreate());
   TRACE(initiallies, 1,
 	("actively invoking initially/recovery of %#x (%.*s)",
-	 obj, ct->d.name->d.items, ct->d.name->d.data));
+	 obj, CODEPTR(obj->flags)->d.name->d.items,
+	 CODEPTR(obj->flags)->d.name->d.data));
   run(obj, reasonToIndex(why), 0);
 }
 
@@ -477,8 +478,8 @@
 struct State *stateFetch(OID oid, Node loc)
 {
   State *state = (State *)OIDFetch(oid);
-  int isnew = 0;
 #ifdef DISTRIBUTED
+  int isnew = 0;
   if (ISNIL(state)) {
     ConcreteType stateCT = BuiltinInstCT(INTERPRETERSTATEI);
 
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/cctab.c ubc-latest-src/vm/src/cctab.c
--- ubc-1.05alpha-src/vm/src/cctab.c	2017-12-11 17:59:03.421711955 +0100
+++ ubc-latest-src/vm/src/cctab.c	2017-12-11 17:59:03.483711482 +0100
@@ -9,11 +9,6 @@
 #include "assert.h"
 #include "cctab.h"
 
-static int notselected(void) 
-{
-  assert(0);
-  return 1;
-}
 CCallDescriptor EMSTREAM_table[] = { 
   { (ccallFunction) streamOpen, "EMS_OPEN", "ixS" },
   { (ccallFunction) streamClose, "EMS_CLOSE", "vxi" },
@@ -31,6 +26,7 @@
   { (ccallFunction) streamFlush, "EMS_FLUSH", "vxi" },
   { (ccallFunction) streamBind, "EMS_BIND", "iS" },
   { (ccallFunction) streamAccept, "EMS_ACCEPT", "ii" },
+  { (ccallFunction) streamRawRead, "EMS_RAWREAD", "ixip" },
 };
 CCallDescriptor STRING_table[] = { 
   { (ccallFunction) charIsAlpha, "EMCH_ISALPHA", "bi" },
@@ -59,246 +55,20 @@
 CCallDescriptor MISK_table[] = { 
   { (ccallFunction) die, "UEXIT", "vi" },
   { (ccallFunction) mgetenv, "UGETENV", "sS" },
-};
-CCallDescriptor REGEXP_table[] = { 
-  { (ccallFunction) notselected, "REG_EXEC", "bpS" },
-  { (ccallFunction) notselected, "REG_SUB", "SpS" },
-  { (ccallFunction) notselected, "REG_COMP", "pS" },
-};
-CCallDescriptor XFORMS_table[] = { 
-  { (ccallFunction) notselected, "FL_INITIALIZE", "vS" },
-  { (ccallFunction) notselected, "FL_BGN_FORM", "iiii" },
-  { (ccallFunction) notselected, "FL_END_FORM", "v" },
-  { (ccallFunction) notselected, "FL_SHOW_FORM", "viiiS" },
-  { (ccallFunction) notselected, "FL_DO_FORMS", "i" },
-  { (ccallFunction) notselected, "FL_HIDE_FORM", "vi" },
-  { (ccallFunction) notselected, "FL_GET_DISPLAY", "i" },
-  { (ccallFunction) notselected, "FL_CREATE_BOX", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_CREATE_FRAME", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_CREATE_TEXT", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_CREATE_BITMAP", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_SET_BITMAP_DATA", "viiiS" },
-  { (ccallFunction) notselected, "FL_SET_BITMAP_FILE", "viS" },
-  { (ccallFunction) notselected, "FL_CREATE_CLOCK", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_CREATE_CHART", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_SET_CHART_MAXNUMB", "vii" },
-  { (ccallFunction) notselected, "FL_CLEAR_CHART", "vi" },
-  { (ccallFunction) notselected, "FL_ADD_CHART_VALUE", "vifSi" },
-  { (ccallFunction) notselected, "FL_INSERT_CHART_VALUE", "viifSi" },
-  { (ccallFunction) notselected, "FL_REPLACE_CHART_VALUE", "viifSi" },
-  { (ccallFunction) notselected, "FL_SET_CHART_BOUNDS", "viff" },
-  { (ccallFunction) notselected, "FL_SET_CHART_AUTOSIZE", "vii" },
-  { (ccallFunction) notselected, "FL_CREATE_BUTTON", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_CREATE_LIGHTBUTTON", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_CREATE_ROUNDBUTTON", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_CREATE_CHECKBUTTON", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_CREATE_BITMAPBUTTON", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_SET_BUTTON", "vii" },
-  { (ccallFunction) notselected, "FL_GET_BUTTON", "ii" },
-  { (ccallFunction) notselected, "FL_GET_BUTTON_NUMB", "ii" },
-  { (ccallFunction) notselected, "FL_SET_BITMAPBUTTON_DATA", "viiiS" },
-  { (ccallFunction) notselected, "FL_SET_BITMAPBUTTON_FILE", "viS" },
-  { (ccallFunction) notselected, "FL_CREATE_SLIDER", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_CREATE_VALSLIDER", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_SET_SLIDER_VALUE", "vif" },
-  { (ccallFunction) notselected, "FL_GET_SLIDER_VALUE", "fi" },
-  { (ccallFunction) notselected, "FL_SET_SLIDER_BOUNDS", "viff" },
-  { (ccallFunction) notselected, "FL_SET_SLIDER_STEP", "vif" },
-  { (ccallFunction) notselected, "FL_SET_SLIDER_SIZE", "vif" },
-  { (ccallFunction) notselected, "FL_SET_SLIDER_PRECISION", "vii" },
-  { (ccallFunction) notselected, "FL_CREATE_DIAL", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_SET_DIAL_VALUE", "vif" },
-  { (ccallFunction) notselected, "FL_GET_DIAL_VALUE", "fi" },
-  { (ccallFunction) notselected, "FL_SET_DIAL_BOUNDS", "viff" },
-  { (ccallFunction) notselected, "FL_SET_DIAL_ANGLES", "viff" },
-  { (ccallFunction) notselected, "FL_SET_DIAL_CROSS", "vii" },
-  { (ccallFunction) notselected, "FL_SET_DIAL_STEP", "vif" },
-  { (ccallFunction) notselected, "FL_CREATE_COUNTER", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_SET_COUNTER_VALUE", "vif" },
-  { (ccallFunction) notselected, "FL_GET_COUNTER_VALUE", "fi" },
-  { (ccallFunction) notselected, "FL_SET_COUNTER_BOUNDS", "viff" },
-  { (ccallFunction) notselected, "FL_SET_COUNTER_STEP", "viff" },
-  { (ccallFunction) notselected, "FL_SET_COUNTER_PRECISION", "vii" },
-  { (ccallFunction) notselected, "FL_CREATE_INPUT", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_GET_INPUT", "si" },
-  { (ccallFunction) notselected, "FL_SET_INPUT", "viS" },
-  { (ccallFunction) notselected, "FL_SET_INPUT_SELECTED", "vii" },
-  { (ccallFunction) notselected, "FL_SET_INPUT_SELECTED_RANGE", "viii" },
-  { (ccallFunction) notselected, "FL_SET_INPUT_CURSORPOS", "viii" },
-  { (ccallFunction) notselected, "FL_GET_INPUT_CURSORXPOS", "ii" },
-  { (ccallFunction) notselected, "FL_SET_INPUT_MAXCHARS", "vii" },
-  { (ccallFunction) notselected, "FL_SET_INPUT_SCROLL", "vii" },
-  { (ccallFunction) notselected, "FL_SETPUP_FONTSIZE", "vi" },
-  { (ccallFunction) notselected, "FL_SETPUP_FONTSTYLE", "vi" },
-  { (ccallFunction) notselected, "FL_CREATE_MENU", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_GET_MENU", "ii" },
-  { (ccallFunction) notselected, "FL_GET_MENU_TEXT", "si" },
-  { (ccallFunction) notselected, "FL_GET_MENU_ITEM_TEXT", "sii" },
-  { (ccallFunction) notselected, "FL_GET_MENU_MAXITEMS", "ii" },
-  { (ccallFunction) notselected, "FL_SET_MENU", "viS" },
-  { (ccallFunction) notselected, "FL_CLEAR_MENU", "vi" },
-  { (ccallFunction) notselected, "FL_ADDTO_MENU", "viS" },
-  { (ccallFunction) notselected, "FL_REPLACE_MENU_ITEM", "viiS" },
-  { (ccallFunction) notselected, "FL_DELETE_MENU_ITEM", "vii" },
-  { (ccallFunction) notselected, "FL_SET_MENU_ITEM_MODE", "viii" },
-  { (ccallFunction) notselected, "FL_GET_MENU_ITEM_MODE", "iii" },
-  { (ccallFunction) notselected, "FL_SHOW_MENU_SYMBOL", "vii" },
-  { (ccallFunction) notselected, "FL_SET_MENU_POPUP", "vii" },
-  { (ccallFunction) notselected, "FL_CREATE_CHOICE", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_CLEAR_CHOICE", "vi" },
-  { (ccallFunction) notselected, "FL_ADDTO_CHOICE", "viS" },
-  { (ccallFunction) notselected, "FL_DELETE_CHOICE", "vii" },
-  { (ccallFunction) notselected, "FL_REPLACE_CHOICE", "viiS" },
-  { (ccallFunction) notselected, "FL_GET_CHOICE", "ii" },
-  { (ccallFunction) notselected, "FL_GET_CHOICE_TEXT", "si" },
-  { (ccallFunction) notselected, "FL_GET_CHOICE_ITEM_TEXT", "sii" },
-  { (ccallFunction) notselected, "FL_GET_CHOICE_MAXITEMS", "ii" },
-  { (ccallFunction) notselected, "FL_SET_CHOICE", "vii" },
-  { (ccallFunction) notselected, "FL_SET_CHOICE_TEXT", "viS" },
-  { (ccallFunction) notselected, "FL_SET_CHOICE_ITEM_MODE", "viii" },
-  { (ccallFunction) notselected, "FL_SET_CHOICE_ALIGN", "vii" },
-  { (ccallFunction) notselected, "FL_SET_CHOICE_FONTSIZE", "vii" },
-  { (ccallFunction) notselected, "FL_SET_CHOICE_FONTSTYLE", "vii" },
-  { (ccallFunction) notselected, "FL_CREATE_BROWSER", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_CLEAR_BROWSER", "vi" },
-  { (ccallFunction) notselected, "FL_ADDTO_BROWSER", "viS" },
-  { (ccallFunction) notselected, "FL_ADD_BROWSER_LINE", "viS" },
-  { (ccallFunction) notselected, "FL_INSERT_BROWSER_LINE", "viiS" },
-  { (ccallFunction) notselected, "FL_DELETE_BROWSER_LINE", "vii" },
-  { (ccallFunction) notselected, "FL_REPLACE_BROWSER_LINE", "viiS" },
-  { (ccallFunction) notselected, "FL_GET_BROWSER_LINE", "sii" },
-  { (ccallFunction) notselected, "FL_SELECT_BROWSER_LINE", "vii" },
-  { (ccallFunction) notselected, "FL_DESELECT_BROWSER_LINE", "vii" },
-  { (ccallFunction) notselected, "FL_DESELECT_BROWSER", "vi" },
-  { (ccallFunction) notselected, "FL_ISSELECTED_BROWSER_LINE", "iii" },
-  { (ccallFunction) notselected, "FL_GET_BROWSER", "ii" },
-  { (ccallFunction) notselected, "FL_GET_BROWSER_MAXLINE", "ii" },
-  { (ccallFunction) notselected, "FL_GET_BROWSER_SCREENLINES", "ii" },
-  { (ccallFunction) notselected, "FL_GET_BROWSER_TOPLINE", "ii" },
-  { (ccallFunction) notselected, "FL_SET_BROWSER_TOPLINE", "vii" },
-  { (ccallFunction) notselected, "FL_SET_BROWSER_XOFFSET", "vii" },
-  { (ccallFunction) notselected, "FL_SET_BROWSER_FONTSIZE", "vii" },
-  { (ccallFunction) notselected, "FL_SET_BROWSER_FONTSTYLE", "vii" },
-  { (ccallFunction) notselected, "FL_CREATE_TIMER", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_SET_TIMER", "vif" },
-  { (ccallFunction) notselected, "FL_GET_TIMER", "fi" },
-  { (ccallFunction) notselected, "FL_CREATE_XYPLOT", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_SET_OBJECT_LSIZE", "vii" },
-  { (ccallFunction) notselected, "FL_SET_FONT", "vii" },
-  { (ccallFunction) notselected, "FL_SET_OBJECT_RETURN", "vii" },
-  { (ccallFunction) notselected, "FL_ADD_OBJECT", "vii" },
-  { (ccallFunction) notselected, "FL_SET_OBJECT_SHORTCUT", "viSi" },
-  { (ccallFunction) notselected, "FL_REDRAW_OBJECT", "vi" },
-  { (ccallFunction) notselected, "FL_FLUSH", "v" },
-  { (ccallFunction) notselected, "FL_GET_STRING_WIDTH", "iiiSi" },
-  { (ccallFunction) notselected, "FL_SET_OBJECT_BOXTYPE", "vii" },
-  { (ccallFunction) notselected, "FL_SET_OBJECT_LALIGN", "vii" },
-  { (ccallFunction) notselected, "FL_CREATE_PIXMAP", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_SET_PIXMAP_FILE", "viS" },
-  { (ccallFunction) notselected, "FL_SET_PIXMAP_PIXMAP", "viii" },
-  { (ccallFunction) notselected, "FL_FREE_PIXMAP_PIXMAP", "vi" },
-  { (ccallFunction) notselected, "FL_DELETE_OBJECT", "vi" },
-  { (ccallFunction) notselected, "FL_SET_OBJECT_LABEL", "viS" },
-  { (ccallFunction) notselected, "FL_HIDE_OBJECT", "vi" },
-  { (ccallFunction) notselected, "FL_SHOW_OBJECT", "vi" },
-  { (ccallFunction) notselected, "FL_FREEZE_FORM", "vi" },
-  { (ccallFunction) notselected, "FL_UNFREEZE_FORM", "vi" },
-  { (ccallFunction) notselected, "FL_SET_OBJECT_POSITION", "viii" },
-  { (ccallFunction) notselected, "FL_SET_FORM_POSITION", "viii" },
-  { (ccallFunction) notselected, "FL_REDRAW_FORM", "vi" },
-  { (ccallFunction) notselected, "FL_RINGBELL", "v" },
-  { (ccallFunction) notselected, "FL_CREATE_FREE", "iiiiiiS" },
-  { (ccallFunction) notselected, "FL_FREE_FETCH", "iii" },
-  { (ccallFunction) notselected, "FL_FREE_WAIT", "viX" },
-  { (ccallFunction) notselected, "FL_DRAWMODE", "vi" },
-  { (ccallFunction) notselected, "FL_LINE", "viiiii" },
-  { (ccallFunction) notselected, "FL_RECTANGLE", "viiiiii" },
-  { (ccallFunction) notselected, "FL_SET_OBJECT_COLOR", "viii" },
-  { (ccallFunction) notselected, "FL_SET_CLIPPING", "viiii" },
-  { (ccallFunction) notselected, "FL_UNSET_CLIPPING", "v" },
-  { (ccallFunction) notselected, "FL_SET_TEXT_CLIPPING", "viiii" },
-  { (ccallFunction) notselected, "FL_UNSET_TEXT_CLIPPING", "v" },
-  { (ccallFunction) notselected, "FL_ROUNDRECTANGLE", "viiiiii" },
-  { (ccallFunction) notselected, "FL_OVAL", "viiiiii" },
-  { (ccallFunction) notselected, "FL_PIESLICE", "viiiiiiii" },
-  { (ccallFunction) notselected, "FL_ACTIVATE_OBJECT", "vi" },
-  { (ccallFunction) notselected, "FL_DEACTIVATE_OBJECT", "vi" },
-  { (ccallFunction) notselected, "FL_FREE_OBJECT", "vi" },
-  { (ccallFunction) notselected, "FL_FREE_FORM", "vi" },
-  { (ccallFunction) notselected, "FL_DRAW_TEXT", "viiiiiiiiS" },
-  { (ccallFunction) notselected, "FL_SET_OBJECT_LSTYLE", "vii" },
-};
-CCallDescriptor XLIBA_table[] = { 
-  { (ccallFunction) notselected, "XOPENDISPLAY", "is" },
-  { (ccallFunction) notselected, "XCONNECTIONNUMBER", "ii" },
-  { (ccallFunction) notselected, "MTREGISTERFD", "vi" },
-};
-CCallDescriptor XTA_table[] = { 
-  { (ccallFunction) notselected, "XTTOOLKITINITIALIZE", "v" },
-  { (ccallFunction) notselected, "XTCREATEAPPLICATIONCONTEXT", "i" },
-  { (ccallFunction) notselected, "XTOPENDISPLAY", "iiss" },
-  { (ccallFunction) notselected, "XTAPPCREATESHELL", "issiiii" },
-  { (ccallFunction) notselected, "XTMANAGECHILD", "vi" },
-  { (ccallFunction) notselected, "XTREALIZEWIDGET", "vi" },
-  { (ccallFunction) notselected, "XTAPPMAINLOOP", "vi" },
-  { (ccallFunction) notselected, "XTSETLANGUAGEPROC", "v" },
-  { (ccallFunction) notselected, "XTVAAPPINITIALIZE", "is" },
-  { (ccallFunction) notselected, "XTVACREATEMANAGEDWIDGET", "isiisii" },
-  { (ccallFunction) notselected, "XTADDCALLBACK", "visi" },
-  { (ccallFunction) notselected, "XTRETRIEVECALLBACK", "i" },
-  { (ccallFunction) notselected, "MXTSETARGINT", "vii" },
-  { (ccallFunction) notselected, "MXTSETARGSTRING", "vis" },
-  { (ccallFunction) notselected, "MXTCLEARARG", "vi" },
-  { (ccallFunction) notselected, "MXTVACREATEMANAGEDWIDGET", "isiii" },
-};
-CCallDescriptor XMA_table[] = { 
-  { (ccallFunction) notselected, "", "" },
-};
-CCallDescriptor BANI_table[] = { 
-  { (ccallFunction) notselected, "STARTSERVER", "v" },
-  { (ccallFunction) notselected, "STARTCLIENT", "v" },
-  { (ccallFunction) notselected, "CALLSERVER", "iii" },
-  { (ccallFunction) notselected, "INITCLIENT", "iis" },
-  { (ccallFunction) notselected, "INITSERVER", "vi" },
-  { (ccallFunction) notselected, "CALLSERVER2", "iiipi" },
-  { (ccallFunction) notselected, "CHECKWITHSERVER", "bi" },
-  { (ccallFunction) notselected, "SERVERGETSTATUS", "ii" },
-  { (ccallFunction) notselected, "SGETNUMPARAMS", "iii" },
-  { (ccallFunction) notselected, "SGETPARAM", "iiii" },
-  { (ccallFunction) notselected, "RUNCLIENT", "iiipi" },
-  { (ccallFunction) notselected, "CGETNUMPARAMS", "iii" },
-  { (ccallFunction) notselected, "CGETPARAM", "iiii" },
-  { (ccallFunction) notselected, "ASKING", "vs" },
-  { (ccallFunction) notselected, "TESTER", "v" },
-};
-CCallDescriptor MYRISTREAM_table[] = { 
-  { (ccallFunction) notselected, "EMS_OPEN", "ixS" },
-  { (ccallFunction) notselected, "EMS_CLOSE", "vxi" },
-  { (ccallFunction) notselected, "EMS_EOS", "bxi" },
-  { (ccallFunction) notselected, "EMS_ISATTY", "bxi" },
-  { (ccallFunction) notselected, "EMS_GETC", "cxi" },
-  { (ccallFunction) notselected, "EMS_UNGETC", "vxic" },
-  { (ccallFunction) notselected, "EMS_GETS", "Sxi" },
-  { (ccallFunction) notselected, "EMS_FILLV", "ixip" },
-  { (ccallFunction) notselected, "EMS_PUTC", "vxic" },
-  { (ccallFunction) notselected, "EMS_PUTI", "vxiii" },
-  { (ccallFunction) notselected, "EMS_WRITEI", "vxiii" },
-  { (ccallFunction) notselected, "EMS_PUTF", "vxif" },
-  { (ccallFunction) notselected, "EMS_PUTS", "vxip" },
-  { (ccallFunction) notselected, "EMS_FLUSH", "vxi" },
-  { (ccallFunction) notselected, "EMS_BIND", "iS" },
-  { (ccallFunction) notselected, "EMS_ACCEPT", "ii" },
+  { (ccallFunction) opendir, "UOPENDIR", "pS" },
+  { (ccallFunction) mreaddir, "UREADDIR", "sp" },
+  { (ccallFunction) closedir, "UCLOSEDIR", "vp" },
 };
 CCallDescriptor *ccalltable[] = {
   EMSTREAM_table,
   STRING_table,
   RAND_table,
   MISK_table,
-  REGEXP_table,
-  XFORMS_table,
-  XLIBA_table,
-  XTA_table,
-  XMA_table,
-  BANI_table,
-  MYRISTREAM_table,
+  0,
+  0,
+  0,
+  0,
+  0,
+  0,
+  0,
 };
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/cctab.h ubc-latest-src/vm/src/cctab.h
--- ubc-1.05alpha-src/vm/src/cctab.h	2017-12-11 17:59:03.421711955 +0100
+++ ubc-latest-src/vm/src/cctab.h	2017-12-11 17:59:03.483711482 +0100
@@ -49,6 +49,8 @@
 #define EMS_BIND 14
 extern int streamAccept(void);
 #define EMS_ACCEPT 15
+extern int streamRawRead(void);
+#define EMS_RAWREAD 16
 #define STRING 1
 extern int charIsAlpha(void);
 #define EMCH_ISALPHA 0
@@ -96,225 +98,10 @@
 #define UEXIT 0
 extern int mgetenv(void);
 #define UGETENV 1
-#define REGEXP 4
-#define REG_EXEC 0
-#define REG_SUB 1
-#define REG_COMP 2
-#define XFORMS 5
-#define FL_INITIALIZE 0
-#define FL_BGN_FORM 1
-#define FL_END_FORM 2
-#define FL_SHOW_FORM 3
-#define FL_DO_FORMS 4
-#define FL_HIDE_FORM 5
-#define FL_GET_DISPLAY 6
-#define FL_CREATE_BOX 7
-#define FL_CREATE_FRAME 8
-#define FL_CREATE_TEXT 9
-#define FL_CREATE_BITMAP 10
-#define FL_SET_BITMAP_DATA 11
-#define FL_SET_BITMAP_FILE 12
-#define FL_CREATE_CLOCK 13
-#define FL_CREATE_CHART 14
-#define FL_SET_CHART_MAXNUMB 15
-#define FL_CLEAR_CHART 16
-#define FL_ADD_CHART_VALUE 17
-#define FL_INSERT_CHART_VALUE 18
-#define FL_REPLACE_CHART_VALUE 19
-#define FL_SET_CHART_BOUNDS 20
-#define FL_SET_CHART_AUTOSIZE 21
-#define FL_CREATE_BUTTON 22
-#define FL_CREATE_LIGHTBUTTON 23
-#define FL_CREATE_ROUNDBUTTON 24
-#define FL_CREATE_CHECKBUTTON 25
-#define FL_CREATE_BITMAPBUTTON 26
-#define FL_SET_BUTTON 27
-#define FL_GET_BUTTON 28
-#define FL_GET_BUTTON_NUMB 29
-#define FL_SET_BITMAPBUTTON_DATA 30
-#define FL_SET_BITMAPBUTTON_FILE 31
-#define FL_CREATE_SLIDER 32
-#define FL_CREATE_VALSLIDER 33
-#define FL_SET_SLIDER_VALUE 34
-#define FL_GET_SLIDER_VALUE 35
-#define FL_SET_SLIDER_BOUNDS 36
-#define FL_SET_SLIDER_STEP 37
-#define FL_SET_SLIDER_SIZE 38
-#define FL_SET_SLIDER_PRECISION 39
-#define FL_CREATE_DIAL 40
-#define FL_SET_DIAL_VALUE 41
-#define FL_GET_DIAL_VALUE 42
-#define FL_SET_DIAL_BOUNDS 43
-#define FL_SET_DIAL_ANGLES 44
-#define FL_SET_DIAL_CROSS 45
-#define FL_SET_DIAL_STEP 46
-#define FL_CREATE_COUNTER 47
-#define FL_SET_COUNTER_VALUE 48
-#define FL_GET_COUNTER_VALUE 49
-#define FL_SET_COUNTER_BOUNDS 50
-#define FL_SET_COUNTER_STEP 51
-#define FL_SET_COUNTER_PRECISION 52
-#define FL_CREATE_INPUT 53
-#define FL_GET_INPUT 54
-#define FL_SET_INPUT 55
-#define FL_SET_INPUT_SELECTED 56
-#define FL_SET_INPUT_SELECTED_RANGE 57
-#define FL_SET_INPUT_CURSORPOS 58
-#define FL_GET_INPUT_CURSORXPOS 59
-#define FL_SET_INPUT_MAXCHARS 60
-#define FL_SET_INPUT_SCROLL 61
-#define FL_SETPUP_FONTSIZE 62
-#define FL_SETPUP_FONTSTYLE 63
-#define FL_CREATE_MENU 64
-#define FL_GET_MENU 65
-#define FL_GET_MENU_TEXT 66
-#define FL_GET_MENU_ITEM_TEXT 67
-#define FL_GET_MENU_MAXITEMS 68
-#define FL_SET_MENU 69
-#define FL_CLEAR_MENU 70
-#define FL_ADDTO_MENU 71
-#define FL_REPLACE_MENU_ITEM 72
-#define FL_DELETE_MENU_ITEM 73
-#define FL_SET_MENU_ITEM_MODE 74
-#define FL_GET_MENU_ITEM_MODE 75
-#define FL_SHOW_MENU_SYMBOL 76
-#define FL_SET_MENU_POPUP 77
-#define FL_CREATE_CHOICE 78
-#define FL_CLEAR_CHOICE 79
-#define FL_ADDTO_CHOICE 80
-#define FL_DELETE_CHOICE 81
-#define FL_REPLACE_CHOICE 82
-#define FL_GET_CHOICE 83
-#define FL_GET_CHOICE_TEXT 84
-#define FL_GET_CHOICE_ITEM_TEXT 85
-#define FL_GET_CHOICE_MAXITEMS 86
-#define FL_SET_CHOICE 87
-#define FL_SET_CHOICE_TEXT 88
-#define FL_SET_CHOICE_ITEM_MODE 89
-#define FL_SET_CHOICE_ALIGN 90
-#define FL_SET_CHOICE_FONTSIZE 91
-#define FL_SET_CHOICE_FONTSTYLE 92
-#define FL_CREATE_BROWSER 93
-#define FL_CLEAR_BROWSER 94
-#define FL_ADDTO_BROWSER 95
-#define FL_ADD_BROWSER_LINE 96
-#define FL_INSERT_BROWSER_LINE 97
-#define FL_DELETE_BROWSER_LINE 98
-#define FL_REPLACE_BROWSER_LINE 99
-#define FL_GET_BROWSER_LINE 100
-#define FL_SELECT_BROWSER_LINE 101
-#define FL_DESELECT_BROWSER_LINE 102
-#define FL_DESELECT_BROWSER 103
-#define FL_ISSELECTED_BROWSER_LINE 104
-#define FL_GET_BROWSER 105
-#define FL_GET_BROWSER_MAXLINE 106
-#define FL_GET_BROWSER_SCREENLINES 107
-#define FL_GET_BROWSER_TOPLINE 108
-#define FL_SET_BROWSER_TOPLINE 109
-#define FL_SET_BROWSER_XOFFSET 110
-#define FL_SET_BROWSER_FONTSIZE 111
-#define FL_SET_BROWSER_FONTSTYLE 112
-#define FL_CREATE_TIMER 113
-#define FL_SET_TIMER 114
-#define FL_GET_TIMER 115
-#define FL_CREATE_XYPLOT 116
-#define FL_SET_OBJECT_LSIZE 117
-#define FL_SET_FONT 118
-#define FL_SET_OBJECT_RETURN 119
-#define FL_ADD_OBJECT 120
-#define FL_SET_OBJECT_SHORTCUT 121
-#define FL_REDRAW_OBJECT 122
-#define FL_FLUSH 123
-#define FL_GET_STRING_WIDTH 124
-#define FL_SET_OBJECT_BOXTYPE 125
-#define FL_SET_OBJECT_LALIGN 126
-#define FL_CREATE_PIXMAP 127
-#define FL_SET_PIXMAP_FILE 128
-#define FL_SET_PIXMAP_PIXMAP 129
-#define FL_FREE_PIXMAP_PIXMAP 130
-#define FL_DELETE_OBJECT 131
-#define FL_SET_OBJECT_LABEL 132
-#define FL_HIDE_OBJECT 133
-#define FL_SHOW_OBJECT 134
-#define FL_FREEZE_FORM 135
-#define FL_UNFREEZE_FORM 136
-#define FL_SET_OBJECT_POSITION 137
-#define FL_SET_FORM_POSITION 138
-#define FL_REDRAW_FORM 139
-#define FL_RINGBELL 140
-#define FL_CREATE_FREE 141
-#define FL_FREE_FETCH 142
-#define FL_FREE_WAIT 143
-#define FL_DRAWMODE 144
-#define FL_LINE 145
-#define FL_RECTANGLE 146
-#define FL_SET_OBJECT_COLOR 147
-#define FL_SET_CLIPPING 148
-#define FL_UNSET_CLIPPING 149
-#define FL_SET_TEXT_CLIPPING 150
-#define FL_UNSET_TEXT_CLIPPING 151
-#define FL_ROUNDRECTANGLE 152
-#define FL_OVAL 153
-#define FL_PIESLICE 154
-#define FL_ACTIVATE_OBJECT 155
-#define FL_DEACTIVATE_OBJECT 156
-#define FL_FREE_OBJECT 157
-#define FL_FREE_FORM 158
-#define FL_DRAW_TEXT 159
-#define FL_SET_OBJECT_LSTYLE 160
-#define XLIBA 6
-#define XOPENDISPLAY 0
-#define XCONNECTIONNUMBER 1
-#define MTREGISTERFD 2
-#define XTA 7
-#define XTTOOLKITINITIALIZE 0
-#define XTCREATEAPPLICATIONCONTEXT 1
-#define XTOPENDISPLAY 2
-#define XTAPPCREATESHELL 3
-#define XTMANAGECHILD 4
-#define XTREALIZEWIDGET 5
-#define XTAPPMAINLOOP 6
-#define XTSETLANGUAGEPROC 7
-#define XTVAAPPINITIALIZE 8
-#define XTVACREATEMANAGEDWIDGET 9
-#define XTADDCALLBACK 10
-#define XTRETRIEVECALLBACK 11
-#define MXTSETARGINT 12
-#define MXTSETARGSTRING 13
-#define MXTCLEARARG 14
-#define MXTVACREATEMANAGEDWIDGET 15
-#define XMA 8
-#define BANI 9
-#define STARTSERVER 0
-#define STARTCLIENT 1
-#define CALLSERVER 2
-#define INITCLIENT 3
-#define INITSERVER 4
-#define CALLSERVER2 5
-#define CHECKWITHSERVER 6
-#define SERVERGETSTATUS 7
-#define SGETNUMPARAMS 8
-#define SGETPARAM 9
-#define RUNCLIENT 10
-#define CGETNUMPARAMS 11
-#define CGETPARAM 12
-#define ASKING 13
-#define TESTER 14
-#define MYRISTREAM 10
-#define EMS_OPEN 0
-#define EMS_CLOSE 1
-#define EMS_EOS 2
-#define EMS_ISATTY 3
-#define EMS_GETC 4
-#define EMS_UNGETC 5
-#define EMS_GETS 6
-#define EMS_FILLV 7
-#define EMS_PUTC 8
-#define EMS_PUTI 9
-#define EMS_WRITEI 10
-#define EMS_PUTF 11
-#define EMS_PUTS 12
-#define EMS_FLUSH 13
-#define EMS_BIND 14
-#define EMS_ACCEPT 15
+extern int opendir(void);
+#define UOPENDIR 2
+extern int mreaddir(void);
+#define UREADDIR 3
+extern int closedir(void);
+#define UCLOSEDIR 4
 #endif
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/creation.c ubc-latest-src/vm/src/creation.c
--- ubc-1.05alpha-src/vm/src/creation.c	2017-12-11 17:59:03.421711955 +0100
+++ ubc-latest-src/vm/src/creation.c	2017-12-11 17:59:03.483711482 +0100
@@ -144,6 +144,7 @@
   state->op = o;
   state->sb = (int)vmMalloc(stackSize);
   state->sp = state->sb;
+  state->opp = (OpVectorElement)JNIL;
   state->ep = (Object) JNIL;
   state->et = (ConcreteType) JNIL;
   state->nstoid = nooid;
@@ -189,6 +190,7 @@
   state->op = o;
   state->sb = (int)vmMalloc(stackSize);
   state->sp = state->sb;
+  state->opp = (OpVectorElement)JNIL;
   state->ep = (Object) JNIL;
   state->et = (ConcreteType) JNIL;
 }
@@ -214,6 +216,7 @@
   state = newState(o, ct);
 
   ope = ct->d.opVector->d.data[index];
+  state->opp = ope;
   state->ep = (Object) JNIL; state->et = (ConcreteType) JNIL;
   state->pc = (int)ope->d.code->d.data;
 
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/debug.c ubc-latest-src/vm/src/debug.c
--- ubc-1.05alpha-src/vm/src/debug.c	2017-12-11 17:59:03.421711955 +0100
+++ ubc-latest-src/vm/src/debug.c	2017-12-11 17:59:03.484711475 +0100
@@ -458,6 +458,8 @@
   if (vector) fprintf(stderr, " }");
 }
 
+extern int inHeap(unsigned int x);
+
 void displayX(int n, int *x, int vector)
 {
   if (vector) fprintf(stderr, "{ ");
@@ -466,9 +468,13 @@
       fprintf(stderr, "nil");
     } else if (*x == -1) {
       fprintf(stderr, "minus 1!");
+    } else if (!inHeap(*x)) {
+      fprintf(stderr, "non-heap pointer: %08x", *x);
     } else {
+      fprintf(stderr, "<%#x, ", *x);
       ConcreteType cp = CODEPTR(((Object)*x)->flags);
-      fprintf(stderr, "%#x %.*s", *x,
+      fprintf(stderr, "%#x>", (unsigned int)cp);
+      fprintf(stderr, " %.*s",
 	      cp->d.name->d.items, 
 	      (char *)cp->d.name->d.data);
       if (cp == BuiltinInstCT(STRINGI)) {
@@ -493,8 +499,13 @@
     fprintf(stderr, "nil");
   } else if (o == (Object)-1) {
     fprintf(stderr, "minus 1!");
+  } else if (!inHeap((unsigned int)o)) {
+    fprintf(stderr, "non-heap pointer: %08x", (unsigned int)o);
+  } else if (!inHeap((unsigned int)cp)) {
+    fprintf(stderr, "non-heap ct pointer: %08x", (unsigned int)cp);
   } else {
-    fprintf(stderr, "<%#x, %#x> %s%.*s", (int)o, (int)cp,
+    fprintf(stderr, "<%#x, %#x>", (int)o, (int)cp);
+    fprintf(stderr, " %s%.*s",
 	    HASODP(cp->d.instanceFlags) ? (RESDNT(o->flags) ? "" : "remote ") : "", 
 	    cp->d.name->d.items,
 	    (char *)cp->d.name->d.data);
@@ -772,6 +783,25 @@
 	  fprintf(stderr, "  locals:\n");
 	  dump(theTemplate, lstate.fp);
 	}
+	{
+	  unsigned int base = lstate.fp ? lstate.fp : lstate.sb;
+	  base += sizeFromTemplate(theTemplate);
+	  unsigned int ptr = base;
+	  if (ptr < lstate.sp) {
+	    /*
+	     * There is memory left over here that I don't have a template
+	     * for, let's at least document it.
+	     */
+	    while (ptr < lstate.sp) {
+	      char crap[32];
+	      sprintf(crap, "[extra +%3d]", ptr - base);
+	      printName(crap);
+	      displayX(1, (int *)ptr, 0);
+	      fprintf(stderr, "\n");
+	      ptr += 4;
+	    }
+	  }
+	}
       }
     }
   } while (unwind(&lstate) && --limit > 0);
@@ -1103,7 +1133,7 @@
   int stacklevel = 0;
   lstate = *state;
   do {
-    fprintf(stderr, "edb> ");
+    fprintf(stderr, "edb> "); fflush(stderr);
     {
       char *streamGetString( int *fail, int fd );
       int streamEos( int *fail, int fd );
@@ -1147,7 +1177,7 @@
 	tstate = temp;
 	lstate = *tstate;
 	stacklevel = 0;
-	summary(&lstate, S_PRINT);
+	summary(&lstate, S_PRINT + S_UPDATE);
       } else {
 	fprintf(stderr, "No such process (only %d exist)\n",
 		ISetSize(allProcesses));
@@ -1170,7 +1200,7 @@
     } else if (samestring(command, "up")) {
       if (unwind(&lstate)) {
 	stacklevel ++;
-	summary(&lstate, S_PRINT);
+	summary(&lstate, S_PRINT + S_UPDATE);
       } else {
 	fprintf(stderr, "Can't do up (at the top of the stack)\n");
       }
@@ -1186,7 +1216,7 @@
 	    fprintf(stderr, "Oops - couldn't unwind when I should have\n");
 	  }
 	}
-	summary(&lstate, S_PRINT);
+	summary(&lstate, S_PRINT + S_UPDATE);
       }
     } else if (samestring(command, "look") || samestring(command, "info")) {
       wherecommand(&lstate, 1, 1);
@@ -1270,6 +1300,11 @@
   return NULL;
 }
 
+void showProcess(State *state, int levelOfDetail)
+{
+  wherecommand(state, levelOfDetail, 9999999);
+}
+
 void showAllProcesses(State *state, int levelOfDetail)
 {
   State lstate, *statep, *nstate;
@@ -1296,12 +1331,13 @@
     if (statep != state) {
       fprintf(stderr, "Process %d %#x %s", current, (unsigned int)statep,
 	      isReady(statep) ? "ready" : "not ready");
-      if (!isNoOID(statep->nsoid)) 
+      if (!isNoOID(statep->nsoid)) {
 	if (ISNIL(nstate = (State *)OIDFetch(statep->nsoid))) {
 	  fprintf(stderr, " waiting some state");
 	} else {
 	  fprintf(stderr, " waiting on state %#x", (unsigned int)nstate);
 	}
+      }
       fprintf(stderr, "\n");
       lstate = *statep;
       if (levelOfDetail > 0) {
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/dist.c ubc-latest-src/vm/src/dist.c
--- ubc-1.05alpha-src/vm/src/dist.c	2017-12-11 17:59:03.421711955 +0100
+++ ubc-latest-src/vm/src/dist.c	2017-12-11 17:59:03.484711475 +0100
@@ -15,6 +15,7 @@
 #include "types.h"
 #include "mqueue.h"
 #include "storage.h"
+#include "misc.h"
 
 Node myid;
 
@@ -177,6 +178,42 @@
 #endif
 }
 
+static char *formatIPAddress(Bits32 addr, char *buffer)
+{
+	sprintf(buffer, "%d.%d.%d.%d",
+			(addr & 0xff000000) >> 24, (addr & 0x00ff0000) >> 16,
+			(addr & 0x0000ff00) >> 8, (addr & 0x000000ff));
+	return buffer;
+}
+
+static int isLocalAddress(Bits32 addr)
+{
+	return ((addr & 0xff000000) == 0x7f000000);
+}
+
+static void checkForStrangeness()
+{
+	int i, prev = -1;
+	TRACE(dist, 7, ("  Looking for strangeness"));
+	for (i = 0; i < nothers; i++) {
+		TRACE(dist, 8, ("  Looking at %#x.%4x %d %s", ntohl(others[i].id.ipaddress), others[i].id.port, others[i].s, isLocalAddress(ntohl(others[i].id.ipaddress)) ? "Local" : "Not local"));
+		if (!isLocalAddress(ntohl(others[i].id.ipaddress))) {
+			if (prev != -1 && others[prev].s == others[i].s && others[prev].id.ipaddress != others[i].id.ipaddress) {
+				char b1[32], b2[32];
+				/* Strangeness */
+				TRACE(dist, 9, ("Strange, others[%d] = %#x %d", prev, ntohl(others[prev].id.ipaddress), others[prev].s));
+				TRACE(dist, 9, ("Strange, others[%d] = %#x %d", i, ntohl(others[i].id.ipaddress), others[i].s));
+				printf("Found two different addresses for a node (%s and %s)\n",
+					   formatIPAddress(ntohl(others[prev].id.ipaddress), b1),
+					   formatIPAddress(ntohl(others[i].id.ipaddress), b2));
+				printf("This node probably has a non-working but enabled network interface\n");
+				printf("Emerald doesn't deal well with this\n");
+			}
+			prev = i;
+		}
+	}
+}
+
 int findsocket(Node *t, int create)
 {
   int i, addrlen, s, pos;
@@ -280,6 +317,7 @@
     TRACE(dist, 9, ("Inserting %#x.%d -> %d in others[%d]", ntohl(cache.id.ipaddress), cache.id.port, cache.s, nothers));
     others[nothers++] = cache;
   }
+  checkForStrangeness();
   return cache.s;
 }
 
@@ -380,6 +418,7 @@
     setupReader(ls->ri);
     if (notifyFunction) callNotifyFunction(ls->ri->id, 1);
   }
+  checkForStrangeness();
   vmFree((char *)ls);
 }
 
@@ -390,6 +429,7 @@
   int addrlen = sizeof(addr), on = 1;
   ListenerState *ls = (ListenerState *)vmMalloc(sizeof(*ls));
 
+  TRACE(dist, 1, ("ListenerCB on %d", sock));
   newsocket = accept(sock, (struct sockaddr *)&addr, &addrlen);
   if (newsocket < 0) return;
   if (setsockopt(newsocket, IPPROTO_TCP, TCP_NODELAY, (char *)&on, sizeof (on)) < 0) {
@@ -411,6 +451,7 @@
   ls->nbo.port = htons(myid.port);
   ls->nbo.epoch = htons(myid.epoch);
   ls->nbo.userid = htonl(getuid());
+  checkForStrangeness();
   if (send(ls->ri->s, (char *)&ls->nbo, sizeof(ls->nbo), 0) != sizeof(ls->nbo)) {
     nukeother(*ls->ri);
     closesocket(ls->ri->s);
@@ -463,9 +504,8 @@
     return -1;
   }
   if (setsockopt(mysocket, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof (on)) < 0) {
-    closesocket(mysocket);
-    perror("setsockopt");
-    return -1;
+	  /* This is not a big deal, ignore it */
+	  TRACE(dist, 1, ("Failed to set SO_REUSEADDR socket option"));
   }
   /*
    * Originally we did this all the time on not windows
@@ -560,14 +600,14 @@
 
 void establishHandler(int sig, void (*handler)(int))
 {
-#if defined(__svr4__) || defined(__SYSTYPE_SVR4__)
+#if defined(__svr4__) || defined(__SYSTYPE_SVR4__) || defined(CYGWIN)
   struct sigaction action;
 
   memset(&action, 0, sizeof(action));
   action.sa_handler = handler;
   sigaction(sig, &action, NULL);
 #else
-#ifdef WIN32
+#if defined(WIN32) || defined(DOS)
   signal(sig, handler);
 #else
   struct sigvec vec;
@@ -608,21 +648,32 @@
   return rval;
 }
 
+int getplane()
+{
+  int port = 0;
+  extern int offsetbyuserid;
+  char *plane = getenv("EMPLANE");
+  if (plane) {
+    port += mstrtol(plane, 0, 10);
+  } else if (offsetbyuserid) {
+    port += getuid() % EMERALDPORTSKIP;
+  }
+  return port;
+}
+
+
 int InitDist()
 {
   extern Node MyNode;
   extern OID MyBaseOID;
   int port;
-  char *plane;
   extern char *getenv(const char *);
 
   InitStorage();
 
   MyNode.epoch = random() & 0xffff;
   /* start up the network subsystem */
-  port = EMERALDFIRSTPORT;
-  plane = getenv("EMPLANE");
-  if (plane) port += mstrtol(plane, 0, 10);
+  port = EMERALDFIRSTPORT + getplane();
   
 #ifdef DISTRIBUTED
   while (DNetStart(0,  port, MyNode.epoch) != 0) {
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/distgc.c ubc-latest-src/vm/src/distgc.c
--- ubc-1.05alpha-src/vm/src/distgc.c	2017-12-11 17:59:03.421711955 +0100
+++ ubc-latest-src/vm/src/distgc.c	2017-12-11 17:59:03.484711475 +0100
@@ -243,6 +243,7 @@
   OID oid;
   Object o;
   int marked = 0, markedstates = 0, unmarkedstates = 0, removed = 0, notremoved = 0;
+  extern int nDGCremoved;
   if (whichgc == lastCompletedDistGCSeq) {
     TRACE(distgc, 3, ("Extraneous finish distgc"));
     return;
@@ -295,6 +296,7 @@
       marked++;
     }
   } OTableNext();
+  nDGCremoved += removed;
   TRACE(distgc, 2, ("Dist GC %d: finished cleaning object table", distGCSeq));
   TRACE(distgc, 2, ("%d marked states, %d unmarked states, %d marked, %d removed, %d notremoved",
 		    markedstates, unmarkedstates, marked, removed, notremoved));
@@ -338,6 +340,8 @@
 {
   if (inDistGC()) return;
   assert(!remotegreys);
+  extern int nDGCs;
+  nDGCs ++;
   remotegreys = ISetCreate();
   interestingblacks = ISetCreate();
   stage = dgcWorking;
@@ -737,7 +741,7 @@
 {
   Object o;
   OID oid;
-  TRACE(distgc, 4, ("DistGCInfo %s received from %s",
+  TRACE(distgc, 3, ("DistGCInfo %s received from %s",
 		    h->option1 ? "black" : "grey", NodeString(srv)));
   if (!inDistGC())
     startDistGC();
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/dist.h ubc-latest-src/vm/src/dist.h
--- ubc-1.05alpha-src/vm/src/dist.h	2017-12-11 17:59:03.421711955 +0100
+++ ubc-latest-src/vm/src/dist.h	2017-12-11 17:59:03.484711475 +0100
@@ -14,7 +14,7 @@
 #endif
 
 #define EMERALDFIRSTPORT 0x3ee3
-#define EMERALDPORTSKIP 0x100
+#define EMERALDPORTSKIP 0x400
 #define EMERALDPORTPROBE(n) ((n) + EMERALDPORTSKIP)
 
 char *NodeString(Node);
@@ -26,6 +26,7 @@
 extern void DInit(void);
 void DStart(void);
 
+extern int getplane(void);
 int DNetStart(unsigned int, unsigned short, unsigned short);
 int DSend(Node receiver, void *sbuf, int slen);
 int DProd(Node *receiver);
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/gaggle.c ubc-latest-src/vm/src/gaggle.c
--- ubc-1.05alpha-src/vm/src/gaggle.c	2017-12-11 17:59:03.425711924 +0100
+++ ubc-latest-src/vm/src/gaggle.c	2017-12-11 17:59:03.488711444 +0100
@@ -235,6 +235,12 @@
 
   value = (gtypeptr) OIScLookup(gaggleTable, goid);
   tonuke = 0;
+  if (!value) {
+    TRACE(gaggle, 0, ("Removing %s from unknown gaggle %s", OIDString(deadMember),
+		      OIDString(goid)));
+    return;
+  }
+
   if (sameOID(value->gmember, deadMember)) {
     tonuke = value;
     OIScInsert(gaggleTable, goid, (int)value->next);
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/gc.c ubc-latest-src/vm/src/gc.c
--- ubc-1.05alpha-src/vm/src/gc.c	2017-12-11 17:59:03.425711924 +0100
+++ ubc-latest-src/vm/src/gc.c	2017-12-11 17:59:03.488711444 +0100
@@ -109,6 +109,8 @@
 int move_stack_size = 0;
 static int total_gc_time, old_gc_time;
 static int nGCs, nOGCs;
+int nDGCs, nDGCremoved;
+
 
 static word *survivors_start, *survivors_end;
 
@@ -129,10 +131,20 @@
 
 static inline void forward(Object o, Object new)
 {
+  OID oid;
   TRACE(memory, 5, ("Forwarding %#x to %#x", o, new));
   new->flags = o->flags;
-  o->flags = (int)new | 1;
-  assert((HASOID(new->flags) && 1) == (!isNoOID(OIDOf(o))));
+  o->flags = (unsigned int)new | 1;
+  oid = OIDOf(o);
+  if ((HASOID(new->flags) && 1) != !isNoOID(oid)) {
+    TRACE(memory, 0, ("Object %#x has oid %s, HASOID == %s", o, OIDString(oid),
+		      HASOID(new->flags) ? "true" : "false"));
+    if (isNoOID(oid)) {
+      CLEARHASOID(new->flags);
+    } else {
+      SETHASOID(new->flags);
+    }
+  }
   if (HASOID(new->flags)) UpdateObjectLocation(o, new);
 }
 
@@ -196,12 +208,14 @@
   return (Object) new_addr;
 }
 
-void gc_stats (int *tg, int *og, int *n, int *no)
+void gc_stats (int *tg, int *og, int *n, int *no, int *nd, int *ndr)
 {
   *tg = total_gc_time;
   *og = old_gc_time;
   *n = nGCs;
   *no = nOGCs;
+  *nd = nDGCs;
+  *ndr = nDGCremoved;
 }
 
 #ifndef NDEBUG
@@ -802,6 +816,30 @@
 static int total_stores, total_interesting_stores;
 extern void gcollect_old(void);
 
+static int needDistGC(void)
+{
+  /*
+   * Think about starting a distGC if the fraction of free space is small
+   * (how small?) and the number of objects with OIDs is large (how
+   * large?).  The current settings of these two parameters is entirely a
+   * guess.
+   */
+#define DISTGCPERCENTTHRESHOLD 25
+#define DISTGCGLOBALOBJECTTHRESHOLD 10000
+  if (!inDistGC()) {
+    int freepercent = (old_end - nextGen) * 100 / (old_end - old_start);
+    if (freepercent < DISTGCPERCENTTHRESHOLD) {
+      TRACE(distgc, 2, ("Starting distgc, free memory = %d", freepercent));
+      return 1;
+    } else if (OTableSize(ObjectTable) > DISTGCGLOBALOBJECTTHRESHOLD) {
+      TRACE(distgc, 2, ("Starting distgc, objects with oids = %d",
+			OTableSize(ObjectTable)));
+      return 1;
+    }
+  }
+  return 0;
+}    
+
 void gcollect(void)
 {
   int start_time;
@@ -850,10 +888,10 @@
   total_gc_time += (done_time - start_time);
 
   TRACE(memory, 3, ("Old = %d words, new = %d words, promo = %d words", 
-		    ((int)nextGen - (int)old_start) / sizeof(int),
+		    ((unsigned int)nextGen - (unsigned int)old_start) / sizeof(int),
 		    (allocatingForward ? 
-		     (int)fromSpace - (int)new_start :
-		     (int)new_end - (int)fromSpace) / sizeof(int),
+		     (unsigned int)fromSpace - (unsigned int)new_start :
+		     (unsigned int)new_end - (unsigned int)fromSpace) / sizeof(int),
 		    wordsToBePromotedNextGC));
   TRACE(memory, 4, ("Total stores so far = %d, %d interesting", 
 		    total_stores, total_interesting_stores));
@@ -861,7 +899,7 @@
     TRACE(memory, 0, ("old_end = %#x, next_gen = %#x, diff = %d, promo = %d\n",
 		      old_end, nextGen, old_end - nextGen,
 		      wordsToBePromotedNextGC));
-    TRACE(memory, 0, ("Out of memory.  Try including the flag -O%dk on the command line!", old_size/1024 + 256));
+    fprintf(stderr, "Out of memory.  Try including the flag -O%dk on the command line!\n", old_size/1024 + 256);
     abort();
   }
 
@@ -893,6 +931,24 @@
   inhibit_gc++;
 }
 
+void ensureSpace(int bytes)
+{
+  assert(!inhibit_gc);
+  while (wordsLeftInThisGeneration * 4 < bytes) {
+    gcollect();
+  }
+
+  if (old_end - nextGen - wordsToBePromotedNextGC < BYTES_TO_WORDS(bytes))
+    gcollect();
+
+  /*
+   * Since the call to gcollect can sometimes call gcollect_old, then we
+   * only need to call it again if it is really necessary.
+   */
+  if (old_end - nextGen - wordsToBePromotedNextGC < BYTES_TO_WORDS(bytes))
+    gcollect_old();
+}
+
 /* allocate lb bytes of data in the old generation */
 void *gc_malloc_old (int lb, int remember)
 {
@@ -906,7 +962,7 @@
       TRACE(memory, 0, ("old_end = %#x, next_gen = %#x, diff = %d, promo = %d\n",
 			old_end, nextGen, old_end - nextGen,
 			wordsToBePromotedNextGC));
-      TRACE(memory, 0, ("Out of memory.  Try including the flag -O%dk on the command line!", old_size/1024 + 256));
+      fprintf(stderr, "Out of memory.  Try including the flag -O%dk on the command line!\n", old_size/1024 + 256);
       abort();
     } else {
       gcollect();
@@ -915,7 +971,7 @@
 	TRACE(memory, 0, ("old_end = %#x, next_gen = %#x, diff = %d, promo = %d\n",
 			  old_end, nextGen, old_end - nextGen,
 			  wordsToBePromotedNextGC));
-	TRACE(memory, 0, ("Out of memory.  Try including the flag -O%dk on the command line!", old_size/1024 + 256));
+	fprintf(stderr, "Out of memory.  Try including the flag -O%dk on the command line!\n", old_size/1024 + 256);
 	abort();
       }
     }
@@ -962,6 +1018,12 @@
   return op;
 }
 
+int inHeap(unsigned int x)
+{
+    return ((old_start <= (word *)x && (word *)x < old_end) ||
+	    (new_lb <= (word *)x && (word *)x < new_ub));
+}
+
 void gc_init (void (*b)(void), void (*d)(void), void (*a)(void), void (*e)(void))
 {
   _gc_b = b;
@@ -976,7 +1038,7 @@
     old_size = p_old_size;
     guaranteeInterGcInterval = p_guaranteeInterGcInterval;
     if (copyCount > 2) {
-      TRACE(memory, 0, ("Copy count of > 2 are not supported: %d", copyCount));
+      fprintf(stderr, "Copy counts of > 2 are not supported: %d\n", copyCount);
       copyCount = 2;
     }
     nbytes = copyCount * (copyCount == 1?1:2) * bytesPerGeneration;
@@ -987,22 +1049,7 @@
     old_end = old_start + (old_size / sizeof(word));
     new_lb = new_start;
     new_ub = new_end;
-    if (((int)old_start & CODEPTREXTRA) != CODEPTREXTRA) {
-      TRACE(memory, 0, ("EXTRA: old_start = %#x", (unsigned int)old_start));
-      abort();
-    }
-    if (((int)new_start & CODEPTREXTRA) != CODEPTREXTRA) {
-      TRACE(memory, 0, ("EXTRA: new_start = %#x", (unsigned int)new_start));
-      abort();
-    }
-    if ((((int)old_start & ~ALLBITS) | CODEPTREXTRA) != (int)old_start) {
-      TRACE(memory, 0, ("BITS: old_start = %#x", (unsigned int)old_start));
-      abort();
-    }
-    if ((((int)new_start & ~ALLBITS) | CODEPTREXTRA) != (int)new_start) {
-      TRACE(memory, 0, ("BITS: new_start = %#x", (unsigned int)new_start));
-      abort();
-    }
+    codeptrextra = (unsigned int)old_start & ALLBITS;
       
     wordsPerGeneration = bytesPerGeneration / sizeof(word);
     wordsLeftInThisGeneration = 
@@ -1010,6 +1057,8 @@
 	bytesPerGeneration / sizeof(word) :
 	(new_end - new_start + wordsToBePromotedNextGC) / (copyCount==1?1:2)
 	  - liveWords();
+	TRACE(memory, 1, ("old = [%#x - %#x], new = [%#x - %#x]",
+					  old_start, old_end, new_start, new_end));
   }
 }
 
@@ -1447,7 +1496,7 @@
 {
   int count = 0;
 
-  while ((int)o > 0) {
+  while (!IIXScIsNIL(o)) {
     count ++;
     o = (Object)o->flags;
   }
@@ -1533,7 +1582,7 @@
     } else {
       int size = sizeOf(o);
       new = (Object)IIXScLookup(freeLists, size);
-      assert((int)new > 0);
+      assert(!IIXScIsNIL(new));
       IIXScInsert(freeLists, size, new->flags);
       forward(o, new);
     }
@@ -1586,7 +1635,9 @@
 void findBoundary(void)
 {
   Object o, hole = 0, guess, holes = 0, lasto;
+#if !defined(NDEBUG)
   Object to = (Object)nextGen;
+#endif
   int holeSize = 0, size, left;
 #define RECORDHOLESIZE(hole, size) IIScInsert(holeSizes, (int)hole, size)
 #define GETHOLESIZE(hole) IIScLookup(holeSizes, (int)hole)
@@ -1680,7 +1731,7 @@
       if (IIXScBumpBy(liveSizes, size, -1) < 0) {
 	Object freeChunk = (Object)IIXScLookup(freeLists, size);
 	int tSize = size;
-	assert((int)freeChunk > 0);
+	assert(!IIXScIsNIL(freeChunk));
 	TRACE(memory, 9, ("Re-allocating a free chunk of size %d at 0x%x",
 			  size, freeChunk));
 	IIXScInsert(freeLists, size, freeChunk->flags);
@@ -1733,7 +1784,7 @@
       size = sizeOf(o);
       if (marked(o)) {
 	new = (Object)IIXScLookup(freeLists, size);
-	assert((int)new > 0);
+	assert(!IIXScIsNIL(new));
 	TRACE(memory, 5, ("Finding a new location for 0x%x at 0x%x", o, new));
 	IIXScInsert(freeLists, size, new->flags);
 	checkAsOnFreeList(new, size);
@@ -1742,7 +1793,7 @@
 	(void)move_fields(o, new, checkAndFindNew_old);
 	clearMark(new);
       } else {
-	TRACE(memory, 5, ("Object at 0x%x is not reachable", o));
+	TRACE(memory, 9, ("Object at 0x%x is not reachable", o));
 	/* do nothing, the object isn't reachable */
       }
     }
@@ -1895,17 +1946,7 @@
   IIXScDestroy(freeLists);
   done_time = currentCpuTime();
   old_gc_time += (done_time - start_time);
-  /*
-   * Think about starting a distGC if the fraction of free space is small
-   * (how small?) and the number of objects with OIDs is large (how
-   * large?).  The current settings of these two parameters is entirely a
-   * guess.
-   */
-#define DISTGCPERCENTTHRESHOLD 25
-#define DISTGCGLOBALOBJECTTHRESHOLD 15000
-  if (!inDistGC() &&
-      ((old_end - nextGen) * 100 / (old_end - old_start) < DISTGCPERCENTTHRESHOLD ||
-       (OTableSize(ObjectTable) > DISTGCGLOBALOBJECTTHRESHOLD))) {
+  if (needDistGC()) {
     startDistGC();
   }
 }
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/gc.h ubc-latest-src/vm/src/gc.h
--- ubc-1.05alpha-src/vm/src/gc.h	2017-12-11 17:59:03.425711924 +0100
+++ ubc-latest-src/vm/src/gc.h	2017-12-11 17:59:03.488711444 +0100
@@ -58,6 +58,7 @@
 extern Object createStub(ConcreteType ct, void *stub, OID oid);
 
 extern int inhibit_gc;
+extern void ensureSpace(int howmanybytes);
 extern void anticipateGC(int howmanybytes);
 extern void new_rem_set(Object);
 extern void recordSize(Object, int);
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/globals.c ubc-latest-src/vm/src/globals.c
--- ubc-1.05alpha-src/vm/src/globals.c	2017-12-11 17:59:03.425711924 +0100
+++ ubc-latest-src/vm/src/globals.c	2017-12-11 17:59:03.488711444 +0100
@@ -15,6 +15,7 @@
   return 1;
 }
 
+int codeptrextra;
 Object BuiltinGlobalArray[NUMBUILTINS][NUMTAGS];
 int totalbytecodes;
 String TrueString, FalseString;
@@ -59,7 +60,9 @@
        junfix,
        jrefix,
        jlocate,
-       jisfixed
+       jisfixed,
+       jgetIncarnationTime,
+       jgetLoadAverage
      };
 
 void initGlobals()
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/globals.h ubc-latest-src/vm/src/globals.h
--- ubc-1.05alpha-src/vm/src/globals.h	2017-12-11 17:59:03.425711924 +0100
+++ ubc-latest-src/vm/src/globals.h	2017-12-11 17:59:03.488711444 +0100
@@ -51,7 +51,9 @@
 	jfix(struct State *),
 	junfix(struct State *),
 	jrefix(struct State *),
-	jlocate(struct State *);
+	jlocate(struct State *),
+	jgetIncarnationTime(struct State *),
+	jgetLoadAverage(struct State *);
 
 extern int (*(sysfuncs[]))(struct State *),
 	(*(xfuncs[]))(int *);
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/iixsc.h ubc-latest-src/vm/src/iixsc.h
--- ubc-1.05alpha-src/vm/src/iixsc.h	2017-12-11 17:59:03.426711917 +0100
+++ ubc-latest-src/vm/src/iixsc.h	2017-12-11 17:59:03.488711444 +0100
@@ -5,6 +5,8 @@
 #define _EMERALD_IIXSC_H
 
 #include "iisc.h"
+#define IIXScNIL IIScNIL
+#define IIXScIsNIL(x) IIScIsNIL(x)
 
 #define SMALLONES (2 * 1024 + 3)
 
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/io.c ubc-latest-src/vm/src/io.c
--- ubc-1.05alpha-src/vm/src/io.c	2017-12-11 17:59:03.426711917 +0100
+++ ubc-latest-src/vm/src/io.c	2017-12-11 17:59:03.488711444 +0100
@@ -11,11 +11,13 @@
 #include "timer.h"
 #include "trace.h"
 
+#if !defined(NTRACE)
 static char *EIONames[] = {
   "EIO_Read",
   "EIO_Write",
   "EIO_Except"
 };
+#endif
 
 static fd_set io_sets[3];
 static fd_set data_available;
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/jsys.c ubc-latest-src/vm/src/jsys.c
--- ubc-1.05alpha-src/vm/src/jsys.c	2017-12-11 17:59:03.426711917 +0100
+++ ubc-latest-src/vm/src/jsys.c	2017-12-11 17:59:03.489711436 +0100
@@ -29,6 +29,12 @@
  * Here is our lnn, whatever inet_lnaof returns
  */
 static int syslnn = -1;
+
+/*
+ * Our incarnation time is created in remote.c:init_nodeinfo.
+ */
+extern Object inctm;
+
 /*
  * Here are pointers to our standard input and output streams
  */
@@ -74,10 +80,32 @@
 
 int getname(State *state)
 {
+  TRACE(sys, 1, ("getname returns %.*s", SysName->d.items, SysName->d.data));
   PUSH(String, SysName);
   return 0;
 }
 
+int jgetIncarnationTime(State *state)
+{
+  PUSH(Object, inctm);
+  return 0;
+}
+
+int jgetLoadAverage(State *state)
+{
+  double avg = 1.0;
+  int ret;
+#if defined(i386freebsd)
+  ret = getloadavg(&avg, 1);
+  if (ret < 1) {
+    TRACE(sys, 0, ("getloadavg failed, ret %d", ret));
+    avg = 1.0;
+  }
+#endif
+  PUSH(float, (float) avg);
+  return 0;
+}
+
 int jisfixed(State *state)
 {
   ConcreteType ct;
@@ -162,7 +190,7 @@
 int jfix(State *state)
 {
   ConcreteType ct, d_ct;
-  Object obj, d, dn;
+  Object obj, d;
   int retc = 0;
 
   obj = *(Object *)sp;
@@ -175,7 +203,7 @@
   if (ISNIL(obj) || !HASODP(ct->d.instanceFlags) || ISIMUT(ct->d.instanceFlags)) {
     /* do nothing */
   } else {
-    dn = whereIs(d, d_ct);
+    Object dn = whereIs(d, d_ct);
     if (ISNIL(dn)) {
       return unavailable(state, d);
     } else if (RESDNT(dn->flags) && RESDNT(obj->flags)) {
@@ -192,7 +220,7 @@
 int jrefix(State *state)
 {
   ConcreteType ct, d_ct;
-  Object obj, d, dn;
+  Object obj, d;
   int retc = 0;
 
   obj = *(Object *)sp;
@@ -205,7 +233,7 @@
   if (ISNIL(obj) || !HASODP(ct->d.instanceFlags) || ISIMUT(ct->d.instanceFlags)) {
     /* do nothing */
   } else {
-    dn = whereIs(d, d_ct);
+    Object dn = whereIs(d, d_ct);
     if (ISNIL(dn)) {
       return unavailable(state, d);
     } else if (RESDNT(dn->flags) && RESDNT(obj->flags)) {
@@ -241,7 +269,7 @@
 int jmove(State *state)
 {
   ConcreteType ct, d_ct;
-  Object obj, d, dn;
+  Object obj, d;
   int retc = 0;
 
   obj = *(Object *)sp;
@@ -253,7 +281,7 @@
   if (ISNIL(obj) || !HASODP(ct->d.instanceFlags) || ISIMUT(ct->d.instanceFlags)) {
     /* do nothing */
   } else {
-    dn = whereIs(d, d_ct);
+    Object dn = whereIs(d, d_ct);
     if (ISNIL(dn)) {
       return unavailable(state, d);
     } else if (RESDNT(dn->flags) && RESDNT(obj->flags)) {
@@ -326,7 +354,7 @@
 
 #if !defined(WIN32)
   if (gethostname(name, sizeof name) < 0) {
-    TRACE(dist, 0, ("Can't get my own host name, making one up"));
+    fprintf(stderr, "Can't get my own host name, making one up\n");
     strcpy(name, "imaginary");
   }
 
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/jsys.h ubc-latest-src/vm/src/jsys.h
--- ubc-1.05alpha-src/vm/src/jsys.h	2017-12-11 17:59:03.426711917 +0100
+++ ubc-latest-src/vm/src/jsys.h	2017-12-11 17:59:03.489711436 +0100
@@ -37,4 +37,6 @@
 #define JREFIX 36
 #define JLOCATE 37
 #define ISFIXED 38
-#define JSYS_OPS 39
+#define JGETINCARNATIONTIME 39
+#define JGETLOADAVERAGE 40
+#define JSYS_OPS 41
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/locate.c ubc-latest-src/vm/src/locate.c
--- ubc-1.05alpha-src/vm/src/locate.c	2017-12-11 17:59:03.426711917 +0100
+++ ubc-latest-src/vm/src/locate.c	2017-12-11 17:59:03.489711436 +0100
@@ -112,7 +112,9 @@
     } else if (SameNode(srv, limbo)) {
       sendUnavailableReply(str);
     } else {
-      sendMsg(srv, str);
+	if (sendMsg(srv, str) < 0) {
+	    TRACE(locate, 1, ("locationResolved:  can't send reply"));
+	};
     }
   } ISetNext();
   ISetDestroy(l->waitingMsgs);
@@ -301,7 +303,9 @@
     replyh.kind = LocateReply;
     replyh.status = 0;		/* Found it here */
     reply = StartMsg(&replyh);
-    sendMsg(h->sslocation, reply);
+    if (sendMsg(h->sslocation, reply) < 0) {
+	TRACE(locate, 1, ("handleLocationRequest: can't send found it here reply"));
+    }
   } else if (h->option1 == 0) {
     /* Forwarding is allowed */
     if (ISNIL(obj) || SameNode(loc, limbo) || SameNode(loc, srv) || forwardMsg(loc, h, str) < 0) {
@@ -310,11 +314,13 @@
       replyh.kind = LocateReply;
       replyh.status = 1;	/* Not found */
       reply = StartMsg(&replyh);
-      sendMsg(h->sslocation, reply);
+      if (sendMsg(h->sslocation, reply) < 0) {
+	  TRACE(locate, 1, ("handleLocationRequest: can't send not found reply"));
+      }
       TRACE(locate, 4, ("Can't find %s reply to %s",
 			 OIDString(h->target), NodeString(srv)));
     } else {
-      TRACE(locate, 4, ("Forwarding request to %s", NodeString(loc)));
+      TRACE(locate, 4, ("FIXME: Not really forwarding request to %s", NodeString(loc)));
     }
   } else {
     TRACE(locate, 4, ("Got a demand-reply location request for a non resident object"));
@@ -322,7 +328,9 @@
     replyh.kind = LocateReply;
     replyh.status = 1;		/* Not here */
     reply = StartMsg(&replyh);
-    sendMsg(srv, reply);
+    if (sendMsg(srv, reply) < 0) {
+	TRACE(locate, 1, ("handleLocationRequest: can't send not found reply"));
+    }
   }
 }
 
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/main.c ubc-latest-src/vm/src/main.c
--- ubc-1.05alpha-src/vm/src/main.c	2017-12-11 17:59:03.426711917 +0100
+++ ubc-latest-src/vm/src/main.c	2017-12-11 17:59:03.489711436 +0100
@@ -39,6 +39,8 @@
 int debugInteractively = 0;
 int gotsigint = 0;
 int checkSameUser = 1;
+int offsetbyuserid = 1;
+int fakeUnavailable = 0;
 int debugFirst = 0;
 extern int checkpointBuiltins;
 extern void statistics(void);
@@ -82,7 +84,7 @@
            p_guaranteeInterGcInterval;
 extern int bytesPerGeneration, copyCount, old_size;
 extern void gc_init(void (*)(void), void (*)(void), void (*)(void), void (*)(void));
-extern void gc_stats (int *tg, int *og, int *n, int *no);
+extern void gc_stats (int *tg, int *og, int *n, int *no, int *nd, int *ndr);
 extern void init_nodeinfo(void), sysinit(void);
 extern int parseTraceFlag(char *), init_upcall(void), interpret(struct State *);
 
@@ -217,6 +219,13 @@
       case '1':
 	activelyInitialize = value;
 	break;
+      case 'f':
+	++x;
+	value = mstrtol(&av[0][x], 0, 0);
+	fakeUnavailable = value;
+	if (fakeUnavailable < 1) fakeUnavailable = 1;
+	if (fakeUnavailable > 100) fakeUnavailable = 100;
+	break;
       case 'F':
 	SetTraceFile(&av[0][x+1]);
 	break;
@@ -307,6 +316,9 @@
 	debugFirst = value;
 	if (value) debugInteractively = 1;
 	break;
+      case 'u':
+	offsetbyuserid = value;
+	break;
       case 'U':
 	checkSameUser = 0;
 	break;
@@ -451,14 +463,14 @@
 {
   if (beVerbose) {
     int tg, og, time;
-    int n, no;
-    extern int totalbytecodes;
+    int n, no, nd, ndremoved;
+    extern long long totalbytecodes;
 
     time = currentCpuTime();
     
-    printf("Executed %d bytecodes in %d.%02d seconds\n", 
+    printf("Executed %lld bytecodes in %d.%02d seconds\n", 
 	   totalbytecodes, time/100, time%100);
-    gc_stats(&tg, &og, &n, &no);
+    gc_stats(&tg, &og, &n, &no, &nd, &ndremoved);
     if (n > 0) {
       if (bytesPerGeneration % 1024 == 0) {
 	printf("%d gcs in %d*%d*%dk = %d Kbytes, time %d.%02d\n", n,
@@ -482,6 +494,9 @@
       }
     }
 #ifdef DISTRIBUTED
+    if (nd > 0) {
+		printf("%d distributed gcs freed %d objects\n", nd, ndremoved);
+	}
     printf("Received %d messages (%d bytes), sent %d messages (%d bytes)\n",
 	   nMessagesReceived, nBytesReceived, nMessagesSent, nBytesSent);
 #endif
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/misc.c ubc-latest-src/vm/src/misc.c
--- ubc-1.05alpha-src/vm/src/misc.c	2017-12-11 17:59:03.427711909 +0100
+++ ubc-latest-src/vm/src/misc.c	2017-12-11 17:59:03.489711436 +0100
@@ -100,13 +100,14 @@
 			c = *++str;
 		}
 	}
-	if (base == 0)
+	if (base == 0) {
 		if (c != '0')
 			base = 10;
 		else if (str[1] == 'x' || str[1] == 'X')
 			base = 16;
 		else
 			base = 8;
+	}
 	/*
 	 * for any base > 10, the digits incrementally following
 	 *	9 are assumed to be "abc...z" or "ABC...Z"
@@ -1085,6 +1086,16 @@
   }
 }
 
+static int isAllNil(unsigned int *x, int size)
+{
+  int i;
+  size /= 4;
+  for (i = 0; i < size; ++i) {
+    if (!ISNIL(x[i])) return 0;
+  }
+  return 1;
+}
+
 static void findRootsInStack(State *state, void (*pointers_f)(int, Object *),
 			     void (*variable_f)(Object *, ConcreteType *), void (*variables_f)(int, u32 *))
 {
@@ -1098,6 +1109,7 @@
   lstate = *state;
 
   if (state->ep && state->et && ISNOTNIL(state->ep)) variable_f(&state->ep, &state->et);
+  pointers_f(1, (Object *)&state->opp);
   do {
     if (lstate.pc) {
       if (HASODP((*cpp)->d.instanceFlags)) pointers_f(1, opp);
@@ -1117,7 +1129,27 @@
 			    theTemplate->d.items, theTemplate->d.data));
 	}
 	if (lstate.sp > lstate.fp) {
-	  findLocals(theTemplate, lstate.fp ? lstate.fp : lstate.sb, lstate.sp, pointers_f, variables_f);
+	  unsigned int base = lstate.fp ? lstate.fp : lstate.sb;
+	  IFTRACE(memory, 1) {
+	    if (base + sizeFromTemplate(theTemplate) < lstate.sp) {
+	      /*
+	       * There is memory left over here that I don't have a template
+	       * for, let's at least document it.
+	       */
+	      TRACE(memory, 1,
+		    ("%d bytes of undescribed stack at line %d in %.*s.%.*s",
+		     lstate.sp - base - sizeFromTemplate(theTemplate),
+		     findLineNumber(lstate.pc, theOp->d.code, theTemplate),
+		     lstate.cp->d.name->d.items, lstate.cp->d.name->d.data, 
+		     theOp->d.name->d.items, theOp->d.name->d.data));
+	      if (!isAllNil(base + sizeFromTemplate(theTemplate),
+			    lstate.sp - base - sizeFromTemplate(theTemplate))) {
+		TRACE(memory, 1, ("Backtrace of process"));
+		showProcess(state, 1);
+	      }
+	    }
+	  }
+	  findLocals(theTemplate, base, lstate.sp, pointers_f, variables_f);
 	} else {
 	  /* We must have suspended this guy before executing any
 	     instructions, or there aren't any data items. */
@@ -1340,6 +1372,23 @@
       }
     } OIScNext();
   }    
+  {
+    noderecord **nd;
+    for (nd = &allnodes->p; *nd; nd = &(*nd)->p) {
+      Object node = OIDFetch((*nd)->node);
+      Object inctm = OIDFetch((*nd)->inctm);
+      if (ISNIL(node)) {
+	TRACE(memory, 4, ("Mark roots: can't fetch the node for %s", OIDString((*nd)->node)));
+      } else {
+	pointers_f(1, &node);
+      }
+      if (ISNIL(inctm)) {
+	TRACE(memory, 4, ("Mark roots: can't fetch the inctm for %s", OIDString((*nd)->inctm)));
+      } else {
+	pointers_f(1, &inctm);
+      }
+    }
+  }
 #endif    
   {
     extern Object StdInStream, StdOutStream;
@@ -1408,6 +1457,62 @@
   return sizeOfX(o, o, CODEPTR(o->flags));
 }
 
+int VecLength(Vector o)
+{
+  if (ISNIL(o)) return 0;
+  return o->d.items;
+}
+
+/*
+ * Search the queue of waiting states for one that is attempting an
+ * invocation of an operation in the given type.   Remove the first one
+ * found and return it, or return NULL.
+ */
+State *findAcceptable(SQueue waiting, AbstractType acceptable)
+{
+  State *s;
+  OpVectorElement ove;
+  ATOpVectorElement ave;
+  int i;
+  TRACE(process, 3, ("Trying to find an acceptable operation"));
+  SQueueForEach(waiting, s) {
+    TRACE(process, 4, ("Looking at state #%x", s));
+    ove = s->opp;
+    assert(ove && !ISNIL(ove));
+    TRACE(process, 5, ("State #%x is operation %.*s[%d] %d",
+		       s, ove->d.name->d.items, ove->d.name->d.data,
+		       ove->d.nargs, ove->d.id));
+    if (acceptable->d.ops->d.items == 0) {
+      /*
+       * This is Any. accept the op.
+       */
+      int res = SQueueYank(waiting, s);
+      if (!res) assert(0);
+      TRACE(process, 4, ("Found an acceptable operation"));
+      return s;
+    } else {
+      for (i = 0; i < acceptable->d.ops->d.items; i++) {
+	ave = acceptable->d.ops->d.data[i];
+	TRACE(process, 6, ("AT Operation %d is %.*s[%d] %d",
+			   i, ave->d.name->d.items, ave->d.name->d.data,
+			   VecLength((Vector)ave->d.arguments),
+			   ave->d.id));
+	if (ave->d.id == ove->d.id) {
+	  /*
+	   * Found this op in the AT, accept the op.
+	   */
+	  int res = SQueueYank(waiting, s);
+	  if (!res) assert(0);
+	  TRACE(process, 4, ("Found an acceptable operation"));
+	  return s;
+	}
+      }
+    }
+  } SQueueNext();
+  TRACE(process, 4, ("Failed to find an acceptable operation"));
+  return NULL;
+}
+
 #if defined(WIN32)
 static struct _timeb xx_start;
 
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/misc.h ubc-latest-src/vm/src/misc.h
--- ubc-1.05alpha-src/vm/src/misc.h	2017-12-11 17:59:03.427711909 +0100
+++ ubc-latest-src/vm/src/misc.h	2017-12-11 17:59:03.489711436 +0100
@@ -11,6 +11,10 @@
 #include "dist.h"
 #endif
 
+#ifndef _EMERALD_SQUEUE_H
+#include "squeue.h"
+#endif
+
 #define MAX_FILE_DESCRIPTORS 32
 #define STACKSIZE (16 * 1024)
 extern int stackSize;
@@ -26,57 +30,6 @@
 extern unsigned int *currentOPECount;
 #endif
 
-#define FINDCODEBODY(pc, result, ct, theId) {\
-  OpVector ov = (ct)->d.opVector;\
-  OpVectorElement ope;\
-  int i;\
-  (result) = 0;\
-  for (i = 3; i < ov->d.items; i++) {\
-    ope = ov->d.data[i];\
-    if (ope->d.id == (theId)) {\
-      PROFILEBUMP(pc, ope,ct);\
-      (result) = (unsigned int)(ope->d.code->d.data);\
-      break;\
-    }\
-  }\
-  if ((result) == 0){\
-    fprintf(stderr,"FindCode: op %s id %d undefined for ct %.*s (0x%08x)\n",\
-            OperationName(theId),(theId),\
-	    (ct)->d.name->d.items,\
-	    (ct)->d.name->d.data,\
-	    (ct));\
-    DEBUG("");\
-  }\
-}
-
-#define FINDCODE(pc, result, x, y) FINDCODEBODY(pc, result, x, y)
-
-#define FINDOVE(result, ct, theId) {\
-  if (ISNIL(ct)) { \
-    (result) = 0; \
-  } else { \
-    OpVector ov = (ct)->d.opVector;\
-    OpVectorElement ope;\
-    int i;\
-    (result) = 0;\
-    for (i = 3; i < ov->d.items; i++) {\
-      ope = ov->d.data[i];\
-      if (ope->d.id == (theId)) {\
-	(result) = i; \
-	break;\
-      }\
-    }\
-    if ((result) == 0){\
-      fprintf(stderr,"FindCode: op %s id %d undefined for ct %.*s (0x%08x)\n",\
-	      OperationName(theId),(theId),\
-	      (ct)->d.name->d.items,\
-	      (ct)->d.name->d.data,\
-	      (u32)(ct));\
-      DEBUG("");\
-    }\
-  } \
-}
-
 struct State;
 extern Object rootdir, rootdirg, node, inctm, upcallStub, locsrv, debugger;
 extern int unwind(struct State *state);
@@ -87,6 +40,10 @@
 void tryToInit(Object obj);
 void becomeStub(Object o, ConcreteType ct, void *stub);
 extern int sizeOf(Object o);
+extern int sizeFromTemplate(Template t);
+extern int findLineNumber(unsigned pc, Code code, Template template);
+extern void showProcess(struct State *state, int levelOfDetail);
+extern struct State *findAcceptable(SQueue, AbstractType);
 int upcall( Object o, int fn, int *fail, int argc, int retc, int *args );
 void WriteOID(struct OID *oid, Stream theStream);
 void ReadOID(struct OID *oid, Stream theStream);
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/move.c ubc-latest-src/vm/src/move.c
--- ubc-1.05alpha-src/vm/src/move.c	2017-12-11 17:59:03.427711909 +0100
+++ ubc-latest-src/vm/src/move.c	2017-12-11 17:59:03.489711436 +0100
@@ -24,6 +24,72 @@
 
 IISc fixedMap;
 
+static int misdigit(int c)
+{
+  return ('0' <= c && c <= '9');
+}
+
+int sizeFromTemplate(Template t)
+{
+  int count, size = 0, totalsize = 0;
+  char c, *brands;
+
+  if (ISNIL(t)) return 0;
+
+  brands = (char *)t->d.data;
+  while(*brands != '\0') {
+    switch (*brands++) {
+    case '%':
+      count = 0;
+      while (misdigit(c = *brands++)) {
+	count = count * 10 + c-'0';
+      }
+      if (!count) count = 1;
+      assert(c != '*');
+      switch(c) {
+      case 'm':
+	assert(count == 1);
+	size = 8;
+	break;
+      case 'X':
+      case 'x':
+      case 'D':
+      case 'd':
+      case 'F':
+      case 'f':
+	size = 4;
+	break;
+      case 'C':
+      case 'c':
+      case 'B':
+      case 'b':
+	size = 4;
+	break;
+      case 'V':
+      case 'v':
+	size = 8;
+	break;
+      case 'l':
+      case 'L':
+      case 'q':
+	TRACE(rinvoke, 0, ("Brand %c can't appear in an activation record", c));
+	assert(0);
+	break;
+      default:
+	TRACE(rinvoke, 0, ("can't figure brand %c", c));
+	assert(0);
+      }
+      totalsize += count * size;
+      break;
+    default:
+      TRACE(rinvoke, 0, ("What is '%c' doing in a template?", brands[-1]));
+      assert(0);
+      break;
+    }
+  }
+  return totalsize;
+}
+
 #ifdef DISTRIBUTED
 
 extern int receivingObjects;
@@ -263,71 +329,6 @@
   }
 }
 
-static int misdigit(int c)
-{
-  return ('0' <= c && c <= '9');
-}
-u32 sizeFromTemplate(Template t)
-{
-  int count, size, totalsize = 0;
-  char c, *brands;
-
-  if (ISNIL(t)) return 0;
-
-  brands = (char *)t->d.data;
-  while(*brands != '\0') {
-    switch (*brands++) {
-    case '%':
-      count = 0;
-      while (misdigit(c = *brands++)) {
-	count = count * 10 + c-'0';
-      }
-      if (!count) count = 1;
-      assert(c != '*');
-      switch(c) {
-      case 'm':
-	assert(count == 1);
-	size = 8;
-	break;
-      case 'X':
-      case 'x':
-      case 'D':
-      case 'd':
-      case 'F':
-      case 'f':
-	size = 4;
-	break;
-      case 'C':
-      case 'c':
-      case 'B':
-      case 'b':
-	size = 4;
-	break;
-      case 'V':
-      case 'v':
-	size = 8;
-	break;
-      case 'l':
-      case 'L':
-      case 'q':
-	TRACE(rinvoke, 0, ("Brand %c can't appear in an activation record", c));
-	assert(0);
-	break;
-      default:
-	TRACE(rinvoke, 0, ("can't figure brand %c", c));
-	assert(0);
-      }
-      totalsize += count * size;
-      break;
-    default:
-      TRACE(rinvoke, 0, ("What is '%c' doing in a template?", brands[-1]));
-      assert(0);
-      break;
-    }
-  }
-  return totalsize;
-}
-
 ConcreteType buildSpoofCT(Template t, int size)
 {
   ConcreteType ct;
@@ -464,12 +465,12 @@
  */
 int addActivations(State *state, Stream str, int ready)
 {
-  ConcreteType spoofCT;
+  ConcreteType spoofCT = 0;
   int opindex = findOpVectorIndex(state->cp, state->pc);
   OpVectorElement ove = state->cp->d.opVector->d.data[opindex];
   int templateSize = sizeFromTemplate(ove->d.template);
   int nargsandress;
-  Object spoof;
+  Object spoof = 0;
   OID oido, oidct, prevstateoid, newstateoid;
   Node prevstatesrv;
   int result, howmany, pcoffset;
@@ -559,8 +560,8 @@
   ConcreteType spoofCT;
   u32 opindex, pcoffset;
   OpVectorElement ove;
-  int templateSize, nargsandress, i, howmany, sp;
-  Object spoof;
+  int templateSize = 0, nargsandress, i, howmany, sp;
+  Object spoof = 0;
   OID oido, oidct, prevstateoid, newstateoid, nsoid, nstoid;
   Node prevstatesrv;
   State *state, *prevstate;
@@ -632,6 +633,7 @@
   }
 
   /* set up the interpreter state */
+  state->opp = ove;
   state->pc = (u32)ove->d.code->d.data + pcoffset;
   if (pcoffset && howmany) {
     for (i = 0; i < howmany * 2; i++) {
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/newdist.c ubc-latest-src/vm/src/newdist.c
--- ubc-1.05alpha-src/vm/src/newdist.c	1970-01-01 01:00:00.000000000 +0100
+++ ubc-latest-src/vm/src/newdist.c	2017-12-11 17:59:03.490711429 +0100
@@ -0,0 +1,659 @@
+/*
+ * Copyright (C)
+ * Norman C. Hutchinson and the University of British Columbia, 1998
+ */
+#define E_NEEDS_STRING
+#define E_NEEDS_SOCKET
+#define E_NEEDS_SIGNAL
+#define E_NEEDS_IOV
+#define E_NEEDS_TCP
+#define E_NEEDS_NETDB
+#define E_NEEDS_ERRNO
+#include "system.h"
+
+#include "assert.h"
+#include "types.h"
+#include "mqueue.h"
+#include "storage.h"
+#include "misc.h"
+
+Node myid;
+
+MQueue incoming;
+
+#ifdef DISTRIBUTED
+#include "dist.h"
+#include "remote.h"
+#include "io.h"
+
+#ifdef WIN32
+extern int gettimeofday(struct timeval *, void *);
+#endif /* not WIN32 */
+
+#ifndef SELECTSIZE_T
+#define SELECTSIZE_T size_t
+#endif
+#ifndef SELECTFD_T
+#define SELECTFD_T fd_set
+#endif
+#ifndef SELECTCONST
+#define SELECTCONST const
+#endif
+
+#define MAXOTHERS 128
+static int nothers;
+struct other {
+  Node id;
+  int s;
+} others[MAXOTHERS], cache;
+
+/*
+ * Forward declarations.
+ */
+static void setupReader(struct other *ri);
+
+extern int checkSameUser;
+
+static void pipeHandler(int signalnumber)
+{
+  TRACE(dist, 1, ("Got SIGPIPE"));
+}
+
+ssize_t Dwrite2(int fd, void *buf1, size_t n1, void *buf2, size_t n2)
+{
+  int res;
+  struct iovec v[2];
+  int howmany = 2;
+  v[0].iov_base = buf1;
+  v[0].iov_len = n1;
+  v[1].iov_base = buf2;
+  v[1].iov_len = n2;
+  TRACE(dist, 4, ("write2 on %d for %d+%d bytes", fd, n1, n2));
+  if (fd < 0) return -1;
+  while (1) {
+#ifdef WIN32
+    res = send(fd, v[0].iov_base, v[0].iov_len, 0);
+#else
+    res = writev(fd, v, howmany);
+#endif /* WIN32 */
+    TRACE(dist, 4, ("write2 wrote %d", res));
+    if ((unsigned)res == v[0].iov_len + v[1].iov_len) {
+      res = n1 + n2;
+      break;
+    } else if (res > 0) {
+      /* Only wrote a part, fix up things */
+      if ((unsigned)res < v[0].iov_len) {
+	v[0].iov_len -= res;
+	v[0].iov_base += res;
+      } else {
+	res -= v[0].iov_len;
+	v[0].iov_len = v[1].iov_len - res;
+	v[0].iov_base = v[1].iov_base + res;
+	v[1].iov_base = 0;
+	v[1].iov_len = 0;
+	howmany = 1;
+      }
+    } else if (res <= 0 && errno == EINTR) {
+      /*
+       * Go around the loop.
+       */
+    } else {
+      TRACE(dist, 1, ("write2 on %d for %d+%d bytes returned %d, errno = %d",
+		      fd, n1, n2, res, errno));
+      break;
+    }
+  }
+  TRACE(dist, 4, ("write2 returning %d", res));
+  return res;
+}
+
+struct header {
+  int length;
+};
+
+static int mysocket;
+
+struct nbo {
+  unsigned int ipaddress;
+  unsigned short port, epoch;
+  int userid;
+};
+
+static NotifyFunction notifyFunction;
+
+void DRegisterNotify(NotifyFunction f)
+{
+  assert(notifyFunction == 0);
+  notifyFunction = f;
+}
+
+static void nukeother(struct other o)
+{
+  int from, to;
+  TRACE(dist, 8, ("Nuking %x.%x (%d)", ntohl(o.id.ipaddress), o.id.port, o.s));
+  for (from = 0, to = 0; from < nothers; from++) {
+    if (others[from].s == o.s) {
+      TRACE(dist, 8, ("  Nuking %x.%x (%d)", ntohl(others[from].id.ipaddress), others[from].id.port, others[from].s));
+      /* don't do this one */
+    } else {
+      if (from != to) {
+	others[to++] = others[from];
+      } else {
+	to++;
+      }
+    }
+  }
+  TRACE(dist, 7, ("Nothers went from %d to %d", nothers, to));
+  nothers = to;
+  cache.id.ipaddress = cache.id.port = cache.s = 0;
+}
+
+static void maximizeSocketBuffers(int s)
+{
+#if defined(SO_SNDBUF) && defined(SO_RCVBUF)
+  int size = 0, mid, low, high, len;
+  int which = SO_SNDBUF;
+  do {
+    len = sizeof(low);
+    if (getsockopt(s, SOL_SOCKET, which, (char *)&low, &len) >= 0) {
+      low = low / 1024;
+      high = 128;
+      while (low < high) {
+	mid = size = ((low + high) / 2) * 1024;
+	if (size == low * 1024 || size == high * 1024) break;
+	TRACE(dist, 14, ("Range [%d-%d], trying size %d", low * 1024, high * 1024, size));
+	if (setsockopt(s, SOL_SOCKET, which, (char *)&size, sizeof(size)) < 0) {
+		TRACE(dist, 13, ("Resetting high to %d", mid / 1024));
+	  high = mid / 1024;
+	} else {
+	TRACE(dist, 13, ("Resetting low to %d", mid / 1024));
+
+	  low = mid / 1024;
+	}
+      }
+    }
+    TRACE(dist, 3, ("Set socket buffer size to %d", size));
+    which = (which == SO_SNDBUF ? SO_RCVBUF : -1);
+  } while (which != -1);
+#endif
+}
+
+int findsocket(Node *t, int create)
+{
+  int i, addrlen, s, pos;
+  struct sockaddr_in addr;
+  struct other *o, localcopy;
+  struct nbo nbo;
+
+  TRACE(dist, 7, ("in find socket for %#x.%4x", ntohl(t->ipaddress), t->port));
+  if (cache.id.ipaddress == t->ipaddress && cache.id.port == t->port && cache.s) {
+    TRACE(dist, 8, ("find socket returning %d from cache", cache.s));
+    return cache.s;
+  }
+  for (i = 0; i < nothers; i++) {
+    TRACE(dist, 9, ("  Looking at %#x.%4x", ntohl(others[i].id.ipaddress), others[i].id.port));
+    if (others[i].id.ipaddress == t->ipaddress && others[i].id.port == t->port) {
+      cache = others[i];
+      TRACE(dist, 8, ("find socket returning %d", cache.s));
+      return cache.s;
+    }
+  }
+  if (!create) return -1;
+#if defined(WIN32) && defined(SO_SYNCHRONOUS_NONALERT)
+  {
+    int optionValue = SO_SYNCHRONOUS_NONALERT;
+    int err;
+    err = setsockopt(INVALID_SOCKET,
+		     SOL_SOCKET,
+		     SO_OPENTYPE,
+		     (char *)&optionValue,
+		     sizeof(optionValue));
+    if (err != NO_ERROR) {
+      printf("setsockopt: OPENTYPE failed with %d\n", err);
+      abort();
+    }
+  }
+#endif
+  if ((s = socket(AF_INET, SOCK_STREAM, 0)) < 0) return -1;
+  memset(&addr, 0, sizeof(addr));
+  addr.sin_family = AF_INET;
+  addr.sin_port = htons(0);
+  addr.sin_addr.s_addr = 0;
+  if (bind(s, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+    perror("findsocket.bind");
+    closesocket(s);
+    return -1;
+  }
+  memset(&addr, 0, sizeof(addr));
+  addr.sin_family = AF_INET;
+  addr.sin_port = htons(t->port);
+  addr.sin_addr.s_addr = t->ipaddress;
+  addrlen = sizeof(addr);
+  TRACE(dist, 1, ("Trying to connect to %08lx.%04x", ntohl(addr.sin_addr.s_addr), ntohs(addr.sin_port)));
+  if (connect(s, (struct sockaddr *)&addr, addrlen) < 0) {
+    TRACE(dist, 3, ("Connect failed with errno %d %s", errno, strerror(errno)));
+    closesocket(s);
+    return -1;
+  }
+  {
+    int on = 1;
+    if (setsockopt(s, IPPROTO_TCP, TCP_NODELAY, (char *)&on, sizeof (on)) < 0) {
+      closesocket(s);
+      perror("setsockopt");
+      return -1;
+    }
+  }
+  maximizeSocketBuffers(s);
+
+  localcopy.id = *t;
+  localcopy.s = s;
+  TRACE(dist, 9, ("Inserting %#x.%d -> %d in others[%d]", ntohl(t->ipaddress), t->port, localcopy.s, nothers));
+  pos = nothers;
+  others[nothers++] = localcopy;
+  {
+    nbo.ipaddress = myid.ipaddress;
+    nbo.port = htons(myid.port);
+    nbo.epoch = htons(myid.epoch);
+    nbo.userid = htonl(getuid());
+    if (writeToSocketN(localcopy.s, &nbo, sizeof(nbo)) != sizeof(nbo) ||
+	readFromSocketN(localcopy.s, &nbo, sizeof(nbo)) != sizeof(nbo)) {
+      TRACE(dist, 0, ("Couldn't exchange epoch info"));
+      closesocket(localcopy.s);
+      nothers--;
+      return -1;
+    } else if(checkSameUser && getuid() != (int)ntohl(nbo.userid)) {
+      printf("Permission denied - user mismatch local %d != remote %d\n", (int)getuid(), (int)ntohl(nbo.userid));
+      closesocket(localcopy.s);
+      nothers--;
+      return -1;
+    }
+    localcopy.id.ipaddress = nbo.ipaddress;
+    localcopy.id.epoch = ntohs(nbo.epoch);
+    assert(localcopy.id.port == ntohs(nbo.port));
+    *t = localcopy.id;
+  }
+  o = (struct other *)vmMalloc(sizeof *o);
+  *o = localcopy;
+  setupReader(o);
+  TRACE(dist, 2, ("find socket returning new %d", localcopy.s));
+  cache = localcopy;
+  if (!SameNode(others[pos].id, cache.id)) {
+    TRACE(dist, 9, ("Inserting %#x.%d -> %d in others[%d]", ntohl(cache.id.ipaddress), cache.id.port, cache.s, nothers));
+    others[nothers++] = cache;
+  }
+  return cache.s;
+}
+
+static void callNotifyFunction(Node id, int comingup)
+{
+  notifyFunction(id, comingup);
+}
+
+typedef struct ReaderState {
+  struct other *ri;
+  readBuffer rb;
+  int readingLength, length;
+} ReaderState;
+
+static void ReaderCB(int sock, EDirection d, void *state)
+{
+  extern int nMessagesReceived, nBytesReceived;
+  ReaderState *rs = state;
+  int res;
+  void *buffer = 0;
+
+  if (!(res = tryReading(&rs->rb, sock))) return;
+  if (res < 0 || res != rs->rb.goal) {
+    /*
+     * Give up on this socket.
+     */
+    resetHandler(sock, EIO_Read);
+    resetHandler(sock, EIO_Except);
+    closesocket(sock);
+    if (notifyFunction) notifyFunction(rs->ri->id, 0);
+    nukeother(*rs->ri);
+    vmFree(rs->ri);
+    vmFree(rs);
+  } else if (rs->readingLength) {
+    nBytesReceived += sizeof(rs->length);
+    rs->length = ntohl(rs->length);
+    rs->readingLength = 0;
+    if (rs->length > 0) {
+      buffer = vmMalloc(rs->length);
+      setupReadBuffer(&rs->rb, buffer, rs->length, 0, readFromSocket);
+    } else {
+      TRACE(dist, 0, ("Negative length %d", rs->length));
+    }
+  } else {
+    nBytesReceived += rs->length;
+    nMessagesReceived ++;
+    assert(ntohl(*(int *)rs->rb.buffer) == 0xdeafdeaf);
+    MQueueInsert(incoming, rs->ri->id, rs->length, rs->rb.buffer);
+    setupReadBuffer(&rs->rb, &rs->length, sizeof(rs->length), 0, readFromSocket);
+    rs->readingLength = 1;
+  }
+}
+
+static void setupReader(struct other *ri)
+{
+  ReaderState *rs = (ReaderState *)vmMalloc(sizeof(*rs));
+  rs->ri = ri;
+  rs->readingLength = 1;
+  setupReadBuffer(&rs->rb, &rs->length, sizeof(rs->length), 0, readFromSocket);
+  setHandler(rs->ri->s, ReaderCB, EIO_Read, rs);
+  setHandler(rs->ri->s, ReaderCB, EIO_Except, rs);
+}
+
+typedef struct {
+  struct other *ri;
+  struct nbo nbo;
+  readBuffer rb;
+} ListenerState;
+  
+static int checkUserOK(int local, int remote)
+{
+  if (checkSameUser && local != remote) {
+      printf("Permission denied - user mismatch local %d != remote %d\n",
+	      local, remote);
+      return 0;
+  } else {
+    return 1;
+  }
+}
+
+static void ListenerStage2(int sock, EDirection d, void *arg)
+{
+  int res;
+  ListenerState *ls = arg;
+  if (!(res = tryReading(&ls->rb, ls->ri->s))) return;
+  resetHandler(sock, EIO_Read);
+  resetHandler(sock, EIO_Except);
+  if (res != sizeof(ls->nbo) || !checkUserOK(getuid(), ntohl(ls->nbo.userid))) {
+    nukeother(*ls->ri);
+    closesocket(ls->ri->s);
+    vmFree(ls->ri);
+  } else {
+    ls->ri->id.port = ntohs(ls->nbo.port);
+    ls->ri->id.ipaddress = ls->nbo.ipaddress;
+    ls->ri->id.epoch = ntohs(ls->nbo.epoch);
+    TRACE(dist, 8, ("Inserting %#x.%4x.%4x -> %d in others[%d]", ntohl(ls->ri->id.ipaddress), ls->ri->id.port, ls->ri->id.epoch, ls->ri->s, nothers));
+    others[nothers++] = *ls->ri;
+    setupReader(ls->ri);
+    if (notifyFunction) callNotifyFunction(ls->ri->id, 1);
+  }
+  vmFree((char *)ls);
+}
+
+static void ListenerCB(int sock, EDirection d, void *s)
+{
+  int newsocket;
+  struct sockaddr_in addr;
+  int addrlen = sizeof(addr), on = 1;
+  ListenerState *ls = (ListenerState *)vmMalloc(sizeof(*ls));
+
+  TRACE(dist, 1, ("ListenerCB on %d", sock));
+  newsocket = accept(sock, (struct sockaddr *)&addr, &addrlen);
+  if (newsocket < 0) return;
+  if (setsockopt(newsocket, IPPROTO_TCP, TCP_NODELAY, (char *)&on, sizeof (on)) < 0) {
+    closesocket(newsocket);
+    perror("setsockopt");
+    return;
+  }
+  maximizeSocketBuffers(newsocket);
+  ls->ri = (struct other *)vmMalloc(sizeof *ls->ri);
+  ls->ri->s = newsocket;
+  ls->ri->id.ipaddress = addr.sin_addr.s_addr;
+  ls->ri->id.port = ntohs(addr.sin_port);
+
+  TRACE(dist, 1, ("Accepted new connection %d from %#x.%x",
+		  ls->ri->s, ntohl(ls->ri->id.ipaddress), ls->ri->id.port));
+  TRACE(dist, 8, ("Inserting %#x.%x -> %d in others[%d]", ntohl(ls->ri->id.ipaddress), ls->ri->id.port, ls->ri->s, nothers));
+  others[nothers++] = *ls->ri;
+  ls->nbo.ipaddress = myid.ipaddress;
+  ls->nbo.port = htons(myid.port);
+  ls->nbo.epoch = htons(myid.epoch);
+  ls->nbo.userid = htonl(getuid());
+  if (send(ls->ri->s, (char *)&ls->nbo, sizeof(ls->nbo), 0) != sizeof(ls->nbo)) {
+    nukeother(*ls->ri);
+    closesocket(ls->ri->s);
+    vmFree(ls->ri);
+    return;
+  }
+  setupReadBuffer(&ls->rb, &ls->nbo, sizeof(ls->nbo), 0, readFromSocket);
+  setHandler(ls->ri->s, ListenerStage2, EIO_Read, ls);
+  setHandler(ls->ri->s, ListenerStage2, EIO_Except, ls);
+}
+
+static void setupListener(int sock)
+{
+  setHandler(sock, ListenerCB, EIO_Read, NULL);
+}
+
+int DNetStart(unsigned int ipaddress, unsigned short port, unsigned short epoch)
+{
+  struct sockaddr_in addr;
+  int addrlen, on = 1;
+  char hostname[128];
+#ifdef alpha
+#pragma pointer_size long
+#endif
+  struct hostent *h;
+#ifdef alpha
+#pragma pointer_size short
+#endif
+
+  assert(myid.ipaddress == 0 && myid.port == 0 && myid.epoch == 0);
+  if ((mysocket = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
+    return -1;
+  }
+  memset(&addr, 0, sizeof(addr));
+  addr.sin_family = AF_INET;
+  addr.sin_port = htons(port);
+  addr.sin_addr.s_addr = ipaddress;
+  if (bind(mysocket, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
+    closesocket(mysocket);
+    return -1;
+  }
+  addrlen = sizeof(addr);
+  if (getsockname(mysocket, (struct sockaddr *)&addr, &addrlen) < 0) {
+    closesocket(mysocket);
+    return -1;
+  }
+  TRACE(dist, 3, ("NetStart on %#lx.%d", addr.sin_addr.s_addr, ntohs(addr.sin_port)));
+  if (listen(mysocket, 5) < 0) {
+    closesocket(mysocket);
+    return -1;
+  }
+  if (setsockopt(mysocket, SOL_SOCKET, SO_REUSEADDR, (char *)&on, sizeof (on)) < 0) {
+    closesocket(mysocket);
+    perror("setsockopt");
+    return -1;
+  }
+  /*
+   * Originally we did this all the time on not windows
+   */
+  if (addr.sin_addr.s_addr == 0 || addr.sin_addr.s_addr == htonl(0x7f000001)) {
+    if (gethostname(hostname, sizeof hostname) < 0) {
+      printf("Can't get my own host name.\n");
+      printf("Emerald won't work well between machines.\n");
+    } else if ((h = gethostbyname(hostname)) == 0) {
+      printf("Can't look up my own host name.\n");
+      printf("Emerald won't work well between machines.\n");
+    } else {
+      memcpy(&addr.sin_addr.s_addr, h->h_addr, sizeof(unsigned int));
+    }
+  }
+  myid.ipaddress = addr.sin_addr.s_addr;
+  myid.port = ntohs(addr.sin_port);
+  myid.epoch = epoch;
+  TRACE(dist, 2, ("Net start on %04x.%04x.%04x", ntohl(myid.ipaddress), myid.port, myid.epoch));
+  setupListener(mysocket);
+  return 0;
+}
+
+int DProd(Node *receiver)
+{
+  int s = findsocket(receiver, 1);
+  return s;
+}
+
+int DSend(Node receiver, void *sbuf, int slen)
+{
+  unsigned int length;
+  int s = -1, res = 1;
+  extern char *NodeString(Node);
+  extern int nMessagesSent, nBytesSent;
+  noderecord *nr;
+
+
+  if (SameNode(receiver, myid)) {
+    res = -1;
+  } else if (isNoNode(receiver)) {
+    res = -1;
+  } else {
+    nr = getNodeRecordFromSrv(receiver);
+    if (nr && !nr->up) {
+      /*
+       * We have an entry for this node, and it is down.
+       */
+      res = -1;
+    } else {
+      s = findsocket(&receiver, 1);
+      nMessagesSent++;
+      nBytesSent += slen;
+
+      TRACE(dist, 3, ("Send"));
+
+      length = htonl(slen);
+      res = Dwrite2(s, &length, sizeof(length), sbuf, slen);
+      if (res != sizeof(length) + slen) {
+	TRACE(dist, 1, ("DSend to %s, socket %d, for %d bytes returned %d\n",
+			NodeString(receiver), s, slen + sizeof(length), res));
+	res = -1;
+      }
+    }
+  }
+  TRACE(dist, ((res < 0) ? 1 : 5), ("DSend %d to %s on %d returning %d", slen,
+				    NodeString(receiver), s, res));
+  return res;
+}
+
+void processMessages(void)
+{
+  if (MQueueSize(incoming) == 0) checkForIO(1);
+  if (MQueueSize(incoming) > 0) serveRequest();
+}
+
+#endif
+
+#ifdef __linux
+# define sigvec		sigaction
+# define sv_mask	sa_mask
+# define sv_flags	sa_flags
+# define sv_handler	sa_handler
+# define sv_onstack	sa_mask /* ouch, this one really hurts */
+#endif /* __linux */
+
+#ifdef hp700
+#define SIGVEC sigvector
+#else
+#define SIGVEC sigvec
+#endif /* hp700 */
+
+void establishHandler(int sig, void (*handler)(int))
+{
+#if defined(__svr4__) || defined(__SYSTYPE_SVR4__) || defined(CYGWIN)
+  struct sigaction action;
+
+  memset(&action, 0, sizeof(action));
+  action.sa_handler = handler;
+  sigaction(sig, &action, NULL);
+#else
+#if defined(WIN32) || defined(DOS)
+  signal(sig, handler);
+#else
+  struct sigvec vec;
+  memset(&vec, 0, sizeof(vec));
+
+  vec.sv_handler = handler;
+  SIGVEC(sig, &vec, NULL);
+#endif
+#endif
+}
+
+void DInit(void)
+{
+  extern void sigdie(int);
+  establishHandler(SIGINT, sigdie);
+#if defined(SIGPIPE) && defined(DISTRIBUTED)
+  establishHandler(SIGPIPE, pipeHandler);
+#endif
+  incoming = MQueueCreate();
+}
+
+#ifdef WIN32
+void perror(const char *msg)
+{
+  printf("%s: %d\n", msg, errno);
+  fflush(stdout);
+}
+#endif /* WIN32 */
+
+char *NodeString(Node srv)
+{
+  static char buf[5][60];
+  static int i = 0;
+  char *rval;
+
+  rval = buf[i]; i = (i+1) % 5;
+  sprintf(rval, "%08lx.%04x.%04x", ntohl(srv.ipaddress), srv.port, srv.epoch);
+  return rval;
+}
+
+int getplane()
+{
+  int port = 0;
+  extern int offsetbyuserid;
+  char *plane = getenv("EMPLANE");
+  if (plane) {
+    port += mstrtol(plane, 0, 10);
+  } else if (offsetbyuserid) {
+    port += getuid() % EMERALDPORTSKIP;
+  }
+  return port;
+}
+
+
+int InitDist()
+{
+  extern Node MyNode;
+  extern OID MyBaseOID;
+  int port;
+  extern char *getenv(const char *);
+
+  InitStorage();
+
+  MyNode.epoch = random() & 0xffff;
+  /* start up the network subsystem */
+  port = EMERALDFIRSTPORT + getplane();
+  
+#ifdef DISTRIBUTED
+  while (DNetStart(0,  port, MyNode.epoch) != 0) {
+    port = EMERALDPORTPROBE(port);
+    if (port > 0x10000) return -1;
+  }
+#else
+  myid.ipaddress = 0xdeadbeef;
+  myid.port = port;
+  myid.epoch = MyNode.epoch;
+#endif
+  MyNode.ipaddress = myid.ipaddress;
+  MyNode.port = myid.port;
+  MyNode.epoch = myid.epoch;
+  MyBaseOID.ipaddress = ntohl(MyNode.ipaddress);
+  MyBaseOID.port = MyNode.port;
+  MyBaseOID.epoch = MyNode.epoch;
+
+  return 0;
+}
+
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/oidtoobj.c ubc-latest-src/vm/src/oidtoobj.c
--- ubc-1.05alpha-src/vm/src/oidtoobj.c	2017-12-11 17:59:03.427711909 +0100
+++ ubc-latest-src/vm/src/oidtoobj.c	2017-12-11 17:59:03.490711429 +0100
@@ -21,7 +21,11 @@
 #include "read.h"
 #include "assert.h"
 
-#define OBJECTTABLESIZE 101
+/*
+ * The initial size of the object table.  If it is too small, it gets
+ * increased, but due to malloc's behaviour it costs a lot of data space.
+ */
+#define OBJECTTABLESIZE (24 * 1024)
 
 OTable ObjectTable;
 
@@ -37,7 +41,7 @@
  */
 
 void OIDToObjectInit() {
-  ObjectTable = OTableCreateN(4*1024);
+  ObjectTable = OTableCreateN(OBJECTTABLESIZE);
 }
 
 /*
@@ -59,8 +63,7 @@
 #ifndef NDEBUG
   Object old = OIDFetch(oid);
   if (old != o) {
-    ftrace("Botch:  %#x != %#x", (u32)old , (u32)o);
-    assert(0);
+    ftrace("OIDRemove botch:  %#x != %#x", (u32)old , (u32)o);
   }
 #endif
   TRACE(oid, 3, ("Removing id from %#x %s", o, OIDString(oid)));
@@ -86,10 +89,10 @@
   old = OIDFetch(oid);
   if (!ISNIL(old)) {
     if (old != o) {
-      ConcreteType oldct = CODEPTR(old->flags);
       TRACE(oid, 0, ("Defining an id that already exists %s -> %#x, a %.*s",
 		     OIDString(oid), old,
-		     oldct->d.name->d.items, oldct->d.name->d.data));
+		     CODEPTR(old->flags)->d.name->d.items,
+		     CODEPTR(old->flags)->d.name->d.data));
     }
     OTableDeleteByObject(ObjectTable, old);
   }
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/oidtoobj.h ubc-latest-src/vm/src/oidtoobj.h
--- ubc-1.05alpha-src/vm/src/oidtoobj.h	2017-12-11 17:59:03.427711909 +0100
+++ ubc-latest-src/vm/src/oidtoobj.h	2017-12-11 17:59:03.490711429 +0100
@@ -33,6 +33,7 @@
 extern OID FOIDOf(Object o);
 extern OID nooid;
 extern AbCon findAbCon(OID, OID), findConCon(ConcreteType);
+int findOpByName(ConcreteType ct, char *name);
 extern void UpdateObjectLocation(Object oldo, Object newo);
 
 char *OIDString( OID );
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/otable.c ubc-latest-src/vm/src/otable.c
--- ubc-1.05alpha-src/vm/src/otable.c	2017-12-11 17:59:03.428711901 +0100
+++ ubc-latest-src/vm/src/otable.c	2017-12-11 17:59:03.490711429 +0100
@@ -107,7 +107,7 @@
   register indexType ohash, oidhash;
 
   assert(!ISNIL(value));
-  if (sc->count >= sc->size) ExpandHashTable(sc);
+  if (sc->count >= sc->size - 1) ExpandHashTable(sc);
 
   index = sc->free;
   assert(index);
@@ -263,6 +263,10 @@
 {
   Object value;
   OTableTEPtr e = LookupByOID(sc, a);
+  if (!e) {
+    TRACE(oid, 2, ("Can't delete object %#x from otable", a));
+    return;
+  }
   value = e->value;
   Delete(sc, e);
 }
@@ -271,6 +275,10 @@
 {
   OID oid;
   OTableTEPtr e = LookupByObject(sc, a);
+  if (!e) {
+    TRACE(oid, 2, ("Can't delete object %#x from otable", a));
+    return;
+  }
   oid = e->key;
   Delete(sc, e);
 }
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/otable.h ubc-latest-src/vm/src/otable.h
--- ubc-1.05alpha-src/vm/src/otable.h	2017-12-11 17:59:03.428711901 +0100
+++ ubc-latest-src/vm/src/otable.h	2017-12-11 17:59:03.490711429 +0100
@@ -12,7 +12,7 @@
 
 #define OTableIsNIL(X) (ISNIL(X))
 
-typedef unsigned short indexType;
+typedef unsigned int indexType;
 
 /*
  * Hidden, private type declarations.  The only thing
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/read.c ubc-latest-src/vm/src/read.c
--- ubc-1.05alpha-src/vm/src/read.c	2017-12-11 17:59:03.428711901 +0100
+++ ubc-latest-src/vm/src/read.c	2017-12-11 17:59:03.490711429 +0100
@@ -998,7 +998,7 @@
 	       at->d.name->d.data,
 	       at->d.filename->d.items,
 	       at->d.filename->d.data));
-      } else if ((int)ct < NUMBUILTINS){
+      } else if ((unsigned int)ct < NUMBUILTINS){
 	TRACE(trans, 2, ("%#x has ct index %#x", o, ct));
       } else {
 	TRACE(trans, 2, ("%#x has ct %#x, a %.*s",
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/remote.c ubc-latest-src/vm/src/remote.c
--- ubc-1.05alpha-src/vm/src/remote.c	2017-12-11 17:59:03.428711901 +0100
+++ ubc-latest-src/vm/src/remote.c	2017-12-11 17:59:03.491711421 +0100
@@ -37,6 +37,7 @@
 extern int doDistribution;
 void *ctstr;
 Node ctsrv;
+#if !defined(NTRACE)
 static char *typenames[] = {
   "EchoRequest",
   "EchoReply",
@@ -59,7 +60,7 @@
   "DistGCDoneRequest",
   "DistGCDoneReply",
   "DistGCDoneReport" };
-  
+#endif  
 
 int isLimbo(Node n)
 {
@@ -186,16 +187,14 @@
 #ifdef DISTRIBUTED
 void parseAddr(char *str, unsigned int *addr, unsigned short *port)
 {
-  char *colon, *plane, *comma;
+  char *colon, *comma;
   struct hostent *h = NULL;
 
   comma = (char *)strchr(str, ',');
   if (comma) *comma = '\0';
   colon = (char *)strchr(str, ':');
   if (!colon) {
-    *port = EMERALDFIRSTPORT;
-    plane = getenv("EMPLANE");
-    if (plane) *port += mstrtol(plane, 0, 10);
+    *port = EMERALDFIRSTPORT + getplane();
   } else {
     *colon = '\0';
     *port = mstrtol(colon + 1, 0, 0);
@@ -203,7 +202,7 @@
   if ('a' <= str[0] && str[0] <= 'z') {
     h = gethostbyname(str);
     if (h == NULL) {
-      TRACE(rinvoke, 0, ("parseAddr: gethostbyname failed!"));
+      fprintf(stderr, "parseAddr: gethostbyname failed!\n");
       return;
     } else { 
       memcpy(addr, h->h_addr, sizeof(*addr));
@@ -610,18 +609,39 @@
   } ISetNext();
 }
 
+static void doUpcallHandlers(Object thenode, Object theinctm, char *name)
+{
+  Object args[4];
+  int fn, fail = 0;
+  ConcreteType nodect;
+
+  if (ISNIL(node)) return;
+  nodect = BuiltinInstCT(NODEI);
+
+  args[0] = thenode;
+  args[1] = (Object)CODEPTR(thenode->flags);
+  args[2] = theinctm;
+  args[3] = (Object)CODEPTR(theinctm->flags);
+  fn = findOpByName(nodect, name);
+  upcall(node, fn, &fail, 2, 0, (int *)args);
+}
+
 static void nukeNode(noderecord *nd)
 {
-  assert(!nd->up);
+  Object thenode, theinctm;
+  theinctm = OIDFetch(nd->inctm);
+  thenode = OIDFetch(nd->node);
+  nd->up = 0;
   invokeHandleDown(nd);
   moveHandleDown(nd);
   locateHandleDown(nd);
+  doUpcallHandlers(thenode, theinctm, "nodedown");
 }
 
 noderecord *update_nodeinfo_fromOIDs(OID nodeOID, OID inctmOID, int up)
 {
   noderecord **nd;
-  Object thenode;
+  Object thenode, inctm;
   ConcreteType ct;
 
   TRACE(rinvoke, 8, ("Updating node info for %08x.%04x.%04x -> %s", nodeOID.ipaddress, nodeOID.port, nodeOID.epoch, up ? "up": "down"));
@@ -631,7 +651,9 @@
 	nodeOID.epoch == (*nd)->node.epoch) {
       TRACE(rinvoke, 9, ("Already had one"));      
       (*nd)->up = up;
-      if (!up) nukeNode(*nd);
+      if (!up) {
+	nukeNode(*nd);
+      } 
       return *nd;
     }
   }
@@ -639,7 +661,8 @@
   TRACE(rinvoke, 9, ("Making a new one"));      
   *nd = (noderecord*) vmMalloc(sizeof(noderecord));
   assert(*nd != NULL);
-  (*nd)->up = up; (*nd)->p = NULL; nodecount++;
+  (*nd)->p = NULL; nodecount++;
+  (*nd)->up = up; 
   (*nd)->srv.ipaddress =  htonl(nodeOID.ipaddress);
   (*nd)->srv.port = nodeOID.port;
   (*nd)->srv.epoch = nodeOID.epoch;
@@ -655,11 +678,12 @@
   ct = BuiltinInstCT(TIMEI); assert(ct);
   (*nd)->inctm = inctmOID;
   if (up) {
-    if (ISNIL(doObjectRequest((*nd)->srv, &(*nd)->inctm, ct))) {
+    inctm = doObjectRequest((*nd)->srv, &(*nd)->inctm, ct);
+    if (ISNIL(inctm)) {
       TRACE(rinvoke, 0, ("update_nodeinfo: failed to retrieve inctm"));
       *nd = (*nd)->p; nodecount--; return NULL;
     }
-  } else if (! ISNIL(OIDFetch((*nd)->inctm))) {
+  } else if (! ISNIL((inctm = OIDFetch((*nd)->inctm)))) {
     /* We already have the object */
   } else {
     /* TODO:
@@ -667,16 +691,15 @@
        believe that we will never have stubs for immutable objects.
      */
     int stack[512];
-    Object o;
     ct = BuiltinInstCT(TIMEI); assert(ct);
     stack[0] = 0;
     stack[1] = (unsigned int) intct;
     stack[2] = 0;
     stack[3] = stack[1];
-    o = CreateObjectFromOutside(ct, (u32)stack);
-    OIDInsert(inctmOID, o);
+    inctm = CreateObjectFromOutside(ct, (u32)stack);
+    OIDInsert(inctmOID, inctm);
   }
-
+  doUpcallHandlers(thenode, inctm, up ? "nodeup" : "nodedown");
   return *nd;
 }
 
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/rinvoke.c ubc-latest-src/vm/src/rinvoke.c
--- ubc-1.05alpha-src/vm/src/rinvoke.c	2017-12-11 17:59:03.428711901 +0100
+++ ubc-latest-src/vm/src/rinvoke.c	2017-12-11 17:59:03.491711421 +0100
@@ -27,6 +27,7 @@
 
 int receivingObjects = 0;
 extern int debugInteractively;
+extern int fakeUnavailable;
 
 #ifdef DISTRIBUTED
 
@@ -198,7 +199,7 @@
   Stream newstr;
   int argc = h->option2, retc = h->option1, fn = h->status, i;
   Object obj;
-  ConcreteType ct;
+  ConcreteType ct = 0;
   RemoteOpHeader replyh;
   int *sp;
   State *state;
@@ -249,6 +250,9 @@
 	findAndSendTo(h->target, newstr);
       }
     }
+  } else if (fakeUnavailable && ((random() % 100) < fakeUnavailable)) {
+    newstr = StealStream(str);
+    sendUnavailableReply(newstr);
   } else {
     OID oid;
     state = newState(obj, ct);
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/system.h ubc-latest-src/vm/src/system.h
--- ubc-1.05alpha-src/vm/src/system.h	2017-12-11 17:59:03.429711894 +0100
+++ ubc-latest-src/vm/src/system.h	2017-12-11 17:59:03.491711421 +0100
@@ -70,7 +70,9 @@
 #    define EINTR 999
 #    define ETIMEDOUT 999
 #  endif
-extern int errno;
+#  ifndef errno
+     extern int errno;
+#  endif
 #endif
 
 #if defined(E_NEEDS_NTOH)
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/threads.c ubc-latest-src/vm/src/threads.c
--- ubc-1.05alpha-src/vm/src/threads.c	2017-12-11 17:59:03.429711894 +0100
+++ ubc-latest-src/vm/src/threads.c	2017-12-11 17:59:03.491711421 +0100
@@ -265,9 +265,7 @@
 
   MyNode.Epoch = random() & 0xffff;
   /* start up the network subsystem */
-  port = EMERALDFIRSTPORT;
-  plane = getenv("EMPLANE");
-  if (plane) port += mstrtol(plane, 0, 10);
+  port = EMERALDFIRSTPORT + getplane();
 
   while (MTNetStart(0,  port, MyNode.Epoch) != 0) {
     port = EMERALDPORTPROBE(port);
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/threads.h ubc-latest-src/vm/src/threads.h
--- ubc-1.05alpha-src/vm/src/threads.h	2017-12-11 17:59:03.429711894 +0100
+++ ubc-latest-src/vm/src/threads.h	2017-12-11 17:59:03.491711421 +0100
@@ -11,7 +11,7 @@
 extern int useThreads;
 
 #define EMERALDFIRSTPORT 0x3ee3
-#define EMERALDPORTSKIP 0x100
+#define EMERALDPORTSKIP 0x400
 #define EMERALDPORTPROBE(n) ((n) + EMERALDPORTSKIP)
 #ifdef MTHREADS
 
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/trace.c ubc-latest-src/vm/src/trace.c
--- ubc-1.05alpha-src/vm/src/trace.c	2017-12-11 17:59:03.429711894 +0100
+++ ubc-latest-src/vm/src/trace.c	2017-12-11 17:59:03.492711414 +0100
@@ -70,7 +70,9 @@
   tracelocate,
   tracedist,
   traceunavailable,
-  tracefailure = 1
+  tracefailure = 1,
+  tracex,
+  traceT
 ;
 
 typedef struct {
@@ -107,6 +109,8 @@
   { "dist", &tracedist },
   { "unavailable", &traceunavailable },
   { "failure", &tracefailure },
+  { "x", &tracex },
+  { "t", &traceT },
   { NULL, 0 },
 };
 
@@ -169,7 +173,6 @@
       value = 1;
     } else {
       value = mstrtol(equals+1, 0, 0);
-      if (value <= 0) value = 1;
       *equals = '\0';
     }
     setTrace(f, value);
@@ -212,37 +215,30 @@
   }
 }
 
-#define USEDIFFS
-#ifdef USEDIFFS
 static struct timeval original;
-#endif
+
 void TraceInit(void)
 {
-#ifdef USEDIFFS
   gettimeofday(&original, 0);
-#endif
   tracefile = stdout;
 }
 
 void traceTS(int level)
 {
-#ifdef USEDIFFS
   extern struct timeval TimeMinus(struct timeval, struct timeval);
-#endif
   struct timeval print, now;
 
   gettimeofday(&now, 0);
-#ifdef USEDIFFS
   print = TimeMinus(now, original);
-#else
-  print = now;
-#endif
+
+  if (traceT) {
   if (tracebufferpointer) {
     sprintf(tracebufferpointer, "%5d.%06d: ", (int)print.tv_sec%100000, (int)print.tv_usec);
     updatetracebufferpointer();
   } else {
     fprintf(tracefile, "%5d.%06d: ", (int)print.tv_sec%100000, (int)print.tv_usec);
   }
+  }
   while (--level > 0) {
     if (tracebufferpointer) {
       tracebufferpointer[0] = ' ';
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/trace.h ubc-latest-src/vm/src/trace.h
--- ubc-1.05alpha-src/vm/src/trace.h	2017-12-11 17:59:03.429711894 +0100
+++ ubc-latest-src/vm/src/trace.h	2017-12-11 17:59:03.492711414 +0100
@@ -66,7 +66,9 @@
   tracelocate,
   tracedist,
   traceunavailable,
-  tracefailure
+  tracefailure,
+  tracex,
+  traceT
 ;
 
 extern void TraceInit(void);
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/types.h ubc-latest-src/vm/src/types.h
--- ubc-1.05alpha-src/vm/src/types.h	2017-12-11 17:59:03.429711894 +0100
+++ ubc-latest-src/vm/src/types.h	2017-12-11 17:59:03.492711414 +0100
@@ -95,37 +95,13 @@
 #define SETISIMUT(f)      ((f) |= ISIMUTBIT)
 #define CLEARISIMUT(f)    ((f) &= ~ISIMUTBIT)
 
-#define CODEPTREXTRA 0
-#ifdef mips
-#undef CODEPTREXTRA
-#define CODEPTREXTRA 0x10000000
-#endif
-#ifdef alpha
-#undef CODEPTREXTRA
-#define CODEPTREXTRA 0x14000000
-#endif
-#ifdef hp700
-#undef CODEPTREXTRA
-#define CODEPTREXTRA 0x40000000
-#endif
-#ifdef ibm
-#undef CODEPTREXTRA
-#define CODEPTREXTRA 0x20000000
-#endif
-#if defined(i386) && defined(linux)
-#undef CODEPTREXTRA
-#define CODEPTREXTRA 0x40000000
-#endif
-#if defined(i386) && (!defined(linux) && defined(__svr4__))
-#undef CODEPTREXTRA
-#define CODEPTREXTRA 0x08000000
-#endif
+extern int codeptrextra;
 
 #define CODEPTRBITS (0xffffffff & ~ALLBITS)
-#define CODEPTR(f)       ((ConcreteType)((((unsigned int)f) & CODEPTRBITS) | CODEPTREXTRA))
+#define CODEPTR(f)       ((ConcreteType)((((unsigned int)f) & CODEPTRBITS) | codeptrextra))
 #define CODEPTRINDEX(f)  ((unsigned int)f & CODEPTRBITS)
 #define SETCODEPTR(f,cp)  \
-  ((f) = ((((unsigned int)f) & ~CODEPTRBITS)) | ((unsigned int)cp & ~CODEPTREXTRA))
+  ((f) = ((((unsigned int)f) & ~CODEPTRBITS)) | ((unsigned int)cp & ~codeptrextra))
 #define SETCODEPTRINDEX(f,cp)  \
   ((f) = (((unsigned int)f) & ~CODEPTRBITS) | (unsigned int)cp)
 
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/upcall.c ubc-latest-src/vm/src/upcall.c
--- ubc-1.05alpha-src/vm/src/upcall.c	2017-12-11 17:59:03.429711894 +0100
+++ ubc-latest-src/vm/src/upcall.c	2017-12-11 17:59:03.492711414 +0100
@@ -1,5 +1,6 @@
-/* upcall.c - call from the runtime into Emerald
-*/
+/*
+ * upcall.c - call from the runtime into Emerald
+ */
 #include "system.h"
 
 #include "vm_exp.h"
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/vm.c ubc-latest-src/vm/src/vm.c
--- ubc-1.05alpha-src/vm/src/vm.c	2017-12-11 17:59:03.429711894 +0100
+++ ubc-latest-src/vm/src/vm.c	2017-12-11 17:59:03.492711414 +0100
@@ -4,7 +4,7 @@
 #include <stdio.h>
 #endif
 void disassemble(unsigned int ptr, int len, FILE *f);
-int totalbytecodes;
+long long totalbytecodes;
 #ifdef PROFILEINTERPRET
 int bc_freq[NINSTRUCTIONS];
 #endif
@@ -18,13 +18,14 @@
 #define sb state->sb 		/* Stack base */
   Object op;		/* Object pointer */
   ConcreteType cp;		/* Concrete type */
+#define opp state->opp 		/* Operation pointer */
 #define ep state->ep 		/* Environment pointer */
 #define et state->et 		/* Environment type */
 #define nsoid state->nsoid 		/* Next SS OID */
 #define nstoid state->nstoid 		/* Next target OID */
 #define psoid state->psoid 		/* Prev SS OID */
 #define psnres state->psnres 		/* Results to return */
-  int addtototalbytecodes = 0;
+  long long addtototalbytecodes = 0;
   unsigned char opcode;
 #if defined(INTERPRETERLOCALS)
   INTERPRETERLOCALS
@@ -142,7 +143,13 @@
         break;
       case DUP: { u32 a;   POP(u32,a); PUSH(u32,a); PUSH(u32,a); }
         break;
-      case DUPV: { SYNCH(); obsolete("DUPV", state); }
+      case ENSURESPACE: {
+      int size;
+      POP(unsigned, size);
+      F_SYNCH();
+      ensureSpace(size + 32);
+      F_UNSYNCH();
+    }
         break;
       case SWAP: { SYNCH(); obsolete("SWAP", state); }
         break;
@@ -542,6 +549,7 @@
 		  POP(u32, fp);
 		  POP(Object, op);
 		  POP(ConcreteType, cp);
+		  opp = (OpVectorElement)JNIL;
 		  IFTRACE(call, 1) {
 		    doret(fp, sb, pc, xcp);
 		  }
@@ -843,8 +851,31 @@
 		  if (o == op) DEBUG("Breakme executed");
 		}
         break;
-      case FORWARD: {
-	       SYNCH(); obsolete("FORWARD", state);
+      case ACPTBLCK: {
+		AbstractType acceptable;
+		State *otherstate;
+		monitor *m = (monitor *)((Object) op)->d;
+
+		POP(AbstractType, acceptable);
+		otherstate = findAcceptable(m->waiting, acceptable);
+		if (!otherstate) {
+		  m->busy = 2;
+		  PUSH(AbstractType, acceptable);
+		  pc --;
+		  SYNCH();
+		  if (!m->waiting) m->waiting = SQueueCreate();
+		  SQueueInsertFront(m->waiting, state);
+		  TRACE(process, 3, ("Blocking synchronizing process %#x", state));
+		  return 1;
+		} else {
+		  m->busy = 3;
+		  SYNCH();
+		  assert(m->waiting);
+		  SQueueInsertFront(m->waiting, state);
+		  TRACE(process, 3, ("Synchronizing process accepted state %#x", otherstate));
+		  state = otherstate;
+		  UNSYNCH();
+		}
                }
         break;
       case BREAKPT: {
@@ -1153,10 +1184,9 @@
         break;
       case GCOLLECT: {
 		  {
-		    extern void startDistGC(void);
+		    SYNCH();
 		    gcollect();
-		    gcollect_old();
-		    startDistGC();
+		    UNSYNCH();
 		  }
 		}
         break;
@@ -1249,12 +1279,63 @@
 		  fixObjectReferenceFromSeq(id, (Object)xct, OffsetOf(xct, &xct->d.type));
 		}
         break;
-      case STUBCALL: {
-                   SYNCH(); obsolete("STUBCALL", state);
+      case SYNCHINIT: {
+		   monitor *m = (monitor *)((Object) op)->d;
+		   /*
+		    * Busy encodes two things:
+		    *	Low order bit:  open (== 0) or locked (== 1)
+		    *	Next bit:       process alive (== 2) or dead (== 0)
+		    *
+		    * The initial value is 3, locked and the process is alive
+		    * (or at least, hasn't died yet).
+		    */
+		   m->busy = 3;
+		   m->waiting = 0;
 		 }
         break;
-      case STUBRETURN: {
-                   SYNCH(); obsolete("STUBRETURN", state);
+      case SYNCHENTER: {
+		   monitor *m = (monitor *)((Object) op)->d;
+		   State *otherstate;
+		   if (prevOP(fp) == op) {
+		     TRACE(process, 3, ("SYNCHENTER on self invoke, passed"));
+		   } else {
+		     switch (m->busy) {
+		     case 0:
+		       /*
+			* Process dead, object unlocked.
+			*/
+		       m->busy = 1;
+		       break;
+		     case 1:
+		     case 3:
+		       /*
+			* Process dead or alive, object locked.
+			*/
+		       SYNCH();
+		       if (!m->waiting) m->waiting = SQueueCreate();
+		       SQueueInsert(m->waiting, state);
+		       TRACE(process, 3, ("Blocking process %x - synchronized object entry",
+					  state));
+		       return 1;
+		       break;
+		     case 2:
+		       /*
+			* Process alive, object unlocked.  The process will be
+			* at the head of the waiting queue, so block yourself and
+			* run it.  It will decide whether to allow entry.
+			*/
+		       assert(m->waiting);
+		       SYNCH();
+		       otherstate = SQueueRemove(m->waiting);
+		       SQueueInsert(m->waiting, state);
+		       state = otherstate;
+		       UNSYNCH();
+		       break;
+		     default:
+		       assert(0);
+		       break;
+		     }
+		   }
                  }
         break;
       case GETOID: {
@@ -1284,8 +1365,30 @@
 		    PUSH(ConcreteType, intct);
 		  }
         break;
-      case TESTREMOTE: {
-                  SYNCH(); obsolete("TESTREMOTE", state);
+      case SYNCHEXIT: {
+		   monitor *m = (monitor *)((Object) op)->d;
+		   State *otherstate;
+		   if (prevOP(fp) == op) {
+		     TRACE(process, 3, ("SYNCHEXIT of self invoke - passed"));
+		   } else {
+		     if ((otherstate = SQueueRemove(m->waiting)) != NULL) {
+		       /*
+			* Either the process is still alive or some other
+			* operation wants in, in either case, schedule it.
+			*/
+		       makeReady(otherstate);
+		       TRACE(process, 3, ("Unblocking process %x - synchronized object exit",
+					  otherstate));
+		     } else {
+		       /*
+			* There is no other process waiting, the process
+			* better be dead and we want to unlock the object.
+			*/
+		       assert(m->busy == 1);
+		       m->busy = 0;
+		       TRACE(process, 3, ("No waiters - synchronized object exit"));
+		     }
+		   }
 		}
         break;
       case GETIDSEQ: {
@@ -1302,8 +1405,26 @@
 		  PUSH(u32, oid.Seq);
 		}
         break;
-      case CCALL: {
-		  SYNCH(); obsolete("CCALL", state);
+      case SYNCHDIE: {
+		   monitor *m = (monitor *)((Object) op)->d;
+		   State *otherstate;
+		   assert(m->busy == 3);
+
+		   if ((otherstate = SQueueRemove(m->waiting)) != NULL) {
+		     /*
+		      * Some other operation wants in, schedule it.
+		      */
+		     makeReady(otherstate);
+		     TRACE(process, 3, ("Unblocking process %x - synchronizing process exit",
+					otherstate));
+		     m->busy = 1;
+		   } else {
+		     /*
+		      * There is no other process waiting, we want to unlock the object.
+		      */
+		     m->busy = 0;
+		     TRACE(process, 3, ("No waiters - synchronizing process exit"));
+		   }
 		}
         break;
       case LDLITB: { 
@@ -1344,8 +1465,11 @@
       sp -= 4 * n;
     }
         break;
-      case TESTREMOTE2: {
-      SYNCH(); obsolete("TESTREMOTE2", state);
+      case GCOLLECTOLD: {
+		     SYNCH();
+		     gcollect();
+		     gcollect_old();
+		     UNSYNCH();
     }
         break;
       case CODEOF: {
@@ -1743,6 +1867,7 @@
   }
 }
 #undef sb
+#undef opp
 #undef ep
 #undef et
 #undef nsoid
@@ -1797,7 +1922,7 @@
   { "STVOB", "s8", 41 } ,
   { "STVAB", "s8", 42 } ,
   { "DUP", "", 43 } ,
-  { "DUPV", "", 44 } ,
+  { "ENSURESPACE", "", 44 } ,
   { "SWAP", "", 45 } ,
   { "ADD", "", 46 } ,
   { "SUB", "", 47 } ,
@@ -1869,7 +1994,7 @@
   { "CREATEVECLIT", "", 113 } ,
   { "STRHASH", "", 114 } ,
   { "BREAKME", "", 115 } ,
-  { "FORWARD", "", 116 } ,
+  { "ACPTBLCK", "", 116 } ,
   { "BREAKPT", "", 117 } ,
   { "UPB", "", 118 } ,
   { "STRLIT", "", 119 } ,
@@ -1906,17 +2031,17 @@
   { "DLOAD", "", 150 } ,
   { "RELOCATEVECTOR", "", 151 } ,
   { "RELOCATETYPE", "", 152 } ,
-  { "STUBCALL", "", 153 } ,
-  { "STUBRETURN", "", 154 } ,
+  { "SYNCHINIT", "", 153 } ,
+  { "SYNCHENTER", "", 154 } ,
   { "GETOID", "", 155 } ,
-  { "TESTREMOTE", "", 156 } ,
+  { "SYNCHEXIT", "", 156 } ,
   { "GETIDSEQ", "", 157 } ,
-  { "CCALL", "u8", 158 } ,
+  { "SYNCHDIE", "", 158 } ,
   { "LDLITB", "u8", 159 } ,
   { "SWAPV", "", 160 } ,
   { "DOCTLITERALS", "", 161 } ,
   { "CVX", "u8", 162 } ,
-  { "TESTREMOTE2", "", 163 } ,
+  { "GCOLLECTOLD", "", 163 } ,
   { "CODEOF", "", 164 } ,
   { "BUILDABCON", "", 165 } ,
   { "CHECKARGABCONB", "u8", 166 } ,
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/vm.d ubc-latest-src/vm/src/vm.d
--- ubc-1.05alpha-src/vm/src/vm.d	2017-12-11 17:59:03.429711894 +0100
+++ ubc-latest-src/vm/src/vm.d	2017-12-11 17:59:03.492711414 +0100
@@ -210,8 +210,10 @@
       TIMESLICELOCALS
 #endif /* SINGLESTEP */
 
+#define prevOP(xx) ((Object)((u32 *)xx)[-3])
 }
 
+
 @ Design decisions:
 @   When variables are pushed on the stack, they are pushed data then AbCon
 @   Object creations push a code pointer, and return an object pointer
@@ -242,6 +244,7 @@
 	_sb     "Stack base"            "u32"
 	op	"Object pointer"	"Object"
 	cp	"Concrete type"		"ConcreteType"
+	_opp	"Operation pointer"	"OpVectorElement"
 	_ep	"Environment pointer"	"Object"
 	_et	"Environment type"	"ConcreteType"
 	_nsoid	"Next SS OID"		"OID"
@@ -324,7 +327,13 @@
 
 @ Miscellaneous stack machine operations
     DUP   ""    { u32 a;   POP(u32,a); PUSH(u32,a); PUSH(u32,a); }
-    DUPV  ""    { SYNCH(); obsolete("DUPV", state); }
+    ENSURESPACE  ""    {
+      int size;
+      POP(unsigned, size);
+      F_SYNCH();
+      ensureSpace(size + 32);
+      F_UNSYNCH();
+    }
     SWAP  ""    { SYNCH(); obsolete("SWAP", state); }
 
 @ Arithmetic operations find operands on the stack, and push the result
@@ -694,6 +704,7 @@
 		  POP(u32, fp);
 		  POP(Object, op);
 		  POP(ConcreteType, cp);
+		  opp = (OpVectorElement)JNIL;
 		  IFTRACE(call, 1) {
 		    doret(fp, sb, pc, xcp);
 		  }
@@ -979,9 +990,35 @@
 		  breakObject(o);
 		  if (o == op) DEBUG("Breakme executed");
 		}
-    FORWARD "" {
-	       SYNCH(); obsolete("FORWARD", state);
+@ Acptblck is blocking selective method acceptance
+
+  ACPTBLCK "" {
+		AbstractType acceptable;
+		State *otherstate;
+		monitor *m = (monitor *)((Object) op)->d;
+
+		POP(AbstractType, acceptable);
+		otherstate = findAcceptable(m->waiting, acceptable);
+		if (!otherstate) {
+		  m->busy = 2;
+		  PUSH(AbstractType, acceptable);
+		  pc --;
+		  SYNCH();
+		  if (!m->waiting) m->waiting = SQueueCreate();
+		  SQueueInsertFront(m->waiting, state);
+		  TRACE(process, 3, ("Blocking synchronizing process %#x", state));
+		  return 1;
+		} else {
+		  m->busy = 3;
+		  SYNCH();
+		  assert(m->waiting);
+		  SQueueInsertFront(m->waiting, state);
+		  TRACE(process, 3, ("Synchronizing process accepted state %#x", otherstate));
+		  state = otherstate;
+		  UNSYNCH();
+		}
                }
+ 
     BREAKPT "" {
 		 DEBUG("Breakpoint");
     	       }
@@ -1270,10 +1307,9 @@
 		   }
     GCOLLECT "" {
 		  {
-		    extern void startDistGC(void);
+		    SYNCH();
 		    gcollect();
-		    gcollect_old();
-		    startDistGC();
+		    UNSYNCH();
 		  }
 		}
     LAND ""     { BINARY(s32,&) }
@@ -1354,13 +1390,64 @@
 		  POP(ConcreteType, xct);
 		  fixObjectReferenceFromSeq(id, (Object)xct, OffsetOf(xct, &xct->d.type));
 		}
-@ STUBCALL and STUBRETURN are obsolete opcodes from an old attempt at
-@ remote invocation  -bwe
-    STUBCALL "" {
-                   SYNCH(); obsolete("STUBCALL", state);
+@ Initialize a lock for an object which is synchronized using accept
+   SYNCHINIT "" {
+		   monitor *m = (monitor *)((Object) op)->d;
+		   /*
+		    * Busy encodes two things:
+		    *	Low order bit:  open (== 0) or locked (== 1)
+		    *	Next bit:       process alive (== 2) or dead (== 0)
+		    *
+		    * The initial value is 3, locked and the process is alive
+		    * (or at least, hasn't died yet).
+		    */
+		   m->busy = 3;
+		   m->waiting = 0;
+		 }
+@ Enter a routine which is synchronized using accept
+   SYNCHENTER "" {
+		   monitor *m = (monitor *)((Object) op)->d;
+		   State *otherstate;
+		   if (prevOP(fp) == op) {
+		     TRACE(process, 3, ("SYNCHENTER on self invoke, passed"));
+		   } else {
+		     switch (m->busy) {
+		     case 0:
+		       /*
+			* Process dead, object unlocked.
+			*/
+		       m->busy = 1;
+		       break;
+		     case 1:
+		     case 3:
+		       /*
+			* Process dead or alive, object locked.
+			*/
+		       SYNCH();
+		       if (!m->waiting) m->waiting = SQueueCreate();
+		       SQueueInsert(m->waiting, state);
+		       TRACE(process, 3, ("Blocking process %x - synchronized object entry",
+					  state));
+		       return 1;
+		       break;
+		     case 2:
+		       /*
+			* Process alive, object unlocked.  The process will be
+			* at the head of the waiting queue, so block yourself and
+			* run it.  It will decide whether to allow entry.
+			*/
+		       assert(m->waiting);
+		       SYNCH();
+		       otherstate = SQueueRemove(m->waiting);
+		       SQueueInsert(m->waiting, state);
+		       state = otherstate;
+		       UNSYNCH();
+		       break;
+		     default:
+		       assert(0);
+		       break;
+		     }
 		 }
-   STUBRETURN "" {
-                   SYNCH(); obsolete("STUBRETURN", state);
                  }
 @GETOID returns three integers: the ipaddress, the incarnation (port and epoch), and the seq
 @ of the OID of the argument object.  If the 
@@ -1391,9 +1478,31 @@
 		    PUSH(u32, theOID.Seq);
 		    PUSH(ConcreteType, intct);
 		  }
-@ TESTREMOTE is an obsolete opcode in the same way as STUB* above
-  TESTREMOTE "" {
-                  SYNCH(); obsolete("TESTREMOTE", state);
+@ Exit a routine which is synchronized using accept
+    SYNCHEXIT "" {
+		   monitor *m = (monitor *)((Object) op)->d;
+		   State *otherstate;
+		   if (prevOP(fp) == op) {
+		     TRACE(process, 3, ("SYNCHEXIT of self invoke - passed"));
+		   } else {
+		     if ((otherstate = SQueueRemove(m->waiting)) != NULL) {
+		       /*
+			* Either the process is still alive or some other
+			* operation wants in, in either case, schedule it.
+			*/
+		       makeReady(otherstate);
+		       TRACE(process, 3, ("Unblocking process %x - synchronized object exit",
+					  otherstate));
+		     } else {
+		       /*
+			* There is no other process waiting, the process
+			* better be dead and we want to unlock the object.
+			*/
+		       assert(m->busy == 1);
+		       m->busy = 0;
+		       TRACE(process, 3, ("No waiters - synchronized object exit"));
+		     }
+		   }
 		}
     GETIDSEQ ""	{
 		  OID oid;
@@ -1408,9 +1517,27 @@
 		  }
 		  PUSH(u32, oid.Seq);
 		}
-@ general purpose escape to the system
-    CCALL "u8"  {
-		  SYNCH(); obsolete("CCALL", state);
+@ announce the death of the synchronizing process
+    SYNCHDIE "" {
+		   monitor *m = (monitor *)((Object) op)->d;
+		   State *otherstate;
+		   assert(m->busy == 3);
+
+		   if ((otherstate = SQueueRemove(m->waiting)) != NULL) {
+		     /*
+		      * Some other operation wants in, schedule it.
+		      */
+		     makeReady(otherstate);
+		     TRACE(process, 3, ("Unblocking process %x - synchronizing process exit",
+					otherstate));
+		     m->busy = 1;
+		   } else {
+		     /*
+		      * There is no other process waiting, we want to unlock the object.
+		      */
+		     m->busy = 0;
+		     TRACE(process, 3, ("No waiters - synchronizing process exit"));
+		   }
 		}
     LDLITB "u8"	{ 
       		  u8 t;
@@ -1448,8 +1575,11 @@
       sp -= 4 * n;
     }
 
-    TESTREMOTE2 "" {
-      SYNCH(); obsolete("TESTREMOTE2", state);
+    GCOLLECTOLD "" {
+		     SYNCH();
+		     gcollect();
+		     gcollect_old();
+		     UNSYNCH();
     }
   
     CODEOF "" {
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/vm.h ubc-latest-src/vm/src/vm.h
--- ubc-1.05alpha-src/vm/src/vm.h	2017-12-11 17:59:03.429711894 +0100
+++ ubc-latest-src/vm/src/vm.h	2017-12-11 17:59:03.492711414 +0100
@@ -42,7 +42,7 @@
 #define STVOB 41
 #define STVAB 42
 #define DUP 43
-#define DUPV 44
+#define ENSURESPACE 44
 #define SWAP 45
 #define ADD 46
 #define SUB 47
@@ -114,7 +114,7 @@
 #define CREATEVECLIT 113
 #define STRHASH 114
 #define BREAKME 115
-#define FORWARD 116
+#define ACPTBLCK 116
 #define BREAKPT 117
 #define UPB 118
 #define STRLIT 119
@@ -151,17 +151,17 @@
 #define DLOAD 150
 #define RELOCATEVECTOR 151
 #define RELOCATETYPE 152
-#define STUBCALL 153
-#define STUBRETURN 154
+#define SYNCHINIT 153
+#define SYNCHENTER 154
 #define GETOID 155
-#define TESTREMOTE 156
+#define SYNCHEXIT 156
 #define GETIDSEQ 157
-#define CCALL 158
+#define SYNCHDIE 158
 #define LDLITB 159
 #define SWAPV 160
 #define DOCTLITERALS 161
 #define CVX 162
-#define TESTREMOTE2 163
+#define GCOLLECTOLD 163
 #define CODEOF 164
 #define BUILDABCON 165
 #define CHECKARGABCONB 166
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/vm_i.h ubc-latest-src/vm/src/vm_i.h
--- ubc-1.05alpha-src/vm/src/vm_i.h	2017-12-11 17:59:03.430711886 +0100
+++ ubc-latest-src/vm/src/vm_i.h	2017-12-11 17:59:03.492711414 +0100
@@ -263,6 +263,7 @@
       TIMESLICELOCALS
 #endif /* SINGLESTEP */
 
+#define prevOP(xx) ((Object)((u32 *)xx)[-3])
 
 #define NINSTRUCTIONS 185
 typedef struct State {
@@ -273,6 +274,7 @@
   u32 sb;		/* Stack base */
   Object op;		/* Object pointer */
   ConcreteType cp;		/* Concrete type */
+  OpVectorElement opp;		/* Operation pointer */
   Object ep;		/* Environment pointer */
   ConcreteType et;		/* Environment type */
   OID nsoid;		/* Next SS OID */
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/write.c ubc-latest-src/vm/src/write.c
--- ubc-1.05alpha-src/vm/src/write.c	2017-12-11 17:59:03.430711886 +0100
+++ ubc-latest-src/vm/src/write.c	2017-12-11 17:59:03.492711414 +0100
@@ -226,7 +226,7 @@
 {
   assert(ct);
 
-  if ((int) ct < NUMBUILTINS) {
+  if ((unsigned int) ct < NUMBUILTINS) {
     assert(0);
     return sizeofObject;
   } else if (ct->d.instanceSize >= 0) {
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/xdr_float.c ubc-latest-src/vm/src/xdr_float.c
--- ubc-1.05alpha-src/vm/src/xdr_float.c	2017-12-11 17:59:03.430711886 +0100
+++ ubc-latest-src/vm/src/xdr_float.c	2017-12-11 17:59:03.493711406 +0100
@@ -30,7 +30,7 @@
 #if defined(LIBC_SCCS) && !defined(lint)
 /*static char *sccsid = "from: @(#)xdr_float.c 1.12 87/08/11 Copyr 1984 Sun Micro";*/
 /*static char *sccsid = "from: @(#)xdr_float.c	2.1 88/07/29 4.0 RPCSRC";*/
-static char *rcsid = "$Id: xdr_float.c,v 1.1 1997/01/21 23:59:53 norm Exp norm $";
+static char *rcsid = "$Id: xdr_float.c,v 1.1 1997/01/21 23:59:53 norm Exp $";
 #endif
 
 /*
diff -x Makefile.in -x COPYING -x CVS -x configure -x '*.ps' -x vmclex.c -x vmcpar.c -x vmcpar.h -x parse.m -x emx.exe -x emx.ncb -x emx.opt -x emx.dsp -x emx.dsw -x emx.mak -x emx.plg -I '^\([ /]\*.*\)\?$' --ignore-space-change --ignore-blank-lines -ruN ubc-1.05alpha-src/vm/src/xsys.c ubc-latest-src/vm/src/xsys.c
--- ubc-1.05alpha-src/vm/src/xsys.c	2017-12-11 17:59:03.430711886 +0100
+++ ubc-latest-src/vm/src/xsys.c	2017-12-11 17:59:03.493711406 +0100
@@ -42,8 +42,7 @@
 static XEvent *waitingEvent;
 static State *waitingState;
 
-void *XCreateDisplay(es)
-String es;
+void XCreateDisplay(String es)
 {
 
   if (es == (String)JNIL) {
@@ -55,7 +54,7 @@
     free(s);
   }
   if (display == NULL) {
-    TRACE0(x, 0, "Cannot initialize display");
+    TRACE(x, 0, ("Cannot initialize display"));
     exit(1);
   } 
   black = BlackPixel(display,DefaultScreen(display));
@@ -65,15 +64,15 @@
 static int tryRead(XEvent *ev)
 {
   if (XPending(display) > 0) {
-    TRACE0(x, 5, "XEvent: calling NextEvent");
+    TRACE(x, 5, ("XEvent: calling NextEvent"));
     XNextEvent(display, ev);
-    TRACE0(x, 5, "XEvent: NextEvent returned");
-    TRACE5(x, 5, "event = (%d %d %d %d %d)", 
+    TRACE(x, 5, ("XEvent: NextEvent returned"));
+    TRACE(x, 5, ("event = (%d %d %d %d %d)", 
       *(0 + (int *)ev),
       *(1 + (int *)ev),
       *(2 + (int *)ev),
       *(3 + (int *)ev),
-      *(4 + (int *)ev));
+      *(4 + (int *)ev)));
     return 1;
   } else {
 /*     XSync(display, False); */
@@ -85,73 +84,59 @@
 /*      EMXReadEvent                                                    */
 /**********************************************************************/
 /* Kernel Call */
-int EMXReadEvent(u32 sp)
+int EMXReadEvent(int *sp)
 {
   Bitchunk                      event;
   XEvent			* ev;
 
-  TRACE0(x, 3, "EMXReadEvent");
+  TRACE(x, 3, ("EMXReadEvent"));
 
   event = *(Bitchunk *)sp;
   if (ISNIL(event)) {
-    TRACE0(x, 0, "Event is NIL in EMXReadEvent.");
+    TRACE(x, 0,("Event is NIL in EMXReadEvent."));
     return 0;
   }
 
   /* Check the size of the Bitchunk */
   if (event->d.items < sizeof(XEvent)) {
-    TRACE2(x, 2, "Read attempt with a too small Bitchunk: %d should be %d.",
-      event->d.items, sizeof(XEvent));
+    TRACE(x, 2, ("Read attempt with a too small Bitchunk: %d should be %d.",
+      event->d.items, sizeof(XEvent)));
     return 0;
   }
 
   /* Check for a display */
   if (!display) {
-    TRACE0(x, 1, "Read attempt with no display (= nil).");
+    TRACE(x, 1, ("Read attempt with no display (= nil)."));
     return 0;
   }
 
   ev = (XEvent *)&event->d.data[0];
-#ifdef RTTHREADS
-  RttBeginCritical();
-#endif
   if (tryRead(ev)) {
-#ifdef RTTHREADS
-    RttEndCritical();
-#endif
   } else {
     do {
-#ifdef RTTHREADS
-      RttEndCritical();
-#endif
-      vmRead(ConnectionNumber(display), 0, 0);
-#ifdef RTTHREADS
-      RttBeginCritical();
-#endif
+      processEverythingOnce();
     } while (tryRead(ev) == 0);
   }
   return 0;
 }
 
-int EMXCreateWindow(sp)
-long *sp;
+int EMXCreateWindow(int *sp)
 {
   int x = sp[0], y = sp[1], w = sp[2], h = sp[3];
   String name = (String) sp[4];
   Window window;
   XSizeHints xsh;
-  XEvent event;
   char *cname;
 
   sp[0] = (long) JNIL;
 
   if (display == NULL) {
-    TRACE0(x, 1, "Create window called with no display");
+    TRACE(x, 1, ("Create window called with no display"));
     return 1;
   }
 
   JTOCString(name, cname);
-  TRACE1(x, 3, "Create window named %s", cname);
+  TRACE(x, 3, ("Create window named %s", cname));
 
   xsh.x = x;
   xsh.y = y;
@@ -159,11 +144,11 @@
   xsh.height = h;
   xsh.flags = (USPosition|USSize); 
 
-  TRACE4(x, 3, "Create window at (%d, %d) size (%d, %d)",
-    xsh.x, xsh.y, xsh.width, xsh.height);
+  TRACE(x, 3, ("Create window at (%d, %d) size (%d, %d)",
+    xsh.x, xsh.y, xsh.width, xsh.height));
   window = XCreateSimpleWindow(display, DefaultRootWindow(display), xsh.x,
 			       xsh.y, xsh.width, xsh.height, 1, black, white);
-  TRACE1(x, 3, "XCreateWindow returns %d", window);
+  TRACE(x, 3, ("XCreateWindow returns %d", window));
   XSetStandardProperties(display,window,cname,cname,None,NULL,0,&xsh);
 /*  XSetWMHints(display,window,&xwmh); */
   XMapWindow(display,window);
@@ -183,8 +168,7 @@
  * Jyhlin Chang Jul 15,1988
  *-----------------------------------------------------------------------*/
 
-int EMXSelectInput(sp)
-long *sp;
+int EMXSelectInput(int *sp)
 {
   Window w = sp[0];
   unsigned long event_mask = sp[1];
@@ -207,7 +191,6 @@
   Font font;
   FontInfoPtr fi;
   XGCValues gcvalues;
-  int flags;
 
   font = (Font) SIScLookup(nameToFont, fontname);
   if (SIScIsNIL(font)) {
@@ -229,13 +212,11 @@
   IIScInsert(GCToFontInfo, (int)gc, (int)fi);  
 }
     
-int EMXInitGc(sp)
-long *sp;
+int EMXInitGc(int *sp)
 {
   Window win = sp[0];
   XGCValues gcvalues;
   GC gc;
-  char *fontname;
   int flags;
 
   TRACE(x, 3, ("XInitGC"));
@@ -251,8 +232,7 @@
   return 1;
 }
 
-int EMXSetWidth(sp )
-long *sp;
+int EMXSetWidth(int *sp)
 {
   GC gc = (GC) sp[0];
   Window  win = (Window) sp[1];
@@ -264,8 +244,7 @@
   return 0;
 } 
 
-EMXSetFont(sp)
-long *sp;
+int EMXSetFont(int *sp)
 {
   GC gc = (GC) sp[0];
   Window win = (Window)sp[1];
@@ -278,110 +257,102 @@
   return 0;
 }
 
-int EMXLine(sp)
-long *sp;
+int EMXLine(int *sp)
 {
   Window win = (Window)sp[0];
   int  x1 = sp[1], y1 = sp[2];
   int  x2 = sp[3], y2 = sp[4];
   GC gc = (GC)sp[5];
 
-  TRACE5(x, 3, "X Line on window %d from (%d, %d) to (%d, %d)",
-    win, x1, y1, x2, y2);
+  TRACE(x, 3, ("X Line on window %d from (%d, %d) to (%d, %d)",
+    win, x1, y1, x2, y2));
   XDrawLine(display,win,gc,x1, y1, x2, y2);
-  TRACE0(x, 3, "XLine done");
+  TRACE(x, 3, ("XLine done"));
   return 0;
 }
 
-int EMXTextWidth(long *sp)
+int EMXTextWidth(int *sp)
 {
   Window win = (Window)sp[0];
   String string = (String)sp[1]; 
   GC gc = (GC)sp[2];
   FontInfoPtr fi;
   
-  TRACE2(x, 3, "XTextWidth begin %.*s", string->d.items, string->d.data);
+  TRACE(x, 3, ("XTextWidth begin %.*s", string->d.items, string->d.data));
   fi = (FontInfoPtr)IIScLookup(GCToFontInfo, (int)gc);
   assert(!IIScIsNIL(fi));
   sp[0] = XTextWidth(fi->f, (char *)string->d.data, string->d.items);
-  TRACE0(x, 3, "XTextWidth done");
+  TRACE(x, 3, ("XTextWidth done"));
   return 1;
 }
   
-int EMXString(sp)
-long *sp;
+int EMXString(int *sp)
 {
   Window win = (Window)sp[0];
   String string = (String)sp[1]; 
   int x = sp[2], y = sp[3];
   GC gc = (GC)sp[4];
 
-  TRACE2(x, 3, "XString begin %.*s", string->d.items, string->d.data);
+  TRACE(x, 3, ("XString begin %.*s", string->d.items, string->d.data));
   XDrawString(display, win, gc, x, y, (char *)string->d.data, string->d.items);
-  TRACE0(x, 3, "XString done");
+  TRACE(x, 3, ("XString done"));
   return 0;
 }
 
-int EMXConfigureWindow(sp)
-long *sp;
+int EMXConfigureWindow(int *sp)
 {
   Window win = (Window)sp[0];
   int x = sp[1], y = sp[2], w = sp[3], h = sp[4];
   XWindowChanges values;
 
-  TRACE5(x, 3, "X ConfigureWindow on window %d (%d, %d) (%d, %d)",
-    win, x, y, w, h);
+  TRACE(x, 3, ("X ConfigureWindow on window %d (%d, %d) (%d, %d)",
+    win, x, y, w, h));
   values.x = x;
   values.y = y;
   values.width = w;
   values.height = h;
   XConfigureWindow(display, win, CWX|CWY|CWWidth|CWHeight, &values);
-  TRACE0(x, 3, "XConfigureWindow done");
+  TRACE(x, 3, ("XConfigureWindow done"));
   return 0;
 }
 
-int EMXFlush()
+int EMXFlush(int *sp)
 {
-  TRACE0(x, 3, "X Flush called");
+  TRACE(x, 3, ("X Flush called"));
   XFlush(display);
-  TRACE0(x, 3, "X Flush done");
+  TRACE(x, 3, ("X Flush done"));
   return 0;
 }
 
-int EMXWFlush(sp)
-long *sp;
+int EMXWFlush(int *sp)
 {
   Window w = (Window) sp[0];
   XFlush(display);
   return 0;
 }
 
-EMXRaiseWindow(sp) 
-long *sp;
+int EMXRaiseWindow(int *sp)
 {
   Window w = (Window)sp[0];
   XRaiseWindow(display, w);
   return 0;
 }
 
-EMXLowerWindow(sp) 
-long *sp;
+int EMXLowerWindow(int *sp)
 {
   Window w = (Window)sp[0];
   XLowerWindow(display, w);
   return 0;
 }
 
-EMXUnmapWindow(sp) 
-long *sp;
+int EMXUnmapWindow(int *sp)
 {
   Window w = (Window)sp[0];
   XUnmapWindow(display, w);
   return 0;
 }
 
-EMXResizeWindow(sp)
-long *sp;
+int EMXResizeWindow(int *sp)
 {
   Window w =(Window)sp[0];
   int x = sp[1],y = sp[2];
@@ -389,8 +360,7 @@
   return 0;
 }
 
-EMXMoveWindow(sp)
-long *sp;
+int EMXMoveWindow(int *sp)
 {
   Window w =(Window)sp[0];
   int x = sp[1],y = sp[2];
@@ -398,16 +368,14 @@
   return 0;
 }
 
-EMXClearWindow(sp)
-long *sp;
+int EMXClearWindow(int *sp)
 {
   Window w = (Window)sp[0];
   XClearWindow(display, w);
   return 0;
 }
 
-EMXClearArea(sp)
-long *sp;
+int EMXClearArea(int *sp)
 {
   Window w = (Window)sp[0];
   int tlx = sp[1], tly = sp[2], width = sp[3], height = sp[4];
@@ -415,15 +383,14 @@
   return 0;
 }
 
-EMXCloseWindow(sp)
-long *sp;
+int EMXCloseWindow(int *sp)
 {
   Window w = (Window)sp[0];
   XDestroyWindow(display,w);
   return 0;
 }
 
-EMXBatch(long *sp)
+int EMXBatch(int *sp)
 {
   int value = sp[0];
   if (value) {
@@ -431,7 +398,7 @@
   return 0;
 }
 
-EMXGet(long *sp)
+int EMXGet(int *sp)
 {
   Window win = (Window)sp[0];
   String string = (String)sp[1]; 
@@ -439,7 +406,7 @@
   return 1;
 }
 
-EMXSet(long *sp)
+int EMXSet(int *sp)
 {
   Window win = (Window)sp[0];
   String string = (String)sp[1]; 
@@ -454,8 +421,7 @@
 #define BUFFERSIZE 255
 static char CInputBuffer[BUFFERSIZE];
 
-int EMXGetCharacter(sp)
-long *sp;
+int EMXGetCharacter(int *sp)
 {
   Bitchunk                      event = (Bitchunk)sp[0];
   int                             length;
@@ -465,43 +431,45 @@
   sp[0] = (long)JNIL;
 
   if (event == (Bitchunk) JNIL) {
-    TRACE0(x, 2, "Event is NIL in EMXGetCharacter.");
+    TRACE(x, 2, ("Event is NIL in EMXGetCharacter."));
     return 1;
   }
 
   ev = (XEvent *)event->d.data; 
-  TRACE5(x, 5, "event = (%d %d %d %d %d)", 
+  TRACE(x, 5, ("event = (%d %d %d %d %d)", 
     *(0 + (int *)ev),
     *(1 + (int *)ev),
     *(2 + (int *)ev),
     *(3 + (int *)ev),
-    *(4 + (int *)ev));
+    *(4 + (int *)ev)));
 
-  TRACE0(x, 5, "Before XLookupString");
+  TRACE(x, 5, ("Before XLookupString"));
   CInputBuffer[0] = '\0';
   length = XLookupString((XKeyEvent *)ev, CInputBuffer, BUFFERSIZE,
 			 (KeySym *)NULL, (XComposeStatus *)NULL);
-  TRACE3(x, 5, "After XLookupString, len=%d, str=%s, end=%d", length,
-	 CInputBuffer, *(CInputBuffer+length));
+  TRACE(x, 5, ("After XLookupString, len=%d, str=%s, end=%d", length,
+	 CInputBuffer, *(CInputBuffer+length)));
 
-  s = (String)CreateString(CInputBuffer, length);
-  TRACE1(x, 5, "After BuildString, s = %x", s);
+  s = (String)CreateString(CInputBuffer);
+  TRACE(x, 5, ("After BuildString, s = %x", s));
   sp[0] = (long) s;
   return 1;
 } 
 
-int EMXInit()
+int EMXInit(int *sp)
 {
-  TRACE0(x, 1, "XInit");
+  TRACE(x, 1, ("XInit"));
   XCreateDisplay((String)JNIL);
   GCToFontInfo = IIScCreate();
   nameToFont = SIScCreate();
+#if 0
   MTRegisterFD(ConnectionNumber(display));
+#endif
   return 0;
 }
 #endif
 
-int (*xfuncs[])() = {
+int (*xfuncs[])(int *) = {
 #ifdef XWindows
   EMXInitGc,		/* 0 */
   EMXSetFont,		/* 1 */
